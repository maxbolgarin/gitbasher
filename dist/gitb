#!/usr/bin/env bash
if [ "$1" == "init" ]; then
git init
fi
git_check=$(git branch --show-current 2>&1)
if [[ "$git_check" == *"fatal: not a git repository"* ]]; then
echo "You can use gitb only in a git repository"
exit
fi
if ((BASH_VERSINFO[0] < 4)); then
printf "Sorry, you need at least ${YELLOW}bash-4.0${ENDCOLOR} to run gitbasher.n
If your OS is debian-based, use:
${GREEN}apt install --only-upgrade bash${ENDCOLOR}n
If your OS is Mac, use:
${GREEN}brew install bash${ENDCOLOR}nn"
exit 1;
fi
RED="\e[31m"
GREEN="\e[32m"
YELLOW="\e[33m"
BLUE="\e[34m"
PURPLE="\e[35m"
CYAN="\e[36m"
GRAY="\e[37m"
ENDCOLOR="\e[0m"
BOLD="\033[1m"
NORMAL="\033[0m"
function get_config_value {
    value=$(git config --local --get $1)
    if [ "$value" == "" ]; then
        value=$(git config --global --get $1)
        if [ "$value" == "" ]; then
            value=$2
        fi
    fi
    echo -e "$value"
}
current_branch=$(git branch --show-current)
main_branch=$(get_config_value gitbasher.branch "main")
if [[ "$( git branch | grep "^[\s\*]*\s*main\s*$" )" == "" ]] && [[ "$( git branch | grep "^[\s\*]*\s*master\s*$" )" != "" ]]; then
    main_branch="master"
elif [[ "$(git branch | cat)" == "" ]]; then
    main_branch=$current_branch
fi
if [ "$(get_config_value gitbasher.branch "")" == "" ]; then
    git config --local gitbasher.branch "$main_branch"
fi
origin_name=$(git remote -v | head -n 1 | sed 's/\t.*//')
if [ "$origin_name" == "" ]; then 
    echo -e "${YELLOW}There is no configured remote in this repo!${ENDCOLOR}"
    echo
    echo -e "Use ${BLUE}git remote add origin <url>${ENDCOLOR} to add it manually"
    echo -e "Press '${BOLD}y${ENDCOLOR}' to add it now or an any key to exit"
    read -n 1 -s choice
    if [ "$choice" != "y" ]; then
        exit
    fi
    echo
    read -p "Remote repo URL: " -e remote_url
    if [ "$remote_url" == "" ]; then
        exit
    fi
    remote_check=$(git ls-remote "$remote_url" 2>&1)
    if [[ "$remote_check" == *"does not appear to be a git"* ]]; then
        echo
        echo -e "${RED}'$remote_url' is not a git repository!${ENDCOLOR}"
        echo "Please make sure you have the correct access rights and the repository exists."
        exit
    fi
    git remote add origin "$remote_url"
    echo -e "${GREEN}Remote successfully added!${ENDCOLOR}"
    if [ "$remote_check" == "" ]; then
        echo -e "${YELLOW}Repository '$remote_url' is probably empty${ENDCOLOR}"
    fi
    echo
    origin_name=$(git remote -v | head -n 1 | sed 's/\t.*//')
fi
sep=$(get_config_value gitbasher.sep "-")
editor=$(get_config_value core.editor "vi")
ticket_name=$(get_config_value gitbasher.ticket "")
scopes=$(get_config_value gitbasher.scopes "")
is_first=$(get_config_value gitbasher.isfirst "true")
git config --local gitbasher.isfirst "false"
RED_ES="\x1b[31m"
GREEN_ES="\x1b[32m"
YELLOW_ES="\x1b[33m"
BLUE_ES="\x1b[34m"
PURPLE_ES="\x1b[35m"
CYAN_ES="\x1b[36m"
GRAY_ES="\x1b[37m"
ENDCOLOR_ES="\x1b[0m"
function set_config_value {
    if [ -z $3 ]; then
        git config --local $1 $2
    else
        git config --global $1 $2
    fi
    echo "$2"
}
function wrong_mode {
    if [ -n "$2" ]; then
        echo -e "Unknown mode ${YELLOW}$2${ENDCOLOR} for ${YELLOW}gitb $1${ENDCOLOR}"
        echo -e "Use ${GREEN}gitb $1 help${ENDCOLOR} to get usage info"
        exit
    fi
}
function get_repo {
    repo=$(git config --get remote.${origin_name}.url)
    repo="${repo/"com:"/"com/"}"
    repo="${repo/"io:"/"io/"}"
    repo="${repo/"org:"/"org/"}"
    repo="${repo/"net:"/"net/"}"
    repo="${repo/"dev:"/"dev/"}"
    repo="${repo/"ru:"/"ru/"}"
    repo="${repo/"git@"/"https://"}"
    repo="${repo/".git"/""}" 
    echo "$repo"
}
function get_repo_name {
    repo=$(get_repo)
    echo "${repo##*/}"
}
function print_configuration {
    echo -e "${YELLOW}Current configuration:${ENDCOLOR}"
    echo -e "\tuser.name:\t${YELLOW}$(get_config_value user.name)${ENDCOLOR}"
    echo -e "\tuser.email:\t${YELLOW}$(get_config_value user.email)${ENDCOLOR}"
    echo -e "\tdefault:\t${YELLOW}$main_branch${ENDCOLOR}"
    echo -e "\tseparator:\t${YELLOW}$sep${ENDCOLOR}"
    echo -e "\teditor:\t\t${YELLOW}$editor${ENDCOLOR}"
    if [ "$ticket_name" != "" ]; then
        echo -e "\tticket:\t\t${YELLOW}$ticket_name${ENDCOLOR}"
    fi
    if [ "$scopes" != "" ]; then
        echo -e "\tscopes:\t\t${YELLOW}$scopes${ENDCOLOR}"
    fi
    local ai_key=$(get_ai_api_key)
    if [ -n "$ai_key" ]; then
        ai_key=$(mask_api_key "$ai_key")
        echo -e "\tAI key:\t\t${GREEN}$ai_key${ENDCOLOR}"
    else
        echo -e "\tAI key:\t\t${RED}not set${ENDCOLOR}"
    fi
    local ai_proxy=$(get_ai_proxy)
    if [ -n "$ai_proxy" ]; then
        echo -e "\tAI proxy:\t${GREEN}$ai_proxy${ENDCOLOR}"
    else
        echo -e "\tAI proxy:\t${YELLOW}not set${ENDCOLOR}"
    fi
}
function escape {
    string="$1"
    sub="$2"
    escaped="\\$sub"
    echo "${string//${sub}/${escaped}}"
}
function check_code {
    if [ $1 != 0 ]; then
        echo
        echo
        echo -e "${RED}Error during $3!${ENDCOLOR}"
        echo -e "$2"
        if [ -n "$git_add" ]; then
            git restore --staged $git_add
        fi
        exit $1
    fi
}
function yes_no_choice {
    while [ true ]; do
        read -n 1 -s choice
        if [ "$choice" == "y" ]; then
            if [ -n "$1" ]; then
                echo -e "${YELLOW}$1${ENDCOLOR}"
                if [ -z $2 ]; then
                    echo
                fi
            fi
            return
        fi
        if [ "$choice" == "n" ]; then
            exit
        fi
    done
}
function choose {
    values=("$@")
    number_of_values=${#values[@]}
    while [ true ]; do
        if [ $number_of_values -gt 9 ]; then
            read -p "$read_prefix" -e -n 2 choice
        else
            read -p "$read_prefix" -n 1 -s choice
        fi
        if [ "$choice" == "0" ] || [ "$choice" == "00" ]; then
            if [ -n "$git_add" ]; then
                git restore --staged $git_add
            fi
            if [ $number_of_values -le 9 ]; then
                printf $choice
            fi
            exit
        fi
        re='^[0-9=]+$'
        if ! [[ $choice =~ $re ]]; then
            if [ -n "$git_add" ]; then
                git restore --staged $git_add
            fi
            exit
        fi
        if [ "$choice" == "=" ] || [ "$choice" == "==" ]; then
            pressed_alt="true"
            break
        fi
        index=$(($choice-1))
        choice_result=${values[index]}
        if [ -n "$choice_result" ]; then
            if [ $number_of_values -le 9 ]; then
                printf $choice
            fi
            break
        else
            if [ $number_of_values -gt 9 ]; then
                if [ -n "$git_add" ]; then
                    git restore --staged $git_add
                fi
                exit
            fi
        fi
    done
}
function git_status {
    status_output=$(git status --short)
    status_output=$(echo "$status_output" | sed "s/^ D/${RED_ES}\tDeleted: ${ENDCOLOR_ES}/")
    status_output=$(echo "$status_output" | sed "s/^D /${GREEN_ES}Staged\t${RED_ES}Deleted: ${ENDCOLOR_ES}/")
    status_output=$(echo "$status_output" | sed "s/^ M/${YELLOW_ES}\tModified:${ENDCOLOR_ES}/")
    status_output=$(echo "$status_output" | sed "s/^MM/${GRAY_ES}Old\t${YELLOW_ES}Modified:${ENDCOLOR_ES}/")
    status_output=$(echo "$status_output" | sed "s/^AM/${GRAY_ES}Old\t${YELLOW_ES}Modified:${ENDCOLOR_ES}/")
    status_output=$(echo "$status_output" | sed "s/^M /${GREEN_ES}Staged\t${YELLOW_ES}Modified:${ENDCOLOR_ES}/")
    status_output=$(echo "$status_output" | sed "s/^A/${GREEN_ES}Staged\tAdded:   ${ENDCOLOR_ES}/")
    status_output=$(echo "$status_output" | sed "s/^??/${GREEN_ES}\tAdded:   ${ENDCOLOR_ES}/")
    echo -e "$status_output"
}
function commit_list {
    ref=$3
    if [[ "$(git --no-pager log -n 1 2>&1)" == *"does not have any commits yet"* ]]; then
        if [[ "$3" == *"HEAD"* ]]; then
            ref="$(echo $3 | sed 's/HEAD..//')"
        else
            return 
        fi
    fi
    IFS=$'\n' 
    read -rd '' -a commits_info <<<"$(git --no-pager log -n $1 --pretty="${YELLOW_ES}%h${ENDCOLOR_ES} | %s | ${BLUE_ES}%an${ENDCOLOR_ES} | ${GREEN_ES}%cr${ENDCOLOR_ES}" $ref | column -ts'|')"
    read -rd '' -a commits_hash <<<"$(git --no-pager log -n $1 --pretty="%h"$ref)"
    for index in "${!commits_info[@]}"
    do
        line=${commits_info[index]}
        if [ $2 == "number" ]; then
            line="$(($index+1)). ${line}"
        elif [ $2 == "tab" ]; then
            line="\t${line}"
        fi
        echo -e "$line"
    done
}
function ref_list {
    IFS=$'\n' 
    read -rd '' -a refs_info <<<"$(git --no-pager reflog -n $1 --pretty="${YELLOW_ES}%h${ENDCOLOR_ES} | ${BLUE_ES}%gd${ENDCOLOR_ES} | %gs | ${GREEN_ES}%cr${ENDCOLOR_ES}" | column -ts'|')"
    read -rd '' -a refs_hash <<<"$(git --no-pager reflog -n $1 --pretty="%gd")"
    refs_info=("${refs_info[@]:1}")
    refs_hash=("${refs_hash[@]:1}")
    for index in "${!refs_info[@]}"
    do
        line="$(($index+1)). ${refs_info[index]}"
        echo -e "$line"
    done
}
function choose_commit {
    commit_list $1 "number"
    if [ $1 -gt 9 ]; then
        echo "00. Exit"
    else
        echo "0. Exit"
    fi
    echo "Enter = to show more"
    echo
    read_prefix="Enter commit number: "
    choose "${commits_hash[@]}"
    commit_hash=$choice_result
    if [ -n "$pressed_alt" ]; then
        commit_list 50 "number"
        echo "00. Exit"
        echo
        choose "${commits_hash[@]}"
        commit_hash=$choice_result
    fi
    echo
}
function print_changes_stat {
    IFS=$'\n' read -rd '' -a stats <<< "$1"
    result_stat=""
    bottom_line=""
    number_of_stats=${#stats[@]}
    for index in "${!stats[@]}"
    do
        s=$(echo ${stats[index]} | sed -e 's/^[[:space:]]*//')
        s=$(sed "s/+/${GREEN_ES}+${ENDCOLOR_ES}/g" <<< ${s})
        s=$(sed "s/-/${RED_ES}-${ENDCOLOR_ES}/g" <<< ${s})
        if [ $(($index+1)) == $number_of_stats ]; then
            #s=$(sed '1 s/,/|/' <<< ${s})
            bottom_line="${s}"
            break
        fi
        result_stat="${result_stat}\n${s}"
    done
    echo -e "$(echo -e "${result_stat}" | column -ts'|')"
    echo -e "$bottom_line"
}
function get_push_list {
    push_list_check=$(git --no-pager log $3/$1..HEAD 2>&1)
    if [[ $push_list_check != *"unknown revision or path not in the working tree"* ]]; then
        push_list=$(commit_list 999 "tab" $3/$1..HEAD)
        history_from="$3/$1"
        return
    fi
    if [[ $push_list_check == *"unknown revision or path not in the working tree"* ]]; then
        if [[ $1 == $2 ]]; then
            push_list=$(commit_list 999 "tab")
            history_from="$3/$1"
            return
        fi
    fi
    base_commit=$(diff -u <(git rev-list --first-parent $1) <(git rev-list --first-parent $2) | sed -ne 's/^ //p' | head -1)
    if [ -n "$base_commit" ]; then
        push_list=$(commit_list 999 "tab" $base_commit..HEAD)
        history_from="${base_commit::7}"
    else
        push_list=$(commit_list 999 "tab" $3/$2..HEAD)
        history_from="$3/$2"
    fi
}
function list_branches {
    args="--sort=-committerdate"
    if [[ "$1" == "remote" ]]; then
        args="--sort=-committerdate -r"
    fi
    branches_str=$(git --no-pager branch $args --format="%(refname:short)")
    branches_info_str=$(git --no-pager branch $args --format="${BLUE_ES}%(refname:short)${ENDCOLOR_ES} | %(contents:subject) | ${YELLOW_ES}%(objectname:short)${ENDCOLOR_ES}  | ${GREEN_ES}%(committerdate:relative)${ENDCOLOR_ES}" | column -ts'|' )
    IFS=$'\n' 
    read -rd '' -a branches <<< "$branches_str"
    read -rd '' -a branches_info <<< "$branches_info_str"
    number_of_branches=${#branches[@]}
    if [[ "$1" == "remote" ]]; then
        ((number_of_branches=number_of_branches-1))
    fi
    if [[ "$number_of_branches" == 0 ]]; then
        echo
        echo -e "${YELLOW}There is no branches${ENDCOLOR}"
        to_exit="true"
        return
    fi
    branch_to_check="${branches[0]}"
    if [[ "$1" == "remote" ]]; then
        branch_to_check="${branches[1]}"
        branch_to_check="$(sed "s/${origin_name}\///g" <<< ${branch_to_check})"
    fi
    if [[ "$number_of_branches" == 1 ]] && [[ "${branch_to_check}" == "${current_branch}" ]]; then
        echo
        echo -e "There is only one branch: ${YELLOW}${current_branch}${ENDCOLOR}"
        to_exit="true"
        return
    fi
    if [[ "$1" == "delete" ]] && [[ "$number_of_branches" == 2 ]] && [[ "${current_branch}" != "${main_branch}" ]]; then
        echo
        echo -e "${YELLOW}There are no branches to delete${ENDCOLOR}"
        to_exit="true"
        return
    fi
    branches_first_main=(${main_branch})
    branches_info_first_main=("dummy")
    if [[ "$1" == "delete" ]]; then
        branches_first_main=()
        branches_info_first_main=()
    fi
    if [[ "$1" == "merge" ]] && [[ "$current_branch" == "$main_branch" ]]; then
        branches_first_main=()
        branches_info_first_main=()
    fi
    for index in "${!branches[@]}"
    do
        branch_to_check="${branches[index]}"
        if [[ "$1" == "delete" ]]; then
            if [[ "$branch_to_check" == "${current_branch}"* ]] || [[ "$branch_to_check" == "${main_branch}"* ]]; then
                continue    
            fi
        fi
        if [[ "$1" == "merge" ]]; then
            if [[ "$branch_to_check" == "${current_branch}"* ]]; then
                continue
            fi
        fi
        if [[ "$1" == "remote" ]]; then
            branch_to_check="$(sed "s/${origin_name}\///g" <<< ${branch_to_check})"
        fi
        if [[ "$branch_to_check" == "${main_branch}"* ]]; then
            branches_info_first_main[0]="${branches_info[index]}"
        elif [[ "$branch_to_check" != "HEAD->"* ]] && [[ "$branch_to_check" != "$origin_name" ]]; then 
            branches_first_main+=(${branches[index]})
            branches_info_first_main+=("${branches_info[index]}")
        fi
    done
    for index in "${!branches_info_first_main[@]}"
    do
        branch=$(escape "${branches_first_main[index]}" "/")
        if [[ "$1" == "remote" ]] && [[ "$branch" != "origin"* ]]; then
            branch="$origin_name\/$branch"
        fi
        branch_line="${branches_info_first_main[index]}"
        if [ "${branches_first_main[index]}" == "$current_branch" ]; then
            echo -e "$(($index+1)). * $branch_line"
        else
            echo -e "$(($index+1)).   $branch_line"
        fi
    done
}
function choose_branch {
    list_branches $1
    if [ -n "$to_exit" ]; then
        exit
    fi
    echo
    printf "Enter branch number: "
    choose "${branches_first_main[@]}"
    branch_name=$choice_result
    if [[ "$1" == "remote" ]]; then
        branch_name=$(sed "s/${origin_name}\///g" <<< ${branch_name})
    fi
    echo
}
function switch {
    switch_output=$(git switch $1 2>&1)
    switch_code=$?
    if [ "$switch_code" == 0 ]; then
        if [ "$current_branch" == "$1" ]; then
            echo -e "${GREEN}Already on '$1'${ENDCOLOR}"
        else
            echo -e "${GREEN}Switched to branch '$1'${ENDCOLOR}"
            changes=$(git_status)
            if [ -n "$changes" ] && [ -z $2 ]; then
                echo
                echo -e "${YELLOW}Moved changes:${ENDCOLOR}"
                echo -e "$changes"
            fi
        fi
        if [ -z $2 ]; then
            get_push_list $1 ${main_branch} ${origin_name}
            if [ -n "$push_list" ]; then
                echo
                count=$(echo -e "$push_list" | wc -l | sed 's/^ *//;s/ *$//')
                echo -e "Your branch ${YELLOW}$1${ENDCOLOR} is ahead ${YELLOW}${history_from}${ENDCOLOR} by ${BOLD}$count${ENDCOLOR} commits"
                echo -e "$push_list"
            fi
        fi
        return
    fi
    if [[ $switch_output == *"Your local changes to the following files would be overwritten"* ]]; then
        conflicts="$(echo "$switch_output" | tail -r | tail -n +3 | tail -r | tail -n +2)"
        echo -e "${RED}Changes would be overwritten by switch to '$1':${ENDCOLOR}"       
        echo -e "${conflicts//[[:blank:]]/}"
        echo
        echo -e "${YELLOW}Commit these files and try to switch for one more time${ENDCOLOR}"
        exit
    fi
    if [ $switch_code -ne 0 ]; then
        echo -e "${RED}Cannot switch to '$main_branch'! Error message:${ENDCOLOR}"
        echo -e "$switch_output"
        exit $switch_code
    fi
}
source scripts/common.sh
function get_ai_api_key {
    get_config_value gitbasher.ai-api-key ""
}
function set_ai_api_key {
    set_config_value gitbasher.ai-api-key "$1"
}
function get_ai_proxy {
    get_config_value gitbasher.ai-proxy ""
}
function set_ai_proxy {
    set_config_value gitbasher.ai-proxy "$1"
}
function clear_ai_proxy {
    git config --unset gitbasher.ai-proxy 2>/dev/null
}
function mask_api_key {
    local api_key="$1"
    if [ -z "$api_key" ]; then
        echo ""
        return
    fi
    local length=${#api_key}
    if [ $length -le 4 ]; then
        echo "$api_key"
        return
    fi
    local visible_chars="${api_key:(-4)}"
    echo "********${visible_chars}"
}
function call_gemini_api {
    local prompt="$1"
    local api_key=$(get_ai_api_key)
    if [ -z "$api_key" ]; then
        echo -e "${RED}AI API key not configured. Set it with: gitb config${ENDCOLOR}" >&2
        return 1
    fi
    local escaped_prompt=$(echo "$prompt" | sed 's/\\/\\\\/g' | sed 's/"/\\"/g' | tr '\n' ' ' | sed 's/  */ /g')
    local json_payload="{
        \"contents\": [{
            \"parts\": [{
                \"text\": \"$escaped_prompt\"
            }]
        }],
        \"generationConfig\": {
            \"temperature\": 0.1,
            \"maxOutputTokens\": 100,
            \"topP\": 0.8,
            \"topK\": 10
        }
    }"
    local proxy_url=$(get_ai_proxy)
    local response=""
    if [ -n "$proxy_url" ]; then
        response=$(curl -s -X POST \
            --proxy "$proxy_url" \
            "https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${api_key}" \
            -H "Content-Type: application/json" \
            -d "$json_payload" 2>/dev/null)
    else
        response=$(curl -s -X POST \
            "https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${api_key}" \
            -H "Content-Type: application/json" \
            -d "$json_payload" 2>/dev/null)
    fi
    if [ $? -ne 0 ] || [ -z "$response" ]; then
        echo -e "${RED}Failed to connect to AI service${ENDCOLOR}" >&2
        return 1
    fi
    local has_error=$(echo "$response" | grep -q '"error"' && echo "true" || echo "false")
    if [ "$has_error" = "true" ]; then
        local error_code=$(echo "$response" | grep -o '"code"[[:space:]]*:[[:space:]]*[0-9]*' | grep -o '[0-9]*')
        local error_message=$(echo "$response" | grep -o '"message"[[:space:]]*:[[:space:]]*"[^"]*"' | sed 's/"message"[[:space:]]*:[[:space:]]*"\([^"]*\)"/\1/')
        echo -e "${RED}AI API Error${ENDCOLOR}" >&2
        if [ -n "$error_code" ]; then
            echo -e "${RED}Error Code: $error_code${ENDCOLOR}" >&2
        fi
        if [ -n "$error_message" ]; then
            echo -e "${RED}Error Message: $error_message${ENDCOLOR}" >&2
        fi
        echo >&2
        case "$error_code" in
            400)
                if [[ "$error_message" == *"location is not supported"* ]]; then
                    echo -e "${YELLOW}âš ï¸  Geographic restriction: Google's Gemini API is not available in your region.${ENDCOLOR}" >&2
                    echo -e "${YELLOW}Solutions:${ENDCOLOR}" >&2
                    echo -e "${YELLOW}  â€¢ Configure proxy with: gitb cfg proxy${ENDCOLOR}" >&2
                    echo -e "${YELLOW}  â€¢ Use a VPN to connect from a supported region${ENDCOLOR}" >&2
                    echo -e "${YELLOW}  â€¢ Use manual commit messages for now${ENDCOLOR}" >&2
                else
                    echo -e "${YELLOW}âš ï¸  Bad request: Check your API configuration or prompt format.${ENDCOLOR}" >&2
                    echo -e "${YELLOW}Solutions:${ENDCOLOR}" >&2
                    echo -e "${YELLOW}  â€¢ Verify your API key is correct${ENDCOLOR}" >&2
                    echo -e "${YELLOW}  â€¢ Try again with a smaller commit diff${ENDCOLOR}" >&2
                fi
                ;;
            401|403)
                echo -e "${YELLOW}ðŸ” Authentication error: Invalid or expired API key.${ENDCOLOR}" >&2
                echo -e "${YELLOW}Solutions:${ENDCOLOR}" >&2
                echo -e "${YELLOW}  â€¢ Check your API key with: gitb cfg ai${ENDCOLOR}" >&2
                echo -e "${YELLOW}  â€¢ Generate a new API key at: https://makersuite.google.com/app/apikey${ENDCOLOR}" >&2
                echo -e "${YELLOW}  â€¢ Ensure your API key has proper permissions${ENDCOLOR}" >&2
                ;;
            429)
                echo -e "${YELLOW}â±ï¸  Rate limit exceeded: Too many requests.${ENDCOLOR}" >&2
                echo -e "${YELLOW}Solutions:${ENDCOLOR}" >&2
                echo -e "${YELLOW}  â€¢ Wait a few minutes and try again${ENDCOLOR}" >&2
                echo -e "${YELLOW}  â€¢ Consider upgrading your API plan for higher limits${ENDCOLOR}" >&2
                ;;
            500|502)
                echo -e "${YELLOW}ðŸ”§ Server error: Google's service is experiencing issues.${ENDCOLOR}" >&2
                echo -e "${YELLOW}Solutions:${ENDCOLOR}" >&2
                echo -e "${YELLOW}  â€¢ Try again in a few minutes${ENDCOLOR}" >&2
                echo -e "${YELLOW}  â€¢ Check Google's API status page${ENDCOLOR}" >&2
                ;;
            503)
                echo -e "${YELLOW}ðŸ“Š Service overloaded: Google's servers are busy.${ENDCOLOR}" >&2
                echo -e "${YELLOW}Solutions:${ENDCOLOR}" >&2
                echo -e "${YELLOW}  â€¢ Try again in a few minutes${ENDCOLOR}" >&2
                echo -e "${YELLOW}  â€¢ Retry during off-peak hours${ENDCOLOR}" >&2
                ;;
            *)
                if [[ "$error_message" == *"suspended"* ]]; then
                    echo -e "${YELLOW}ðŸš« Account suspended: Your API access has been suspended.${ENDCOLOR}" >&2
                    echo -e "${YELLOW}Solutions:${ENDCOLOR}" >&2
                    echo -e "${YELLOW}  â€¢ Contact Google Support to resolve account issues${ENDCOLOR}" >&2
                    echo -e "${YELLOW}  â€¢ Check your Google Cloud Console for notices${ENDCOLOR}" >&2
                elif [[ "$error_message" == *"location is not supported"* ]]; then
                    echo -e "${YELLOW}âš ï¸  Geographic restriction: Google's Gemini API is not available in your region.${ENDCOLOR}" >&2
                    echo -e "${YELLOW}Solutions:${ENDCOLOR}" >&2
                    echo -e "${YELLOW}  â€¢ Configure proxy with: gitb cfg proxy${ENDCOLOR}" >&2
                    echo -e "${YELLOW}  â€¢ Use a VPN to connect from a supported region${ENDCOLOR}" >&2
                    echo -e "${YELLOW}  â€¢ Use manual commit messages for now${ENDCOLOR}" >&2
                else
                    echo -e "${YELLOW}â“ Unknown error occurred.${ENDCOLOR}" >&2
                    echo -e "${YELLOW}Solutions:${ENDCOLOR}" >&2
                    echo -e "${YELLOW}  â€¢ Check Google's API documentation${ENDCOLOR}" >&2
                    echo -e "${YELLOW}  â€¢ Try again later${ENDCOLOR}" >&2
                fi
                ;;
        esac
        return 1
    fi
    local ai_response=""
    ai_response=$(echo "$response" | sed -n 's/.*"text"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/p' | head -1)
    if [ -z "$ai_response" ]; then
        ai_response=$(echo "$response" | sed -n 's/.*"candidates".*"text"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/p' | head -1)
    fi
    if [ -z "$ai_response" ]; then
        ai_response=$(echo "$response" | sed -n 's/.*"content".*"parts".*"text"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/p' | head -1)
    fi
    if [ -n "$ai_response" ]; then
        ai_response=$(echo "$ai_response" | sed 's/\\n/\n/g' | sed 's/\\"/"/g' | sed 's/\\\\//g')
    fi
    if [ -z "$ai_response" ]; then
        echo -e "${RED}Failed to parse AI response${ENDCOLOR}" >&2
        echo -e "${YELLOW}Raw API response:${ENDCOLOR}" >&2
        echo "$response" | head -5 >&2
        echo -e "${YELLOW}...${ENDCOLOR}" >&2
        echo -e "${YELLOW}To see full response, enable debug mode in ai.sh${ENDCOLOR}" >&2
        return 1
    fi
    echo "$ai_response"
}
function check_ai_available {
    if ! command -v curl >/dev/null 2>&1; then
        echo -e "${RED}curl is required for AI functionality but not installed${ENDCOLOR}" >&2
        return 1
    fi
    local api_key=$(get_ai_api_key)
    if [ -z "$api_key" ]; then
        echo -e "${RED}AI API key not configured${ENDCOLOR}" >&2
        echo -e "${YELLOW}Configure it with: gitb cfg ai${ENDCOLOR}" >&2
        return 1
    fi
    return 0
}
function generate_ai_commit_message {
    local staged_files=$(git diff --name-only --cached)
    if [ -z "$staged_files" ]; then
        echo -e "${RED}No staged files found${ENDCOLOR}" >&2
        return 1
    fi
    local diff_content=$(git diff --cached --stat)
    local diff_details=$(git diff --cached | head -100)
    local prompt="Analyze the following git changes and generate a conventional commit message in the format 'type(scope): subject'.
Available types:
- feat: new feature, logic change or performance improvement
- fix: small changes, bug fix
- refactor: code change that neither fixes a bug nor adds a feature, style changes
- test: adding missing tests or changing existing tests
- build: changes that affect the build system or external dependencies
- ci: changes to CI configuration files and scripts
- chore: maintenance and housekeeping
- docs: documentation changes
Staged files:
$staged_files
File changes summary:
$diff_content
Code changes (partial):
$diff_details
Generate ONLY the commit message in the format 'type(scope): subject'. The subject should:
- Use imperative mood (e.g., 'add', 'fix', 'update')
- Be lowercase
- Not end with a period
- Be concise and descriptive
If you can determine a meaningful scope from the file paths, include it. Otherwise, omit the scope.
Respond with only the commit message, nothing else."
    call_gemini_api "$prompt"
}
function generate_ai_commit_message_subject {
    local staged_files=$(git diff --name-only --cached)
    if [ -z "$staged_files" ]; then
        echo -e "${RED}No staged files found${ENDCOLOR}" >&2
        return 1
    fi
    local diff_content=$(git diff --cached --stat)
    local diff_details=$(git diff --cached | head -100)
    local prompt="Analyze the following git changes and generate a conventional commit message that will be after appended to $1'.
Staged files:
$staged_files
File changes summary:
$diff_content
Code changes (partial):
$diff_details
Generate ONLY the commit message. The message should:
- Use imperative mood (e.g., 'add', 'fix', 'update')
- Be lowercase
- Not end with a period
- Be concise and descriptive
Respond with only the commit message without any other text, nothing else."
    call_gemini_api "$prompt"
}
function generate_ai_commit_message_full {
    local staged_files=$(git diff --name-only --cached)
    if [ -z "$staged_files" ]; then
        echo -e "${RED}No staged files found${ENDCOLOR}" >&2
        return 1
    fi
    local diff_content=$(git diff --cached --stat)
    local diff_details=$(git diff --cached | head -100)
    local prompt="Analyze the following git changes and generate a conventional commit message in the format 'type(scope): subject'.
Also write a body and footer for the commit message, where you can explain why you are making the change.
Available types:
- feat: new feature, logic change or performance improvement
- fix: small changes, bug fix
- refactor: code change that neither fixes a bug nor adds a feature, style changes
- test: adding missing tests or changing existing tests
- build: changes that affect the build system or external dependencies
- ci: changes to CI configuration files and scripts
- chore: maintenance and housekeeping
- docs: documentation changes
Staged files:
$staged_files
File changes summary:
$diff_content
Code changes (partial):
$diff_details
Generate ONLY the commit message in the format 'type(scope): subject' with body and footer. The subject should:
- Use imperative mood (e.g., 'add', 'fix', 'update')
- Be lowercase
- Not end with a period
- Be concise and descriptive
If you can determine a meaningful scope from the file paths, include it. Otherwise, omit the scope.
The body should explain why you are making the change. The length of the body should be 1-2 sentences, not more.
Respond with only the full commit message, nothing else."
    call_gemini_api "$prompt"
}
function set_default_branch {
    echo -e "${YELLOW}Fetching remote branches...${ENDCOLOR}"
    echo
    fetch_output=$(git fetch 2>&1)
    check_code $? "$fetch_output" "fetch remote"
    prune_output=$(git remote prune $origin_name 2>&1)
    echo -e "Current gitbasher default branch: ${YELLOW}$main_branch${ENDCOLOR}"
    echo
    echo -e "${YELLOW}Select a branch to make it default in gitbasher${ENDCOLOR}"
    choose_branch "remote"
    echo 
    main_branch=$(set_config_value gitbasher.branch $branch_name)
    echo -e "${GREEN}Set '${branch_name}' as a default gitbasher branch in '${project_name}' repo${ENDCOLOR}"
    echo
    echo -e "Do you want to set it ${YELLOW}globally${ENDCOLOR} for all projects (y/n)?"
    yes_no_choice "\nSet '${branch_name}' globally" "true"
    main_branch=$(set_config_value gitbasher.branch $branch_name "true")
}
function set_sep {
    echo -e "${YELLOW}Select a branch name separator${ENDCOLOR}"
    echo
    echo -e "Separator is a symbol between type and name, e.g. ${YELLOW}name${sep}name${ENDCOLOR}"
    echo -e "Current separator: ${YELLOW}$sep${ENDCOLOR}"
    echo -e "1. type${YELLOW}/${ENDCOLOR}name"
    echo -e "2. type${YELLOW}_${ENDCOLOR}name"
    echo -e "3. type${YELLOW}-${ENDCOLOR}name"
    echo -e "4. type${YELLOW}.${ENDCOLOR}name"
    echo -e "5. type${YELLOW},${ENDCOLOR}name"
    echo -e "6. type${YELLOW}+${ENDCOLOR}name"
    echo -e "7. type${YELLOW}=${ENDCOLOR}name"
    echo -e "8. type${YELLOW}@${ENDCOLOR}name"
    echo "0. Exit without changes"
    declare -A seps=(
            [1]="/"
            [2]="_"
            [3]="-"
            [4]="."
            [5]=","
            [6]="+"
            [7]="="
            [8]="@"
        )
    while [ true ]; do
        read -n 1 -s choice
        if [ "$choice" == "0" ]; then
            exit
        fi
        re='^[0-9]+$'
        if ! [[ $choice =~ $re ]]; then
            continue
        fi
        new_sep="${seps[$choice]}"
        if [ -n "$new_sep" ]; then
            break
        fi
    done
    echo
    sep=$(set_config_value gitbasher.sep $new_sep)
    echo -e "${GREEN}Set '${sep}' as a branch name separator in '${project_name}' repo${ENDCOLOR}"
    echo
    echo -e "Do you want to set it ${YELLOW}globally${ENDCOLOR} for all projects (y/n)?"
    yes_no_choice "\nSet '${sep}' globally" "true"
    sep=$(set_config_value gitbasher.sep $branch_name $new_sep)
}
function set_editor {
    echo -e "${YELLOW}Enter an editor for commit messages${ENDCOLOR}"
    echo
    echo -e "Enter the bin name of editor to run for creating commit messages (e.g. 'vi' or 'nano')"
    echo -e "It will override ${YELLOW}core.editor${ENDCOLOR} git config value, leave it blank to exit without changes"
    echo -e "Current editor: ${YELLOW}${editor}${ENDCOLOR}"
    read -p "Editor: " choice
    if [ "$choice" == "" ]; then
        exit
    fi
    echo
    which_output=$(which $choice)
    if [ "${which_output}" == *"not found"* ] || [ "${which_output}" == "" ]; then
        echo -e "${RED}Binary '${choice}' not found!${ENDCOLOR}"
        exit
    fi
    editor=$(set_config_value core.editor $choice)
    echo -e "${GREEN}Use editor '$editor' located at '$which_output'${ENDCOLOR}"
    echo
    echo -e "Do you want to set it ${YELLOW}globally${ENDCOLOR} for all projects (y/n)?"
    yes_no_choice "\nSet '${editor}' globally" "true"
    sep=$(set_config_value core.editor $branch_name $new_sep)
}
function set_ticket {
    echo -e "${YELLOW}Enter a ticket prefix${ENDCOLOR}"
    echo
    if [ -z $ticket_name ]; then
        echo -e "${YELLOW}Ticket prefix is not set in gitbasher${ENDCOLOR}"
    else
        echo -e "Current ticket prefix: ${YELLOW}$ticket_name${ENDCOLOR}"
    fi
    read -p "Ticket prefix: " -e ticket_name
    if [ -z $ticket_name ]; then
        exit
    fi
    ticket_name="${ticket_name##*( )}"
    echo 
    ticket_name=$(set_config_value gitbasher.ticket $ticket_name)
    echo -e "${GREEN}Set '${ticket_name}' as a ticket name in '${project_name}' repo${ENDCOLOR}"
    echo
    echo -e "Do you want to set it ${YELLOW}globally${ENDCOLOR} for all projects (y/n)?"
    yes_no_choice "\nSet '${ticket_name}' globally" "true"
    ticket_name=$(set_config_value gitbasher.ticket $ticket_name "true")
}
function set_scopes {
    echo -e "${YELLOW}Enter a list of predefined scopes${ENDCOLOR}"
    echo
    if [ "$scopes" == "" ]; then
        echo -e "${YELLOW}Scopes list is not set${ENDCOLOR}"
    else
        echo -e "Current list of scopes: ${YELLOW}$scopes${ENDCOLOR}"
    fi
    echo -e "Use only english letters and space as separator, maximum is 9 scopes"
    echo -e "Enter 0 if you want to remove scopes"
    read -p "Scopes: " -e scopes_raw
    if [ "$scopes_raw" == "" ]; then
        exit
    fi
    if [ "$scopes_raw" == "0" ]; then
        git config --local --unset-all gitbasher.scopes
        echo
        echo -e "${GREEN}Scopes list removed from '${project_name}' repo${ENDCOLOR}"
        exit
    fi
    echo
    re='^([a-zA-Z]+ ){0,8}([a-zA-Z]+)+$'
    if ! [[ $scopes_raw =~ $re ]]; then
        echo -e "${RED}Invalid scopes list!${ENDCOLOR}"
        exit
    fi
    git config --local --replace-all gitbasher.scopes "$scopes_raw"
    scopes="$scopes_raw"
    echo -e "${GREEN}Set '${scopes}' as a scopes list in '${project_name}' repo${ENDCOLOR}"
    echo
    echo -e "Do you want to set it ${YELLOW}globally${ENDCOLOR} for all projects (y/n)?"
    yes_no_choice "\nSet '${scopes}' globally" "true"
    git config --global --replace-all gitbasher.scopes "$scopes_raw"
}
function delete_global {
    echo -e "${YELLOW}Unset global config${ENDCOLOR}"
    echo
    echo -e "Select a cfg to unset from global settings"
    global_default=$(git config --global --get gitbasher.branch)
    if [ "$global_default" != "" ]; then
        echo -e "1. Default branch: ${YELLOW}${global_default}${ENDCOLOR}"
    fi
    global_sep=$(git config --global --get gitbasher.sep)
    if [ "$global_sep" != "" ]; then
        echo -e "2. Branch separator: ${YELLOW}${global_sep}${ENDCOLOR}"
    fi
    global_editor=$(git config --global --get core.editor)
    if [ "$global_editor" != "" ]; then
        echo -e "3. Commit message editor: ${YELLOW}${global_editor}${ENDCOLOR}"
    fi
    global_ticket=$(git config --global --get gitbasher.ticket)
    if [ "$global_ticket" != "" ]; then
        echo -e "4. Ticket prefix: ${YELLOW}${global_ticket}${ENDCOLOR}"
    fi
    global_scopes=$(git config --global --get gitbasher.scopes)
    if [ "$global_scopes" != "" ]; then
        echo -e "5. Scopes list: ${YELLOW}${global_scopes}${ENDCOLOR}"
    fi
    echo -e "0. Exit"
    read -n 1 -s choice
    re='^[012345]+$'
    if ! [[ $choice =~ $re ]]; then
        break
    fi
    if [ "$choice" == "0" ]; then
        exit
    fi
    echo
    case "$choice" in
        1)  
            echo -e "${GREEN}Unset default branch from global settings${ENDCOLOR}"
            git config --global --unset gitbasher.branch
            ;;
        2)
            echo -e "${GREEN}Unset branch separator from global settings${ENDCOLOR}"
            git config --global --unset gitbasher.sep
            ;;
        3)
            echo -e "${GREEN}Unset commit message editor from global settings${ENDCOLOR}"
            git config --global --unset core.editor
            ;;
        4)
            echo -e "${GREEN}Unset ticket prefix from global settings${ENDCOLOR}"
            git config --global --unset gitbasher.ticket
            ;;
        5)
            echo -e "${GREEN}Unset scopes list from global settings${ENDCOLOR}"
            git config --global --unset gitbasher.scopes
            ;;
    esac
}
function set_user {
    echo -e "${YELLOW}Set user name and email${ENDCOLOR}"
    echo
    echo -e "Current name: ${YELLOW}$(get_config_value user.name)${ENDCOLOR}"
    echo -e "Enter new name or leave it empty if you don't want to change it"
    read -p "Name: " -e user_name
    echo
    echo -e "Current email: ${YELLOW}$(get_config_value user.email)${ENDCOLOR}"
    echo -e "Enter new email or leave it empty if you don't want to change it"
    read -p "Email: " -e user_email
    if [ "$user_name" == "" ] && [ "$user_email" == "" ]; then
        exit
    fi
    echo
    if [ "$user_name" != "" ]; then
        echo -e "${GREEN}Set user name to '${user_name}'${ENDCOLOR}"
        git config --local --replace-all user.name "$user_name"
    fi
    if [ "$user_email" != "" ]; then
        echo -e "${GREEN}Set user email to '${user_email}'${ENDCOLOR}"
        git config --local --replace-all user.email "$user_email"
    fi
}
function config_script {
    case "$1" in
        default|def|d|b|main) set_default_cfg="true";;
        separator|sep)        set_sep_cfg="true";;
        editor|ed|e)          set_editor_cfg="true";;
        ticket|jira|ti|t)     set_ticket_cfg="true";;
        scopes|scope|sc|s)    set_scopes_cfg="true";;
        delete|unset|del)     delete_cfg="true";;
        user|name|email|u)    set_user_cfg="true";;
        help|h)               help="true";;
        *)                    wrong_mode "config" $1
    esac
    header="GIT CONFIG"
    if [ -n "${set_default_cfg}" ]; then
        header="$header DEFAULT BRANCH"
    elif [ -n "${set_sep_cfg}" ]; then
        header="$header BRANCH SEPARATOR"
    elif [ -n "${set_editor_cfg}" ]; then
        header="$header COMMIT MESSAGE EDITOR"
    elif [ -n "${set_ticket_cfg}" ]; then
        header="$header TICKET PREFIX"
    elif [ -n "${set_scopes_cfg}" ]; then
        header="$header SCOPES LIST"
    elif [ -n "${delete}" ]; then
        header="$header UNSET GLOBAL CONFIG"
    elif [ -n "${set_user_cfg}" ]; then
        header="$header USER NAME & EMAIL"
    fi
    echo -e "${YELLOW}${header}${ENDCOLOR}"
    echo
    if [ "$set_user_cfg" == "true" ]; then
        set_user
        exit
    fi
    if [ "$set_default_cfg" == "true" ]; then
        set_default_branch
        exit
    fi
    if [ "$set_sep_cfg" == "true" ]; then
        set_sep
        exit
    fi
    if [ "$set_editor_cfg" == "true" ]; then
        set_editor
        exit
    fi
    if [ "$set_ticket_cfg" == "true" ]; then
        set_ticket
        exit
    fi
    if [ "$set_scopes_cfg" == "true" ]; then
        set_scopes
        exit
    fi
    if [ "$delete_cfg" == "true" ]; then
        delete_global
        exit
    fi
    if [ -n "$help" ]; then
        echo -e "usage: ${YELLOW}gitb config <mode>${ENDCOLOR}"
        echo
        echo -e "${YELLOW}Available modes for configuration${ENDCOLOR}"
        echo -e "<empty>\t\t\tPrint current gitbasher configuration"
        echo -e "user|name|email|u\tSet user name and email"
        echo -e "default|def|d|b|main\tUpdate gitbasher's default branch (not in remote git repo!)"
        echo -e "separator|sep|s\t\tUpdate separator between type and name in branch"
        echo -e "editor|ed|e\t\tUpdate text editor for the commit messages"
        echo -e "ticket|ti|t|jira\tSet ticket prefix to help with commit/branch building"
        echo -e "scopes|sc|s\t\tSet a list of scopes to help with commit building"
        echo -e "delete|unset|del\tUnset global configuration"
        exit
    fi
    print_configuration
}
function merge_script {
    case "$1" in
        main|master|m)          main="true";;
        to-main|to-master|tm)   to_main="true";;
        remote|r)               remote="true";;
        help|h)                 help="true";;
        *)
            wrong_mode "merge" $1
    esac
    header="GIT MERGE"
    if [ -n "${main}" ]; then
        header="$header MAIN"
    elif [ -n "${to_main}" ]; then
        header="$header TO MAIN"
    elif [ -n "${remote}" ]; then
        header="$header REMOTE"
    fi
    echo -e "${YELLOW}${header}${ENDCOLOR}"
    echo
    if [ -n "$help" ]; then
        echo -e "usage: ${YELLOW}gitb merge <mode>${ENDCOLOR}"
        echo
        echo -e "${YELLOW}Available modes${ENDCOLOR}"
        echo -e "<empty>\t\t\tSelect a branch to merge into the current one and fix conflicts"
        echo -e "main|master|m\t\tMerge $main_branch to the current branch and fix conflicts"
        echo -e "to-main|to-master|tm\tSwitch to $main_branch and merge the current branch into $main_branch"
        echo -e "remote|r\t\tFetch $origin_name and select a remote branch to merge into current"
        echo -e "help|h\t\t\tShow this help"
        exit
    fi
    if [ -n "$main" ]; then
        if [ "$current_branch" == "${main_branch}" ]; then
            echo -e "${YELLOW}Already on ${main_branch}${ENDCOLOR}"
            exit
        fi
        merge_branch=${main_branch}
    elif [ -n "$to_main" ]; then
        if [ "$current_branch" == "${main_branch}" ]; then
            echo -e "${YELLOW}Already on ${main_branch}${ENDCOLOR}"
            exit
        fi
        merge_branch=${current_branch}
    elif [ -n "$remote" ]; then
        echo -e "${YELLOW}Fetching remote...${ENDCOLOR}"
        echo
        fetch_output=$(git fetch 2>&1)
        check_code $? "$fetch_output" "fetch remote"
        prune_output=$(git remote prune $origin_name 2>&1)
        echo -e "${YELLOW}Select which remote branch to merge into '${current_branch}'${ENDCOLOR}"
        choose_branch "remote"
        merge_branch=${branch_name}
        merge_from_origin=true
        echo
    else
        echo -e "${YELLOW}Select which branch to merge into '${current_branch}'${ENDCOLOR}"
        choose_branch "merge"
        merge_branch=${branch_name}
        echo
    fi
    if [ -z "$remote" ]; then
        echo -e "Do you want to fetch ${YELLOW}${origin_name}/${merge_branch}${ENDCOLOR} before merge (y/n)?"
        read -n 1 -s choice
        if [ "$choice" == "y" ]; then
            echo
            echo -e "${YELLOW}Fetching ${origin_name}/${merge_branch}...${ENDCOLOR}"
            fetch $merge_branch $origin_name
            merge_from_origin=true
        fi
        echo
    fi
    if [ -n "$to_main" ]; then
        switch $main_branch "true"
        echo
        current_branch=$main_branch
    fi
    commit_message_before_merge="$(git --no-pager log --pretty="%s" -1)"
    merge $merge_branch $origin_name $editor "merge" $merge_from_origin
    if [[ $merge_output == *"Already up to date"* ]]; then
        echo -e "${GREEN}Nothing to merge - already up to date${ENDCOLOR}"
        exit
    fi
    commit_message_after_merge="$(git --no-pager log --pretty="%s" -1)"
    if [[ "$commit_message_after_merge" != "$commit_message_before_merge" ]]; then
        echo -e "${GREEN}Successful merge!${ENDCOLOR} ${BLUE}[$merge_branch${ENDCOLOR} -> ${BLUE}$current_branch]${ENDCOLOR}"
        echo -e "$commit_message_after_merge"
    else
        echo -e "${GREEN}Successful fast-forward merge!${ENDCOLOR} ${BLUE}[$merge_branch${ENDCOLOR} -> ${BLUE}$current_branch]${ENDCOLOR}"
    fi
    changes=$(echo "$merge_output" | tail -n +3)
    if [[ $changes == *"conflict"* ]]; then
        commit_hash="$(git --no-pager log --pretty="%h" -1)"
        changes=$(git --no-pager show $commit_hash --stat --format="")
    fi
    if [ -n "$changes" ]; then
        echo
        print_changes_stat "$changes"
    fi
}
function merge {
    args=""
    if [ "$6" == "true" ]; then
        args="--ff-only"
    fi
    if [ "$5" == "true" ]; then
        merge_output=$(git merge $args $2/$1 2>&1)
    else
        merge_output=$(git merge $args $1 2>&1)
    fi
    merge_code=$?
    if [ $merge_code == 0 ] ; then
        return
    fi
    operation="$4"
    if [ "$operation" == "" ]; then
        operation="merge"
    fi
    if [[ $merge_output == *"Please commit your changes or stash them before you merge"* ]]; then
        echo -e "${RED}Cannot $operation! There are uncommited changes that will be overwritten by $operation${ENDCOLOR}"
        files_to_commit=$(echo "$merge_output" | tail -n +2 | tail -r | tail -n +4 | tail -r)
        echo -e "${YELLOW}Files with changes${ENDCOLOR}"
        echo "$files_to_commit"
        exit $merge_code
    fi
    if [[ $merge_output == *"possible to fast-forward"* ]]; then
        echo -e "${RED}Branches cannot be fast forwarded!${ENDCOLOR}"
        echo -e "You should use merge or rebase"
        exit $merge_code
    fi
    if [[ $merge_output != *"fix conflicts and then commit the result"* ]]; then
        echo -e "${RED}Cannot $operation! Error message:${ENDCOLOR}"
        echo "$merge_output"
        exit $merge_code
    fi
    echo -e "${RED}Cannot $operation! There are conflicts in staged files${ENDCOLOR}"
    resolve_conflicts $1 $2 $3
    merge_code=0
    echo
}
function resolve_conflicts {
    echo
    default_message="Merge branch '$2/$1' into '$1'"
    echo -e "${YELLOW}You should resolve conflicts manually${ENDCOLOR}"
    echo -e "After resolving, select an option to continue"
    echo -e "1. Create a merge commit with a generated message:"
    printf "\t${YELLOW}${default_message}${ENDCOLOR}\n"
    echo -e "2. Create a merge commit with an entered message"
    echo -e "3. Abort merge and return to the original state: ${YELLOW}git merge --abort${ENDCOLOR}"
    echo -e "0. Exit from this script ${BOLD}without${NORMAL} merge abort"
    echo
    echo -e "${YELLOW}Files with conflicts${ENDCOLOR}"
    IFS=$'\n' read -rd '' -a files_with_conflicts <<<"$(git --no-pager diff --name-only --diff-filter=U --relative)"
    for file in "${files_with_conflicts[@]}"; do
        echo -e "\t$file"
    done
    while [ true ]; do
        read -n 1 -s choice
        if [ "$choice" == "1" ] || [ "$choice" == "2" ]; then
            merge_commit $choice $files_with_conflicts "${default_message}" $1 $2 $3
            if [ "$merge_error" == "false" ]; then
                return
            fi
        fi
        if [ "$choice" == "3" ]; then
            echo
            echo -e "${YELLOW}Aborting merge...${ENDCOLOR}"
            git merge --abort
            exit $?
        fi
        if [ "$choice" == "0" ]; then
            exit
        fi
    done
}
function merge_commit {
    merge_error="false"
    files_with_conflicts_one_line="$(echo "$2" | tr '\n' ' ' | sed 's/ $//')"
    files_with_conflicts_new="$(git --no-pager grep -l --name-only -E "[<=>]{7} HEAD" $files_with_conflicts_one_line)"
    if [ "$files_with_conflicts_new" != "" ]; then
        echo
        echo -e "${YELLOW}There are files with conflicts${ENDCOLOR}"
        echo -e "$(echo -e "${files_with_conflicts_new}" | tr ' ' '\n' | sed 's/^/\t/')"
        echo
        echo -e "Fix conflicts and press ${YELLOW}$1${ENDCOLOR} for one more time"
        merge_error="true"
        return
    fi
    git add $files_with_conflicts_one_line
    if [ "$1" == "1" ]; then
        commit_message="$3"
        result=$(git commit -m "$commit_message" 2>&1)
        if [[ $result != *"not staged for commit"* ]]; then
            check_code $? "$result" "creating default merge commit"
        fi  
    else
        staged_with_tab="$(sed 's/^/####\t/' <<< "$2")"
        commitmsg_file=".commitmsg__"
        touch $commitmsg_file
        echo """
####
#### Write a message about merge from '$5/$4' into '$4'. Lines starting with '#' will be ignored. 
#### 
#### On branch $4
#### Changes to be commited:
${staged_with_tab}
""" >> $commitmsg_file
        while [ true ]; do
            $6 $commitmsg_file
            commit_message=$(cat $commitmsg_file | sed '/^#/d')
            if [ -n "$commit_message" ]; then
                break
            fi
            echo
            echo -e "${YELLOW}Merge commit message cannot be empty${ENDCOLOR}"
            echo
            read -n 1 -p "Do you want to try for one more time? (y/n) " -s -e choice
            if [ "$choice" != "y" ]; then
                git restore --staged $files_with_conflicts_one_line
                find . -name "$commitmsg_file*" -delete
                merge_error="true"
                exit
            fi    
        done
        find . -name "$commitmsg_file*" -delete
        result=$(git commit -m """$commit_message""" 2>&1)
        if [[ $result != *"not staged for commit"* ]]; then
            check_code $? "$result" "creating merge commit"
        fi  
    fi
}
function rebase_script {
    case "$1" in
        main|master|m)           main="true";;
        interactive|i)           interactive="true";;
        autosquash|a|s|f|ia|if)  autosquash="true";;
        help|h)                  help="true";;
        *)
            wrong_mode "rebase" $1
    esac
    header="GIT REBASE"
    if [ -n "${interactive}" ]; then
        header="$header INTERACTIVE"
    elif [ -n "${autosquash}" ]; then
        header="$header AUTOSQUASH"
    elif [ -n "${main}" ]; then
        header="$header MAIN"
    fi
    echo -e "${YELLOW}${header}${ENDCOLOR}"
    echo
    if [ -n "$help" ]; then
        echo -e "usage: ${YELLOW}gitb rebase <mode>${ENDCOLOR}"
        echo
        echo -e "${YELLOW}Available modes${ENDCOLOR}"
        echo -e "<empty>\t\t\tSelect base branch to rebase current changes"
        echo -e "main|master|m\t\tRebase current branch onto default branch"
        echo -e "interactive|i\t\tSelect base commit in current branch and rebase in an interactive mode"
        echo -e "autosquash|a|s|f|ia|if\tRebase on the current local branch in an interactive mode with --autosquash"
        echo -e "help|h\t\t\tShow this help"
        exit
    fi
    is_clean=$(git status | tail -n 1)
    if [ "$is_clean" != "nothing to commit, working tree clean" ]; then
        echo -e "${RED}Cannot rebase! There are uncommited changes:"
        git_status
        exit 1
    fi
    if [ -n "$main" ]; then
        if [ "$current_branch" == "${main_branch}" ]; then
            echo -e "${YELLOW}Already on ${main_branch}${ENDCOLOR}"
            exit
        fi
        new_base_branch=${main_branch}
    elif [ -n "$autosquash" ]; then
        new_base_branch=${current_branch}
    else
        echo -e "${YELLOW}Select which branch will become a new base for '${current_branch}'${ENDCOLOR}"
        choose_branch "rebase"
        new_base_branch=${branch_name}
        echo
    fi
    if [ -z "$autosquash" ]; then
        echo -e "Fetch ${YELLOW}${origin_name}/${new_base_branch}${ENDCOLOR} before rebase (y/n/0)?"
        read -n 1 -s choice
        if [ "$choice" == "0" ]; then
            exit
        fi
        if [ "$choice" == "y" ]; then
            echo
            echo -e "${YELLOW}Fetching ${origin_name}/${new_base_branch}...${ENDCOLOR}"
            fetch $new_base_branch $origin_name
            from_origin=true
        fi
        echo
    fi
    rebase_branch "$new_base_branch" "$origin_name" "$from_origin" "$interactive" "$autosquash" "$autosquash"
    if [[ $rebase_output == *"is up to date"* ]]; then
        echo -e "${GREEN}Nothing to rebase - already up to date${ENDCOLOR}"
        exit
    fi
    echo
    if [ $rebase_code == 0 ] ; then
        echo -e "${GREEN}Successful rebase!${ENDCOLOR}"
        echo -e "${BLUE}[${new_base_branch}${ENDCOLOR} -> ${BLUE}${current_branch}]${ENDCOLOR}"
    else
        echo -e "${RED}Cannot rebase! Error message:${ENDCOLOR}"
        echo -e "$rebase_output"
    fi
}
function rebase_branch {
    ref=$1
    if [ "$3" == "true" ]; then
        ref=$2/$1
    fi
    if [ "$5" == "true" ]; then
        if [ "$6" == "true" ]; then
            echo -e "Select a new ${BOLD}base${NORMAL} commit from which to squash fixup commits (third one or older):"
            choose_commit 20 "number" $ref
            ref="$commit_hash"
        fi
        rebase_output=$(git rebase -i --autosquash $ref 3>&2 2>&1 1>&3)
    elif [ "$4" == "true" ]; then
        rebase_output=$(git rebase -i $ref 3>&2 2>&1 1>&3)
    else
        rebase_output=$(git rebase $ref 3>&2 2>&1 1>&3)
    fi
    rebase_code=$?
    if [ $rebase_code == 0 ] ; then
        return
    fi
    if [[ $rebase_output == *"Please commit or stash them"* ]]; then
        echo -e "${RED}Cannot rebase! There are uncommited changes:"
        git_status
        exit $rebase_code
    fi
    if [[ $rebase_output == *"error: invalid"* ]]; then
        rebase_todo_errors "$rebase_output"
        echo
    fi
    if [[ $rebase_output == *"Resolve all conflicts manually"* ]] || [[ $rebase_output == *"previous cherry-pick is now empty"* ]]; then
        echo -e "${RED}Cannot rebase! There are conflicts${ENDCOLOR}"
        rebase_conflicts $rebase_output 
    fi
    if [[ $rebase_output != *"Successfully rebased"* ]]; then
        echo -e "${RED}Cannot rebase! Error message:${ENDCOLOR}"
        echo "$rebase_output"
        exit $rebase_code
    fi
}
function rebase_todo_errors {
    rebase_output=$1
    output_to_print=$1
    while [ true ]; do
        echo -e "${RED}Cannot rebase! Your rebase plan has errors:${ENDCOLOR}"
        echo "$(sed '$d' <<< $output_to_print)"
        echo
        echo -e "${YELLOW}You should fix errors${ENDCOLOR}"
        echo -e "1. Open editor to change rebase plan: ${BLUE}git rebase --edit-todo${ENDCOLOR}"
        echo -e "2. Abort rebase and return to the original state: ${YELLOW}git rebase --abort${ENDCOLOR}"
        echo -e "0. Exit from this script ${BOLD}without${NORMAL} rebase abort"
        while [ true ]; do
            read -n 1 -s choice
            re='^[012]+$'
            if [[ $choice =~ $re ]]; then
                break
            fi
        done
        if [ "$choice" == "1" ]; then
            todo_output=$(git rebase --edit-todo 3>&2 2>&1 1>&3)
            rebase_output=$(git rebase --continue 2>&1)
            rebase_code=$?
        elif [ "$choice" == "2" ]; then
            echo
            echo -e "${YELLOW}Aborting rebase...${ENDCOLOR}"
            git rebase --abort
            exit
        elif [ "$choice" == "0" ]; then
            exit $rebase_code
        fi
        if [ "$2" != "" ] ; then
            output_to_print=$todo_output
            if [[ $todo_output != *"can fix this with"* ]]; then
                break
            fi
        else
            output_to_print=$rebase_output
            if [[ $rebase_output != *"error: invalid"* ]]; then
                break
            fi
        fi
        echo
    done
}
function rebase_conflicts {
    print_menu="true"
    new_step="true"
    rebase_output=$1
    while [ true ]; do
        if [ "$print_menu" == "true" ]; then
            echo
            echo -e "${YELLOW}You should resolve conflicts manually${ENDCOLOR}"
            echo -e "After resolving, select an option to continue"
            echo -e "1. Add changes and continue: ${YELLOW}git rebase --continue${ENDCOLOR}"
            echo -e "2. Open editor to change rebase plan: ${BLUE}git rebase --edit-todo${ENDCOLOR}"
            echo -e "3. Throw away the commit from the history: ${RED}git rebase --skip${ENDCOLOR}"
            echo -e "4. Abort rebase and return to the original state: ${YELLOW}git rebase --abort${ENDCOLOR}"
            echo -e "0. Exit from this script ${BOLD}without${NORMAL} rebase abort"
            print_menu="false"
        fi
        if [ "$new_step" == "true" ]; then
            status=$(git status)
            current_step=$(echo "$status" | sed -n 's/.*Last commands done (\([0-9]*\) commands done):/\1/p')
            if [ "$current_step" == "" ]; then
                current_step=$(echo "$status" | sed -n 's/.*Last command done (\([0-9]*\) command done):/\1/p')
            fi
            remaining_steps=$(echo "$status" | sed -n 's/.*Next commands to do (\([0-9]*\) remaining commands):/\1/p')
            total_steps=$((current_step + remaining_steps))
            commit_name=$(echo "$status" | sed -n '/done):/,/Next command/p' | sed 's/^[ \t]*//;s/[ \t]*$//' | sed '/^[LN(]/d' | tail -n 1 )
            commit_name=$(echo "$commit_name" | sed 's/^[ \t]*//;s/[ \t]*$//' | sed "s/\([a-z]* [0-9a-f]*\)/${BLUE_ES}\[\1\]${ENDCOLOR_ES}/")
            files=$(echo "$status" | sed -n '/^Unmerged paths:/,/^$/p' | sed '/^Unmerged paths:/d;/^$/d;/^ *(/d')
            files=$(sed "s/\(.*\)both modified:/\1${YELLOW_ES}modified:${ENDCOLOR_ES}/" <<< "${files}")
            files=$(sed "s/\(.*\)both added:/\1${YELLOW_ES}added:${ENDCOLOR_ES}/" <<< "${files}")
            echo
            echo -e "${GREEN}Step $current_step/$total_steps:${ENDCOLOR} $commit_name"
            if [ "$files" != "" ]; then
                echo -e "$files"
            else
                echo
                echo -e "${YELLOW}The previous commit is now empty due to conflict resolution${ENDCOLOR}"
                echo -e "${GREEN}You can skip this commit by pressing ${BOLD}3${ENDCOLOR}"
                force_skip="true"
            fi
            new_step="false"
        fi
        while [ true ]; do
            read -n 1 -s choice
            re='^[01234]+$'
            if [[ $choice =~ $re ]]; then
                break
            fi
        done
        if [ "$choice" == "1" ]; then
            files_with_conflicts_one_line="$(tr '\n' ' ' <<< "$(git --no-pager diff --name-only --diff-filter=U --relative)")"
            files_with_conflicts_new="$(git grep -l --name-only -E "[<=>]{7} HEAD" $files_with_conflicts_one_lined)"
            if [ "$files_with_conflicts_new" != "" ]; then
                echo
                echo -e "${YELLOW}There are files with conflicts${ENDCOLOR}"
                echo -e "$(echo -e "${files_with_conflicts_new}" | tr ' ' '\n' | sed 's/^/\t/')"
                continue
            fi
            git add .
            rebase_output=$(git -c core.editor=true rebase --continue 2>&1)
            rebase_code=$?
            if [[ $rebase_output == *"Successfully rebased"* ]]; then
                return
            fi
            if [[ $rebase_output != *"CONFLICT"* ]]; then
                echo -e "${RED}Cannot rebase! Error message:${ENDCOLOR}"
                echo "$rebase_output"
                exit $rebase_code
            fi
            new_step="true"
            continue
        fi
        if [ "$choice" == "2" ]; then
            todo_output=$(git rebase --edit-todo 3>&2 2>&1 1>&3)
            rebase_output=$(git rebase --continue 2>&1)
            if [[ $todo_output == *"error: invalid"* ]]; then
                echo
                rebase_todo_errors "$todo_output" "true"
                print_menu="true"
                new_step="true"
            fi
            echo
            echo -e "${YELLOW}Successfull plan edit, continuing...${ENDCOLOR}"
            continue
        fi
        if [ "$choice" == "3" ]; then
            if [ "$force_skip" != "true" ]; then
                echo
                echo -e "Are you sure you want to ${RED}skip${ENDCOLOR} commit and ${RED}throw it away${ENDCOLOR} (y/n)?"
                read -n 1 -s choice_yes
                if [ "$choice_yes" != "y" ]; then
                    echo -e "${YELLOW}Continuing...${ENDCOLOR}"
                    continue
                fi
            fi
            force_skip="false"
            rebase_output=$(git rebase --skip 2>&1)
            rebase_code=$?
            if [[ $rebase_output == *"Successfully rebased"* ]]; then
                echo
                return
            fi
            echo -e "${YELLOW}Skipping commit${ENDCOLOR}"
            new_step="true"
            continue
        fi
        if [ "$choice" == "4" ]; then
            echo
            echo -e "Are you sure you want to ${YELLOW}abort rebase${ENDCOLOR} (y/n)?"
            read -n 1 -s choice_yes
            if [ "$choice_yes" == "y" ]; then
                echo
                echo -e "${YELLOW}Aborting rebase...${ENDCOLOR}"
                git rebase --abort
                exit $?
            else
                echo -e "${YELLOW}Continuing...${ENDCOLOR}"
            fi
            continue
        fi
        if [ "$choice" == "0" ]; then
            exit
        fi
    done
}
function pull_script {
    case "$1" in
        fetch|fe)           fetch="true";;
        all|fa)             fetch="true"; all="true";;
        upd|u)              update="true";;
        ffonly|ff)          ffonly="true";;
        merge|m)            merge="true";;
        rebase|r)           rebase="true";;
        interactive|ri|rs)  rebase="true"; interactive="true";;
        help|h)             help="true";;
        *)
            wrong_mode "pull" $1
    esac
    header_msg="GIT PULL"
    if [ -n "${fetch}" ]; then
        if [ -n "${all}" ]; then
            header_msg="$header_msg FETCH ALL"
        else
            header_msg="$header_msg FETCH"
        fi
    elif [ -n "${rebase}" ]; then
        if [ -n "${interactive}" ]; then
            header_msg="$header_msg INTERACTIVE REBASE"
        else
            header_msg="$header_msg REBASE"
        fi
    elif [ -n "${ffonly}" ]; then
        header_msg="$header_msg FAST FORWARD ONLY"
    elif [ -n "${merge}" ]; then
        header_msg="$header_msg MERGE"
    elif [ -n "${update}" ]; then
        header_msg="$header_msg REMOTE UPDATE"
    fi
    echo -e "${YELLOW}${header_msg}${ENDCOLOR}"
    echo
    if [ -n "$help" ]; then
        echo -e "usage: ${YELLOW}gitb pull${ENDCOLOR}"
        echo
        echo -e "${YELLOW}Available modes${ENDCOLOR}"
        echo -e "<empty>\t\t\tFetch current branch, try to fast-forward or ask about strategy"
        echo -e "fetch|fe\t\tFetch current branch without merge"    
        echo -e "all|fa\t\t\tFetch all without merge"
        echo -e "upd|u\t\t\tRun git remote update to fetch all branches"
        echo -e "ffonly|ff\t\tFetch and then merge in fast forward only mode"
        echo -e "merge|m\t\t\tFetch current branch and then merge it"
        echo -e "rebase|r\t\tFetch current branch and then rebase"
        echo -e "interactive|ri|rs\tFetch current branch and then rebase in interactive mode with --autosquash"
        echo -e "help|h\t\t\tShow this help"
        exit
    fi
    if [ -n "$rebase" ]; then
        mode="rebase"
    elif [ -n "$merge" ]; then
        mode="merge"
    fi
    if [ -n "$fetch" ]; then
        if [ -n "$all" ]; then
            echo -e "${YELLOW}Fetching all...${ENDCOLOR}"
        else
            echo -e "${YELLOW}Fetching '$origin_name/$current_branch'...${ENDCOLOR}"
        fi
        echo
        fetch $current_branch $origin_name $all
        if [ $fetch_code == 0 ] ; then
            commits=$(commit_list 999 "tab" HEAD..$origin_name/$current_branch)
            if [ "$commits" != "" ]; then
                if [ -n "$all" ]; then
                    echo -e "${GREEN}Successfully fetched all!${ENDCOLOR}"
                else
                    echo -e "${GREEN}Successfully fetched '$origin_name/$current_branch'!${ENDCOLOR}"
                fi
                if [ "$fetch_output" != "" ]; then
                    echo
                    echo -e "$fetch_output"
                fi
                echo
                count=$(echo -e "$commits" | wc -l | sed 's/^ *//;s/ *$//')
                echo -e "Your branch is behind ${YELLOW}$origin_name/$current_branch${ENDCOLOR} by ${BOLD}$count${ENDCOLOR} commits"
                echo -e "$commits"
            else
                echo -e "${GREEN}Already up to date${ENDCOLOR}"
            fi
        fi
        exit
    fi
    if [ -n "$update" ]; then
        echo -e "${YELLOW}Updating from remote...${ENDCOLOR}"
        echo
        update_output=$(git remote update 2>&1)
        update_code=$?
        if [ $update_code == 0 ] ; then
            commits=$(commit_list 999 "tab" HEAD..$origin_name/$current_branch)
            if [ "$commits" != "" ]; then
                echo -e "${GREEN}Successfully updated from remote!${ENDCOLOR}"
                if [ "$update_output" != "" ]; then
                    echo
                    echo -e "$update_output"
                fi
                echo
                count=$(echo -e "$commits" | wc -l | sed 's/^ *//;s/ *$//')
                echo -e "Your branch is behind ${YELLOW}$origin_name/$current_branch${ENDCOLOR} by ${BOLD}$count${ENDCOLOR} commits"
                echo -e "$commits"
            else
                echo -e "${GREEN}Already up to date${ENDCOLOR}"
            fi
            exit
        fi
        echo -e "${RED}Cannot update! Error message:${ENDCOLOR}"
        echo -e "${update_output}"
        exit $update_code
    fi
    echo -e "${YELLOW}Pulling '$origin_name/$current_branch'...${ENDCOLOR}"
    echo
    pull $current_branch $origin_name $editor $mode $ffonly 
    exit
}
function fetch {
    if [ -n "$3" ]; then
        fetch_output=$(git fetch --all 2>&1)
        fetch_code=$?
    else
        fetch_output=$(git fetch $2 $1 2>&1)
        fetch_code=$?
    fi
    if [ $fetch_code == 0 ] ; then
        return
    fi
    if [[ ${fetch_output} != *"couldn't find remote ref"* ]]; then
        echo -e "${RED}Cannot fetch '$1'! Error message:${ENDCOLOR}"
        echo -e "${fetch_output}"
        exit $fetch_code
    fi
    echo -e "${YELLOW}There is no '$1' in $2${ENDCOLOR}"
}
function pull {
    fetch $1 $2
    if [ $fetch_code != 0 ] ; then
        return
    fi
    merge_output=$(git merge --ff-only $2/$1 2>&1)
    merge_code=$?
    mode="fast-forward"
    if [[ $merge_output == *"Already up to date"* ]]; then  
        echo -e "${GREEN}Already up to date${ENDCOLOR}"
        return
    fi
    if [ $merge_code != 0 ] ; then
        if [[ $merge_output != *"possible to fast-forward"* ]]; then
            echo -e "${RED}Cannot pull! Error message:${ENDCOLOR}"
            echo "$merge_output"
            exit $merge_code
        fi
        commits=$(commit_list 999 "tab" HEAD..$origin_name/$current_branch)
        count=$(echo -e "$commits" | wc -l | sed 's/^ *//;s/ *$//')
        echo -e "Your branch is behind ${YELLOW}$origin_name/$current_branch${ENDCOLOR} by ${BOLD}$count${ENDCOLOR} commits"
        echo -e "$commits"
        echo
        mode=$4
        if [ "$4" == "merge" ]; then
            echo -e "${YELLOW}Merging...${ENDCOLOR}"
            choice="1"
        elif [ "$4" == "rebase" ]; then
            echo -e "${YELLOW}Rebasing...${ENDCOLOR}"
            choice="2"
        else
            echo -e "${RED}Cannot fast forward!${ENDCOLOR} Choose an option:"
            echo -e "1. ${BLUE}Merge.${ENDCOLOR} It saves commit's timeline, but creates a merge commit with message:"
            echo -e "\t\t${YELLOW}Merge remote-tracking branch '$origin_name/$current_branch' into $current_branch${ENDCOLOR}"
            echo -e "2. ${BLUE}Rebase.${ENDCOLOR} It takes all new local commits and places them on top of the remote branch"
            read -n 1 -s choice
            re='^[12]+$'
            if ! [[ $choice =~ $re ]]; then
                exit 0
            fi
        fi
        echo
        if [ "$choice" == "1" ]; then
            merge $1 $2 $3 "pull" "true" $5
            mode="merge"
            if [ $merge_code != 0 ] ; then
                echo
           fi
        else 
           rebase_branch $1 $2 "true" $interactive $interactive
           mode="rebase"
           if [ $rebase_code != 0 ] ; then
                echo
           fi
        fi
    fi
    echo -e "${GREEN}Successfully pulled with $mode!${ENDCOLOR}"
    if [ "$mode" == "merge" ] || [ "$mode" == "fast-forward" ]; then 
        echo
        if [ $merge_code == 0 ] ; then
            if [[ $merge_output == *"made by the"* ]]; then
                changes=$(echo "$merge_output" | tail -n +3)
            else
                changes=$(echo "$merge_output" | tail -n +2)
            fi
            if [[ -n "$changes" ]]; then
                print_changes_stat "$changes"
            fi
        else
            commit_hash="$(git --no-pager log --pretty="%h" -1)"
            changes=$(git --no-pager show $commit_hash --stat --format="")
            if [[ -n "$changes" ]]; then
                print_changes_stat "$changes"
            fi
        fi
    fi
}
function push {
    push_output=$(git push $1 ${origin_name} ${current_branch} 2>&1)
    push_code=$?
    if [ $push_code -eq 0 ] ; then 
        echo -e "${GREEN}Successful push!${ENDCOLOR}"
        repo=$(get_repo)
        echo -e "${YELLOW}Repo:${ENDCOLOR}\t${repo}"
        if [[ ${current_branch} != ${main_branch} ]]; then
            link=$(echo "$push_output" | grep "https://" | sed 's|^remote:[[:space:]]*||')
            if [[ $repo == *"github"* ]]; then
                if [ "$link" != "" ]; then
                    echo -e "${YELLOW}New PR:${ENDCOLOR}\t${link}"
                else
                    echo -e "${YELLOW}PRs:${ENDCOLOR}\t${repo}/pulls"
                fi
            elif [[ $repo == *"gitlab"* ]]; then
                is_new=$(echo "$push_output" | grep "create a merge request")
                if [ "$is_new" != "" ]; then
                    echo -e "${YELLOW}New MR:${ENDCOLOR}\t${link}"
                else
                    if [ "$mr_link" != "" ]; then
                        echo -e "${YELLOW}MR:${ENDCOLOR}\t${link}"
                    else
                        echo -e "${YELLOW}MRs:${ENDCOLOR}\t${repo}/merge_requests"
                    fi
                fi
            fi
        fi
        exit
    fi
    if [[ $push_output != *"[rejected]"* ]]; then
        echo -e "${RED}Cannot push! Error message:${ENDCOLOR}"
        echo "$push_output"
        exit $push_code
    fi
}
function push_script {
    case "$1" in
        yes|y)      fast="true";;
        force|f)    force="true";;
        list|log|l) list="true";;
        help|h)     help="true";;
        *)
            wrong_mode "push" $1
    esac
    header_msg="GIT PUSH"
    if [ -n "${fast}" ]; then
        header_msg="${YELLOW}$header_msg FAST${ENDCOLOR}"
    elif [ -n "${force}" ]; then
        header_msg="${RED}$header_msg FORCE${ENDCOLOR}"
    elif [ -n "${list}" ]; then
        header_msg="${YELLOW}$header_msg LIST${ENDCOLOR}"
    else
        header_msg="${YELLOW}$header_msg${ENDCOLOR}"
    fi
    echo -e "${header_msg}"
    echo
    if [ -n "$help" ]; then
        echo -e "usage: ${YELLOW}gitb push <mode>${ENDCOLOR}"
        echo
        echo -e "${YELLOW}Available modes${ENDCOLOR}"
        echo -e "<empty>\t\tPrint list of commits, push them to current branch or pull changes first"
        echo -e "yes|y\t\tSame as <empty> but without pressing 'y'"
        echo -e "force|f\t\tSame as <empty> but with --force"
        echo -e "list|log|l\tPrint a list of unpushed local commits without actual pushing it"
        echo -e "help|h\t\tShow this help"
        exit
    fi
    get_push_list ${current_branch} ${main_branch} ${origin_name}
    if [ -z "$push_list" ]; then
        echo -e "${GREEN}Nothing to push${ENDCOLOR}"
        exit
    fi
    if [ "${history_from}" != "${origin_name}/${current_branch}" ]; then
        echo -e "Branch ${YELLOW}${current_branch}${ENDCOLOR} doesn't exist in the ${YELLOW}${origin_name}${ENDCOLOR}, get commits diff from the base commit"
    fi
    count=$(echo -e "$push_list" | wc -l | sed 's/^ *//;s/ *$//')
    echo -e "Your branch is ahead ${YELLOW}${history_from}${ENDCOLOR} by ${BOLD}$count${ENDCOLOR} commits"
    echo -e "$push_list"
    if [ -n "$list" ]; then
        exit
    fi
    echo
    if [ -n "${force}" ]; then
        force_arg=" --force"
    fi
    if [ -z "${fast}" ]; then
        echo -e "Do you want to push${RED}${force_arg}${ENDCOLOR} this commits to ${YELLOW}${origin_name}/${current_branch}${ENDCOLOR} (y/n)?"
        if [ "${current_branch}" == "${main_branch}" ]; then
            echo -e "${RED}Warning!${ENDCOLOR} You are going to push right in the default ${YELLOW}${main_branch}${ENDCOLOR} branch"
        fi
        yes_no_choice "Pushing..."
    else
        echo -e "${YELLOW}Pushing...${ENDCOLOR}"
        echo
    fi
    push $force_arg
    echo -e "${RED}Cannot push!${ENDCOLOR} There are unpulled changes in ${YELLOW}${origin_name}/${current_branch}${ENDCOLOR}"
    echo
    echo -e "Do you want to pull ${YELLOW}${origin_name}/${current_branch}${ENDCOLOR} (y/n)?"
    yes_no_choice "Pulling..."
    pull $current_branch $origin_name $editor
    echo
    echo -e "${YELLOW}Pushing...${ENDCOLOR}"
    echo
    push $force_arg
}
function cleanup_on_exit {
    if [ -n "$1" ]; then
        git restore --staged $1
    fi
}
function after_commit {
    if [ -n "$1" ]; then
        echo -e "${GREEN}Successful commit $1!${ENDCOLOR}"
    else
        echo -e "${GREEN}Successful commit!${ENDCOLOR}"
    fi
    echo
    commit_hash=$(git rev-parse HEAD)
    echo -e "${BLUE}[$current_branch ${commit_hash::7}]${ENDCOLOR}"
    if [ -z "${commit}" ]; then
        echo $(git log -1 --pretty=%B | cat)
    else
        printf "$commit\n"
    fi
    echo
    print_changes_stat "$(git --no-pager show $commit_hash --stat --format="")"
    if [ -z "${fast}" ] && [ -z "${push}" ]; then
        echo
        echo -e "Push your changes: ${YELLOW}gitb push${ENDCOLOR}"
        echo -e "Undo commit: ${YELLOW}gitb reset${ENDCOLOR}"
    fi
}
function commit_script {
    case "$1" in
        msg|m)              msg="true";;
        ticket|jira|j|t)    ticket="true";;
        fast|f)             fast="true";;
        fasts|fs|sf)        fast="true"; scope="true";;
        push|pu|p)          push="true";;
        fastp|fp|pf)        fast="true"; push="true";;
        fastsp|fsp|fps)     fast="true"; push="true"; scope="true";;
        fixup|fix|x)        fixup="true";;
        fixupp|fixp|xp|px)  fixup="true"; push="true";;
        fastfix|fx|xf)      fixup="true"; fast="true";;
        fastfixp|fxp|xfp)   fixup="true"; fast="true"; push="true";;
        amend|am|a)         amend="true";;
        amendf|amf|af|fa)   amend="true"; fast="true";;
        last|l)             last="true";;
        revert|rev)         revert="true";;
        llm|ai|i)           llm="true";;
        llmf|aif|if)        llm="true"; fast="true";;
        llmp|aip|ip)        llm="true"; push="true";;
        llmfp|aifp|ifp|ipf) llm="true"; fast="true"; push="true";;
        llms|ais|is)        llm="true"; scope="true";;
        llmm|aim|im)        llm="true"; msg="true";;
        help|h)             help="true";;
        *)
            wrong_mode "commit" $1
    esac
    header_msg="GIT COMMIT"
    if [ -n "${llm}" ]; then
        header_msg="$header_msg AI"
    fi
    if [ -n "${fast}" ]; then
        if [ -n "${push}" ]; then
            if [ -n "${fixup}" ]; then
                header_msg="$header_msg FAST FIXUP & PUSH"
            else
                header_msg="$header_msg FAST & PUSH"
            fi
        elif [ -n "${fixup}" ]; then
            header_msg="$header_msg FAST FIXUP"
        else
            header_msg="$header_msg FAST"
        fi
    elif [ -n "${fixup}" ]; then
        if [ -n "${push}" ]; then
            header_msg="$header_msg FIXUP & PUSH"
        else
            header_msg="$header_msg FIXUP"
        fi
    elif [ -n "${push}" ]; then
        header_msg="$header_msg & PUSH"
    elif [ -n "${msg}" ]; then
        header_msg="$header_msg MSG"
    elif [ -n "${ticket}" ]; then
        header_msg="$header_msg TICKET"
    elif [ -n "${amend}" ]; then
        header_msg="$header_msg AMEND LAST"
    elif [ -n "${last}" ]; then
        header_msg="$header_msg LAST"
    elif [ -n "${revert}" ]; then
        header_msg="$header_msg REVERT"
    fi
    echo -e "${YELLOW}${header_msg}${ENDCOLOR}"
    echo
    if [ -n "$help" ]; then
        echo -e "usage: ${YELLOW}gitb commit <mode>${ENDCOLOR}"
        echo
        echo -e "${YELLOW}Available modes${ENDCOLOR}"
        echo -e "<empty>\t\tSelect files to commit and create a conventional message in format: 'type(scope): message'"
        echo -e "msg|m\t\tSame as <empty>, but create multiline commit message using text editor"
        echo -e "ticket|t\tSame as <empty>, but add tracker's ticket info to the end of the commit header"
        echo -e "fast|f\t\tAdd all files (git add .) and create a conventional commit message without scope"
        echo -e "fasts|fs|sf\tAdd all files (git add .) and create a conventional commit message with scope"
        echo -e "push|pu|p\tCreate a conventional commit and push changes at the end"
        echo -e "fastp|fp|pf\tCreate a conventional commit in the fast mode and push changes"
        echo -e "fastsp|fsp|fps\tCreate a conventional commit in the fast mode with scope and push changes"
        echo -e "fixup|fix|x\tSelect files and commit to make a --fixup commit (git commit --fixup <hash>)"
        echo -e "fixupp|fixp|xp\tSelect files and commit to make a --fixup commit and push changes"
        echo -e "fastfix|fx|xf\tAdd all files (git add .) and commit to make a --fixup commit"
        echo -e "fastfixp|fxp\tAdd all files (git add .) and commit to make a --fixup commit and push"
        echo -e "amend|am|a\tSelect files and add them to the last commit without message edit (git commit --amend --no-edit)"
        echo -e "amendf|amf|af\tAdd all fiels to the last commit without message edit (git commit --amend --no-edit)"
        echo -e "last|l\t\tChange commit message to the last one"
        echo -e "revert|rev\tSelect a commit to revert (git revert -no-edit <commit>)"
        echo -e "llm|ai|i\tUse AI to generate commit message based on staged changes"
        echo -e "llmf|aif|if\tUse AI to generate commit message in the fast mode (git add .) without confirmation"
        echo -e "llmp|aip|ip\tUse AI to generate commit message and push changes"
        echo -e "llmfp|aifp|ifp\tUse AI to generate commit message in the fast mode and push changes"
        echo -e "llms|ais|is\tUse AI to generate commit summary with manual type and scope enter"
        echo -e "help|h\t\tShow this help"
        git config --unset gitbasher.cached-git-add 2>/dev/null
        exit
    fi
    if [ -n "$last" ]; then
        git config --unset gitbasher.cached-git-add 2>/dev/null
        git commit --amend
        exit
    fi
    is_clean=$(git status | tail -n 1)
    if [ "$is_clean" = "nothing to commit, working tree clean" ]; then
        if [ -z "${revert}" ]; then
            git config --unset gitbasher.cached-git-add 2>/dev/null
            echo -e "${GREEN}Nothing to commit, working tree clean${ENDCOLOR}"
            exit
        fi
    elif [ -n "${revert}" ]; then
        echo -e "${RED}Cannot revert! There are uncommited changes:${ENDCOLOR}"
        exit
    fi
    if [ -n "${revert}" ]; then
        echo -e "${YELLOW}Step 1.${ENDCOLOR} Select a commit to ${YELLOW}revert${ENDCOLOR} it:"
        choose_commit 20
        result=$(git revert --no-edit ${commit_hash} 2>&1)
        check_code $? "$result" "revert"
        after_commit "revert"
        exit
    fi
    if [ -z "${fast}" ]; then 
        echo -e "${YELLOW}Changed files${ENDCOLOR}"
        git_status
    fi
    saved_git_add=""
    if [ -z "${fast}" ]; then
        saved_git_add=$(git config --get gitbasher.cached-git-add 2>/dev/null)
        if [ -n "$saved_git_add" ]; then
            echo
            echo -e "${YELLOW}Found previous git add arguments:${ENDCOLOR} ${BOLD}$saved_git_add${ENDCOLOR}"
            read -n 1 -p "Use them? (y/n) " -s choice
            echo
            if [ "$choice" = "y" ] || [ "$choice" = "Y" ]; then
                git add $saved_git_add
                if [ $? -eq 0 ]; then
                    git_add="$saved_git_add"
                    use_saved_git_add="true"
                else
                    echo
                    echo -e "${RED}Failed to apply saved git add arguments, continuing normally${ENDCOLOR}"
                    git config --unset gitbasher.cached-git-add 2>/dev/null
                fi
                echo
            else
                git config --unset gitbasher.cached-git-add 2>/dev/null
            fi
        fi
    fi
    if [ -n "${fast}" ]; then
        git add .
        git_add="."
        git config --unset gitbasher.cached-git-add 2>/dev/null
    elif [ -n "${use_saved_git_add}" ]; then
        echo -e "${YELLOW}Step 1.${ENDCOLOR} Using saved git add arguments: ${BOLD}$git_add${ENDCOLOR}"
        echo
    else
        echo
        printf "${YELLOW}Step 1.${ENDCOLOR} List files for "
        if [ -n "${fixup}" ]; then
            printf "${YELLOW}--fixup${ENDCOLOR} "
        elif [ -n "${squash}" ]; then
            printf "${YELLOW}--squash${ENDCOLOR} "
        elif [ -n "${amend}" ]; then
            printf "${YELLOW}--amend${ENDCOLOR} "
        fi
        if [ -n "${amend}" ]; then
            printf "to the last commit in the ${YELLOW}${current_branch}${ENDCOLOR} branch\n"
        else
            printf "commit to the ${YELLOW}${current_branch}${ENDCOLOR} branch\n"
        fi
        echo "Leave it blank to exit without changes"
        while [ true ]; do
            read -p "$(echo -n -e "${BOLD}git add${ENDCOLOR} ")" -e git_add
            git_add=$(echo "$git_add" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')
            if [ "$git_add" == "" ]; then
                exit
            fi
            git add $git_add
            if [ $? -eq 0 ]; then
                git config gitbasher.cached-git-add "$git_add"
                break
            fi
        done
        echo
    fi
    echo -e "${YELLOW}Staged files:${ENDCOLOR}"
    staged="$(sed 's/^/\t/' <<< "$(git diff --name-only --cached)")"
    echo -e "${GREEN}${staged}${ENDCOLOR}"
    if [ -n "${llm}" ] && [ -z "${scope}" ]; then
        if [ -n "${fast}" ]; then
            step="1"
        fi
        echo
        echo -e "${YELLOW}Step ${step}.${ENDCOLOR} Generating ${YELLOW}commit message${ENDCOLOR} using AI..."
        if ! check_ai_available; then
            cleanup_on_exit "$git_add"
            exit 1
        fi
        if [ -n "${msg}" ]; then
            ai_commit_message=$(generate_ai_commit_message_full)
        else
            ai_commit_message=$(generate_ai_commit_message)
        fi
        if [ $? -ne 0 ] || [ -z "$ai_commit_message" ]; then
            echo -e "${RED}Failed to generate AI commit message${ENDCOLOR}"
            cleanup_on_exit "$git_add"
            exit 1
        fi
        ai_commit_message=$(echo "$ai_commit_message" | sed 's/^"//;s/"$//' | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')
        echo
        echo -e "${GREEN}AI generated commit message:${ENDCOLOR}"
        echo -e "${BOLD}$ai_commit_message${ENDCOLOR}"
        echo
        if [ -z "${fast}" ] || [ -n "${push}" ]; then
            read -n 1 -p "Use this commit message? (y/n/e to edit) " -s choice
            echo
            echo
        else
            choice="y"
        fi
        if [ "$choice" = "y" ] || [ "$choice" = "Y" ]; then
            commit="$ai_commit_message"
            result=$(git commit -m """$commit""" 2>&1)
            check_code $? "$result" "commit"
            git config --unset gitbasher.cached-git-add 2>/dev/null
            after_commit
            if [ -n "${push}" ]; then
                echo
                push_script y
            fi
            exit
        elif [ "$choice" = "e" ] || [ "$choice" = "E" ]; then
            echo -e "${YELLOW}Edit the AI generated message:${ENDCOLOR}"
            if [ -n "${msg}" ]; then
                commitmsg_file=".commitmsg__"
                echo "$ai_commit_message" > $commitmsg_file
                while [ true ]; do
                    $editor $commitmsg_file
                    commit_message=$(cat $commitmsg_file | sed '/^#/d')
                    if [ -n "$commit_message" ]; then
                        break
                    fi
                    echo
                    echo -e "${YELLOW}Commit message cannot be empty${ENDCOLOR}"
                    echo
                    read -n 1 -p "Try for one more time? (y/n) " -s -e choice
                    if [ "$choice" != "y" ]; then
                        cleanup_on_exit "$git_add"
                        find . -name "$commitmsg_file*" -delete
                        exit
                    fi    
                done
                commit_message=$(cat $commitmsg_file)
                rm $commitmsg_file
                echo
            else
                read -p "" -e -i "$ai_commit_message" commit_message
            fi
            if [ -z "$commit_message" ]; then
                cleanup_on_exit "$git_add"
                exit
            fi
            commit="$commit_message"
            echo
            result=$(git commit -m """$commit""" 2>&1)
            check_code $? "$result" "commit"
            git config --unset gitbasher.cached-git-add 2>/dev/null
            after_commit
            if [ -n "${push}" ]; then
                echo
                push_script y
            fi
            exit
        else
            echo -e "${YELLOW}Falling back to manual commit message creation...${ENDCOLOR}"
        fi
    fi
    if [ -n "${fixup}" ]; then
        echo
        echo -e "${YELLOW}Step 2.${ENDCOLOR} Select a commit to ${YELLOW}--fixup${ENDCOLOR}:"
        if [ -n "${fast}" ]; then
            choose_commit 9
        else
            choose_commit 19
        fi
        result=$(git commit --fixup $commit_hash 2>&1)
        check_code $? "$result" "fixup"
        git config --unset gitbasher.cached-git-add 2>/dev/null
        after_commit "fixup"
        if [ -n "${push}" ]; then
            echo
            push_script y
        fi
        exit
    fi
    if [ -n "${amend}" ]; then
        result=$(git commit --amend --no-edit 2>&1)
        check_code $? "$result" "amend"
        git config --unset gitbasher.cached-git-add 2>/dev/null
        echo
        after_commit "amend"
        exit
    fi
    echo
    step="2"
    if [ -n "${fast}" ]; then
        step="1"
    fi
    echo -e "${YELLOW}Step ${step}.${ENDCOLOR} What ${YELLOW}type${ENDCOLOR} of changes do you want to commit?"
    echo -e "Final meesage will be ${YELLOW}<type>${ENDCOLOR}(${BLUE}<scope>${ENDCOLOR}): ${BLUE}<summary>${ENDCOLOR}"
    echo -e "1. ${BOLD}feat${ENDCOLOR}:\tnew feature, logic change or performance improvement"
    echo -e "2. ${BOLD}fix${ENDCOLOR}:\t\tsmall changes, eg. bug fix"
    echo -e "3. ${BOLD}refactor${ENDCOLOR}:\tcode change that neither fixes a bug nor adds a feature, style changes"
    echo -e "4. ${BOLD}test${ENDCOLOR}:\tadding missing tests or changing existing tests"
    echo -e "5. ${BOLD}build${ENDCOLOR}:\tchanges that affect the build system or external dependencies"
    echo -e "6. ${BOLD}ci${ENDCOLOR}:\t\tchanges to CI configuration files and scripts"
    echo -e "7. ${BOLD}chore${ENDCOLOR}:\tmaintanance and housekeeping"
    echo -e "8. ${BOLD}docs${ENDCOLOR}:\tdocumentation changes"
    echo -e "9.  \t\twrite plain commit without type and scope"
    echo -e "0. Exit without changes"
    declare -A types=(
        [1]="feat"
        [2]="fix"
        [3]="refactor"
        [4]="test"
        [5]="build"
        [6]="ci"
        [7]="chore"
        [8]="docs"
    )
    while [ true ]; do
        read -n 1 -s choice
        if [ "$choice" == "0" ]; then
            cleanup_on_exit "$git_add"
            exit
        fi
        re='^[0-9]+$'
        if ! [[ $choice =~ $re ]]; then
            continue
        fi
        if [ "$choice" == "9" ]; then
            is_empty="true"
            break
        fi
        commit_type="${types[$choice]}"
        if [ -n "$commit_type" ]; then
            break
        fi
    done
    commit=""
    if [ -z "$is_empty" ]; then
        commit="$commit_type"
    fi
    if [ -z "$is_empty" ] && ([ -z "$fast" ] || [ -n "$scope" ]); then
        step="3"
        if [ -n "${fast}" ]; then
            step="2"
        fi
        echo
        echo -e "${YELLOW}Step ${step}.${ENDCOLOR} Enter a ${YELLOW}scope${ENDCOLOR} of changes to provide some additional context"
        echo -e "Final meesage will be ${BLUE}${commit_type}${ENDCOLOR}(${YELLOW}<scope>${ENDCOLOR}): ${BLUE}<summary>${ENDCOLOR}"
        echo -e "Leave it blank to continue without scope or enter 0 to exit without changes"
        detected_scopes=""
        staged_files=$(git diff --name-only --cached)
        if [ -n "$staged_files" ]; then
            declare -A scope_candidates
            while IFS= read -r file; do
                if [ -n "$file" ]; then
                    dir=$(dirname "$file")
                    if [ "$dir" != "." ]; then
                        last_dir=$(basename "$dir")
                        scope_candidates["$last_dir"]=1
                        if [[ "$dir" == */* ]]; then
                            scope_candidates["$last_dir"]=1
                        fi
                        if [[ "$dir" != */* ]]; then
                            scope_candidates["$dir"]=1
                        fi
                    fi
                    filename=$(basename "$file")
                    filename_no_ext="${filename%.*}"
                    if [[ ! "$filename_no_ext" =~ ^(index|main|app|test|spec|config|readme|license)$ ]]; then
                        scope_candidates["$filename_no_ext"]=1
                    fi
                fi
            done <<< "$staged_files"
            detected_scopes_array=()
            for scope in "${!scope_candidates[@]}"; do
                if [[ ! "$scope" =~ ^(src|lib|test|tests|spec|specs|build|dist|node_modules|vendor)$ ]]; then
                    detected_scopes_array+=("$scope")
                fi
            done
            IFS=$'\n' detected_scopes_sorted=($(sort <<<"${detected_scopes_array[*]}"))
            unset IFS
            if [ ${#detected_scopes_sorted[@]} -gt 0 ]; then
                detected_scopes="${detected_scopes_sorted[*]}"
            fi
        fi
        all_scopes=""
        if [ -n "$scopes" ]; then
            all_scopes="$scopes"
        elif [ -n "$detected_scopes" ]; then
            all_scopes="$detected_scopes"
        fi
        if [ -n "$all_scopes" ]; then
           IFS=' ' read -r -a scopes_array <<< "$all_scopes"
           res=""
           for i in "${!scopes_array[@]}"; do
                scope_display="${scopes_array[$i]}"
                res="$res$((i+1)). ${BOLD}${scope_display}${ENDCOLOR}|"
           done
           echo -e "You can select one of the ${YELLOW}detected scopes${ENDCOLOR}: $(echo $res | column -ts'|')"            
        fi
        while [ true ]; do
            read -p "<scope>: " -e commit_scope
            if [ "$commit_scope" == "0" ]; then
                cleanup_on_exit "$git_add"
                exit
            fi
            if [ -z "$commit_scope" ]; then
                commit="$commit: "
                break
            fi
            re_number='^[1-9][0-9]*$'
            if [[ $commit_scope =~ $re_number ]] && [ -n "$all_scopes" ]; then
                IFS=' ' read -r -a scopes_array <<< "$all_scopes"
                index=$((commit_scope - 1))
                if [ $index -ge 0 ] && [ $index -lt ${#scopes_array[@]} ]; then
                    selected_scope="${scopes_array[$index]}"
                    commit_scope="${selected_scope#*}"
                    commit="$commit($commit_scope): "
                    break
                else
                    echo -e "${RED}Invalid scope index! Please choose from 1-${#scopes_array[@]} or enter custom scope.${ENDCOLOR}"
                    continue
                fi
            else
                re='^[a-zA-Z0-9/,_.-]+$'
                if [[ $commit_scope =~ $re ]]; then
                    commit="$commit($commit_scope): "
                    break
                else
                    echo -e "${RED}Invalid scope format! Use only letters, numbers, hyphens, underscores, and dots.${ENDCOLOR}"
                    echo -e "${RED}Debug: input was '$commit_scope'${ENDCOLOR}"
                    continue
                fi
            fi
        done
    fi
    if [ -z "$is_empty" ] && [ -n "$fast" ] && [ -z "$scope" ]; then
        commit="$commit: "
    fi
    if [ -n "${fast}" ]; then
        if [ -n "$scope" ]; then
            step="3"
        else
            step="2"
        fi
    elif [ -n "$is_empty" ]; then
        step="3"
    else
        step="4"
    fi
    echo
    if [ -n "${llm}" ] && [ -n "${scope}" ]; then
        echo -e "${YELLOW}Step ${step}.${ENDCOLOR} Generating ${YELLOW}commit message summary${ENDCOLOR} using AI..."
        if ! check_ai_available; then
            cleanup_on_exit "$git_add"
            exit 1
        fi
        ai_commit_message=$(generate_ai_commit_message_subject "$commit")
        if [ $? -ne 0 ] || [ -z "$ai_commit_message" ]; then
            echo -e "${RED}Failed to generate AI commit message${ENDCOLOR}"
            cleanup_on_exit "$git_add"
            exit 1
        fi
        ai_commit_message=$(echo "$ai_commit_message" | sed 's/^"//;s/"$//' | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')
        echo
        echo -e "${GREEN}AI generated commit message:${ENDCOLOR}"
        echo -e "${BOLD}$ai_commit_message${ENDCOLOR}"
        echo
        read -n 1 -p "Use this commit message? (y/n/e to edit) " -s choice
        echo
        if [ "$choice" = "y" ] || [ "$choice" = "Y" ]; then
            commit="$ai_commit_message"
            echo
            result=$(git commit -m """$commit""" 2>&1)
            check_code $? "$result" "commit"
            git config --unset gitbasher.cached-git-add 2>/dev/null
            after_commit
            if [ -n "${push}" ]; then
                echo
                push_script y
            fi
            exit
        elif [ "$choice" = "e" ] || [ "$choice" = "E" ]; then
            echo
            echo -e "${YELLOW}Edit the AI generated message:${ENDCOLOR}"
            read -p "" -e -i "$ai_commit_message" commit_message
            if [ -z "$commit_message" ]; then
                cleanup_on_exit "$git_add"
                exit
            fi
            commit="$commit_message"
            echo
            result=$(git commit -m """$commit""" 2>&1)
            check_code $? "$result" "commit"
            git config --unset gitbasher.cached-git-add 2>/dev/null
            after_commit
            if [ -n "${push}" ]; then
                echo
                push_script y
            fi
            exit
        else
            echo
            echo -e "${YELLOW}Falling back to manual commit message creation...${ENDCOLOR}"
            echo
        fi
    fi
    echo -e "${YELLOW}Step ${step}.${ENDCOLOR} Write a ${YELLOW}summary${ENDCOLOR} about your changes"
    if [ -n "$is_empty" ]; then
        echo -e "Final meesage will be ${YELLOW}<summary>${ENDCOLOR}"
    elif [ "$commit_scope" == "" ]; then
        echo -e "Final meesage will be ${BLUE}${commit_type}${ENDCOLOR}: ${YELLOW}<summary>${ENDCOLOR}"
    else
        echo -e "Final meesage will be ${BLUE}${commit_type}${ENDCOLOR}(${BLUE}${commit_scope}${ENDCOLOR}): ${YELLOW}<summary>${ENDCOLOR}"
    fi
    echo -e "Leave it blank to exit without changes"
    if [ -n "$msg" ]; then
        commitmsg_file=".commitmsg__"
        touch $commitmsg_file
        staged_with_tab="$(sed 's/^/####\t/' <<< "${staged}")"
        echo """
####
#### Step ${step}. Write a <summary> about your changes. Lines starting with '#' will be ignored. 
#### 
#### On branch ${current_branch}
#### Changes to be commited:
${staged_with_tab}
####
#### Here is expected format:
#### ${commit}<summary>
#### <BLANK LINE>
#### <optional body>
#### <BLANK LINE>
#### <optional footer>
####
#### Summary should provide a succinct description of the change:
####     use the imperative, present tense: 'change' not 'changed' nor 'changes'
####     no dot (.) at the end
####     don't capitalize the first letter
####
#### The body is optional and should explain why you are making the change. 
####
#### The footer is optional and should contain any information about 'Breaking Changes'.
#### Breaking Change section should start with the phrase 'BREAKING CHANGE: ' followed by a summary of the breaking change.
####
#### Similarly, a Deprecation section should start with 'DEPRECATED: ' followed by a short description of what is deprecated.
""" >> $commitmsg_file
        while [ true ]; do
            $editor $commitmsg_file
            commit_message=$(cat $commitmsg_file | sed '/^#/d')
            if [ -n "$commit_message" ]; then
                break
            fi
            echo
            echo -e "${YELLOW}Commit message cannot be empty${ENDCOLOR}"
            echo
            read -n 1 -p "Try for one more time? (y/n) " -s -e choice
            if [ "$choice" != "y" ]; then
                cleanup_on_exit "$git_add"
                find . -name "$commitmsg_file*" -delete
                exit
            fi    
        done
        find . -name "$commitmsg_file*" -delete
    else
        read -p "$(echo -n -e "${commit}")" -e commit_message
        if [ -z "$commit_message" ]; then
            cleanup_on_exit "$git_add"
            exit
        fi
    fi
    if [ -n "${ticket}" ]; then
        echo
        echo -e "${YELLOW}Step 5.${ENDCOLOR} Enter the number of a resolved issue (e.g. in JIRA or Youtrack)"
        echo -e "It will be added to the end of the summary header"
        echo -e "Leave it blank to continue or 0 to exit without changes"
        if [ -n "$ticket_name" ]; then
            read -p "${ticket_name}${sep}" -e commit_ticket
        else 
            read -p "<ticket>: " -e commit_ticket
        fi
        if [ "$commit_ticket" == "0" ]; then
            cleanup_on_exit "$git_add"
            exit
        fi
        if [ "$commit_ticket" != "" ]; then
            commit_ticket=$(echo "$commit_ticket" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')
            summary=$(echo "$commit_message" | head -n 1)
            remaining_message=""
            if [ "$summary" != "$commit_message" ]; then
                remaining_message=$(echo "$commit_message" | tail -n +2)
                remaining_message="""
    $remaining_message"
            fi
            if [ -n "$ticket_name" ]; then
                commit_ticket="${ticket_name}${sep}${commit_ticket}"
            fi
            commit_message="$summary ($commit_ticket)$remaining_message"
        fi
    fi
    commit="${commit}${commit_message}"
    echo
    result=$(git commit -m """$commit""" 2>&1)
    check_code $? "$result" "commit"
    git config --unset gitbasher.cached-git-add 2>/dev/null
    after_commit
    if [ -n "${push}" ]; then
        echo
        push_script y
    fi
}
function branch_script {
    case "$1" in
        list|l)      list="true";;
        remote|r|re) remote="true";;
        main|def|m)  main="true";;
        new|n|c)          
            new="true"
            current="true"    
        ;;
        newd|nd)        
            new="true"
        ;;
        delete|del|d) delete="true";;
        tag|t)        tag="true";;
        help|h)       help="true";;
        *)
            wrong_mode "branch" $1
    esac
    header="GIT BRANCH"
    if [ -n "${remote}" ]; then
        header="$header REMOTE"
    elif [ -n "${main}" ]; then
        header="$header DEFAULT"
    elif [ -n "${current}" ]; then
        header="$header NEW"
    elif [ -n "${new}" ]; then
        header="$header NEW FROM DEFAULT"
    elif [ -n "${list}" ]; then
        header="$header LIST"
    elif [ -n "${delete}" ]; then
        header="$header DELETE"
    elif [ -n "${tag}" ]; then
        header="$header TAG"
    fi
    echo -e "${YELLOW}${header}${ENDCOLOR}"
    echo
    if [ -n "$help" ]; then
        echo -e "usage: ${YELLOW}gitb branch <mode>${ENDCOLOR}"
        echo
        echo -e "${YELLOW}Available modes${ENDCOLOR}"
        echo -e "<empty>\t\tSelect a local branch to switch"
        echo -e "list|l\t\tPrint a list of local branches"
        echo -e "remote|re|r\tFetch $origin_name and select a remote branch to switch"
        echo -e "main|def|m\tSwitch to $main_branch without additional confirmations"
        echo -e "tag|t\t\tCheckout to a specific tag"
        echo -e "new|n|c\t\tBuild a conventional name and create a new branch from $main_branch"
        echo -e "newd|nd\t\tBuild a conventional name, switch to $main_branch, pull it and create new branch"
        echo -e "delete|del|d\tSelect a local branch to delete"
        echo -e "help|h\t\tShow this help"
        exit
    fi
    if [[ -n "${main}" ]]; then
        switch ${main_branch}
        exit
    fi
    if [[ -n "${tag}" ]]; then
        echo -e "${YELLOW}Do you want to fetch remote tags first?${ENDCOLOR}"
        read -n 1 -p "Fetch remote? (y/n) " choice
        echo
        if [ "$choice" = "y" ] || [ "$choice" = "Y" ]; then
            echo
            echo -e "${YELLOW}Fetching remote tags...${ENDCOLOR}"
            fetch_output=$(git fetch --tags 2>&1)
            check_code $? "$fetch_output" "fetch remote tags"
        fi
        echo
        echo -e "${YELLOW}Select a tag to checkout:${ENDCOLOR}"
        tags_info_str=$(git for-each-ref --count=999  --sort=-creatordate refs/tags --format="${BLUE_ES}%(refname:short)${ENDCOLOR_ES} | %(contents:subject) | ${YELLOW_ES}%(objectname:short)${ENDCOLOR_ES} | ${CYAN_ES}%(creatordate:human)${ENDCOLOR_ES}" | column -ts'|' )
        IFS=$'\n' read -rd '' -a tags_info <<<"$tags_info_str"
        if [ -z "$tags_info" ]; then
            echo -e "${RED}No tags found in this repository${ENDCOLOR}"
            exit
        fi
        for index in "${!tags_info[@]}"; do
            echo -e "$(($index+1)). ${tags_info[index]}"
        done
        echo "0. Exit without changes"
        echo
        while [ true ]; do
            read -p "Select tag number: " choice
            if [ "$choice" == "0" ] || [ "$choice" == "" ]; then
                exit
            fi
            re='^[1-9][0-9]*$'
            if [[ $choice =~ $re ]]; then
                index=$((choice - 1))
                if [ $index -ge 0 ] && [ $index -lt ${#tags_info[@]} ]; then
                    selected_tag=$(git for-each-ref --count=999 --sort=-creatordate refs/tags --format='%(refname:short)' | sed -n "$((index+1))p")
                    break
                else
                    echo -e "${RED}Invalid tag number! Please choose from 1-${#tags_info[@]}.${ENDCOLOR}"
                    echo
                    continue
                fi
            else
                echo -e "${RED}Please enter a valid tag number.${ENDCOLOR}"
                echo
                continue
            fi
        done
        echo
        echo -e "${YELLOW}Checking out to tag ${selected_tag}...${ENDCOLOR}"
        echo
        checkout_output=$(git checkout $selected_tag 2>&1)
        checkout_code=$?
        if [ $checkout_code -eq 0 ]; then
            echo -e "${GREEN}Successfully checked out to tag '${selected_tag}'${ENDCOLOR}"
            echo -e "${YELLOW}Note: You are now in 'detached HEAD' state${ENDCOLOR}"
            echo -e "If you want to make changes, create a new branch: ${YELLOW}gitb branch new${ENDCOLOR}"
        else
            echo -e "${RED}Failed to checkout to tag ${selected_tag}! Error message:${ENDCOLOR}"
            echo "${checkout_output}"
            exit $checkout_code
        fi
        exit
    fi
    if [[ -z "$new" ]] && [[ -z "$remote" ]] && [[ -z "$delete" ]] && [[ -z "$list" ]] && [[ -z "$tag" ]]; then
        echo -e "${YELLOW}Select a branch to switch from '${current_branch}'${ENDCOLOR}:"
        choose_branch
        echo
        switch ${branch_name}
        exit
    elif [[ -z "$new" ]] && [[ -n "$remote" ]] && [[ -z "$delete" ]] && [[ -z "$tag" ]]; then
        echo -e "${YELLOW}Fetching remote...${ENDCOLOR}"
        echo
        fetch_output=$(git fetch 2>&1)
        check_code $? "$fetch_output" "fetch remote"
        prune_output=$(git remote prune $origin_name 2>&1)
        echo -e "${YELLOW}Switch from '${current_branch}' to the remote branch${ENDCOLOR}"
        choose_branch "remote"
        echo
        switch ${branch_name}
        exit
    elif [[ -z "$new" ]] && [[ -n "$delete" ]] && [[ -z "$tag" ]]; then
        IFS=$'\n' read -rd '' -a merged_branches <<<"$(git branch -v --sort=-committerdate --merged | cat 2>&1)"
        merged_branches_without_main=()
        for index in "${!merged_branches[@]}"
        do
            branch_with_info="$(echo "${merged_branches[index]}" | sed -e 's/^[[:space:]]*//')"
            if [[ ${branch_with_info} != "${main_branch}"* ]] && [[ ${branch_with_info} != "*"* ]] ; then
                merged_branches_without_main+=("$branch_with_info")
            fi
        done
        number_of_branches=${#merged_branches_without_main[@]}
        if [ $number_of_branches != 0 ]; then
            echo -e "${YELLOW}Do you want to delete merged local branches?${ENDCOLOR}"
            echo -e "These are branches without new changes regarding ${YELLOW}${main_branch}${ENDCOLOR}"
            for index in "${!merged_branches_without_main[@]}"
            do
                printf "\t${merged_branches_without_main[index]}\n"
            done
            printf "\nAnswer (y/n): "
            while [ true ]; do
                read -n 1 -s choice
                if [ "$choice" == "y" ]; then
                    printf "y\n\n"
                    branches_to_delete="$(git branch --merged | egrep -v "(^\*|master|main|develop|${main_branch})" | xargs)"
                    IFS=$' ' read -rd '' -a branches <<<"$branches_to_delete"
                    for index in "${!branches[@]}"
                    do
                        branch_to_delete="$(echo "${branches[index]}" | xargs)"
                        delete_output=$(git branch -d $branch_to_delete 2>&1)
                        delete_code=$?
                        if [ $delete_code == 0 ]; then
                            echo -e "${GREEN}Branch '$branch_to_delete' is deleted!${ENDCOLOR}"
                        else
                            echo -e "${RED}Cannot delete branch '$branch_to_delete'!${ENDCOLOR}"
                            echo -e "${delete_output}"
                            break
                        fi
                    done
                    echo
                    break
                else
                    printf "n\n\n"
                    break
                fi
            done
        fi
        echo -e "${YELLOW}Delete a local branch${ENDCOLOR}"
        choose_branch "delete"
        echo
        delete_output=$(git branch -d $branch_name 2>&1)
        delete_code=$?
        if [ "$delete_code" == 0 ]; then
            echo -e "${GREEN}Branch '$branch_name' is deleted!${ENDCOLOR}"
        elif [[ ${delete_output} == *"is not fully merged"* ]]; then
            echo -e "${RED}The branch '$branch_name' is not fully merged${ENDCOLOR}"
            echo "Do you want to force delete (-D flag) this branch?"
            printf "Answer (y/n): "
            while [ true ]; do
                read -n 1 -s choice
                if [ "$choice" == "y" ]; then
                    printf "y\n\n"
                    delete_output=$(git branch -D $branch_name 2>&1)
                    delete_code=$?
                    if [ "$delete_code" != 0 ]; then
                        echo -e "${RED}Cannot delete branch '$branch_name'! Error message:${ENDCOLOR}"
                        echo -e "${delete_output}"
                        exit
                    fi
                    echo -e "${GREEN}Branch '$branch_name' is deleted!${ENDCOLOR}"
                    break
                elif [ "$choice" == "n" ]; then
                    printf "n\n"
                    exit
                fi
            done
        else
            echo -e "${RED}Cannot delete branch '$branch_name'! Error message:${ENDCOLOR}"
            echo -e "${delete_output}"
            exit
        fi
        remote_check=$(git --no-pager log $origin_name/$branch_name..HEAD 2>&1)
        if [[ $remote_check != *"unknown revision or path not in the working tree"* ]]; then
            echo
            echo -e "${YELLOW}Do you want to delete this branch in the remote?${ENDCOLOR}"
            printf "Answer (y/n): "
            while [ true ]; do
                read -n 1 -s choice
                if [ "$choice" == "y" ]; then
                    printf "y\n\n"
                    echo -e "${YELLOW}Deleting...${YELLOW}"
                    push_output=$(git push $origin_name -d $branch_name 2>&1)
                    push_code=$?
                    echo
                    if [ "$push_code" != 0 ]; then
                        echo -e "${RED}Cannot delete branch '$branch_name'! Error message:${ENDCOLOR}"
                        echo -e "${delete_output}"
                        exit
                    fi
                    echo -e "${GREEN}Branch '$branch_name' is deleted in the remote!${ENDCOLOR}"
                    break
                elif [ "$choice" == "n" ]; then
                    printf "n\n"
                    exit
                fi
            done
        fi
        exit
    fi
    echo -e "${YELLOW}Current local branches:${ENDCOLOR}"
    list_branches
    if [ -n "$list" ]; then
        exit
    fi
    echo
    detected_prefixes=""
    all_branches=$(git branch -a --format='%(refname:short)' 2>/dev/null | sed 's|origin/||g' | sort -u)
    if [ -n "$all_branches" ]; then
        declare -A prefix_candidates
        while IFS= read -r branch; do
            if [ -n "$branch" ] && [[ "$branch" != "$main_branch" ]] && [[ "$branch" != "HEAD" ]]; then
                if [[ "$branch" =~ ^([a-zA-Z0-9]+)[-_/](.+)$ ]]; then
                    prefix="${BASH_REMATCH[1]}"
                    if [[ ${#prefix} -ge 2 ]] && [[ ! "$prefix" =~ ^(dev|tmp|old|new|test)$ ]]; then
                        prefix_candidates["$prefix"]=1
                    fi
                fi
            fi
        done <<< "$all_branches"
        detected_prefixes_array=()
        for prefix in "${!prefix_candidates[@]}"; do
            detected_prefixes_array+=("$prefix")
        done
        if [ ${#detected_prefixes_array[@]} -gt 0 ]; then
            IFS=$'\n' detected_prefixes_sorted=($(sort <<<"${detected_prefixes_array[*]}"))
            unset IFS
            detected_prefixes="${detected_prefixes_sorted[*]}"
        fi
    fi
    all_prefixes=""
    if [ -n "$ticket_name" ]; then
        if [ -n "$detected_prefixes" ]; then
            all_prefixes="$ticket_name $detected_prefixes"
        else
            all_prefixes="$ticket_name"
        fi
    elif [ -n "$detected_prefixes" ]; then
        all_prefixes="$detected_prefixes"
    fi
    branch_type=""
    branch_type_and_sep=""
    if [ -z "$all_prefixes" ]; then
        echo -e "${YELLOW}Step 1.${ENDCOLOR} Enter the full name of the branch"
        echo "Leave it blank if you want to exit"
        printf "${BOLD}git branch${ENDCOLOR} "
        read -e branch_name
        if [ -z "$branch_name" ]; then
            exit
        fi
        branch_name="${branch_name##*( )}"
    else
        echo -e "${YELLOW}Step 1.${ENDCOLOR} Select a prefix for your branch name"
        echo -e "Branches will be created with separator '${YELLOW}${sep}${ENDCOLOR}' (e.g., ${YELLOW}prefix${sep}name${ENDCOLOR})"
        IFS=' ' read -r -a prefixes_array <<< "$all_prefixes"
        declare -A prefixes_map
        res=""
        for i in "${!prefixes_array[@]}"; do
            option=$((i+1))
            prefixes_map["$option"]="${prefixes_array[$i]}"
            res="$res$option. ${BOLD}${prefixes_array[$i]}${ENDCOLOR}|"
        done
        no_prefix_option=$((${#prefixes_array[@]}+1))
        prefixes_map["$no_prefix_option"]=""
        res="$res$no_prefix_option. ${BOLD}no prefix${ENDCOLOR}|"
        echo -e "$(echo $res | column -ts'|')"
        echo -e "0. Exit without changes"
        echo
        while [ true ]; do
            read -p "Select prefix number or enter custom prefix: " choice
            if [ "$choice" == "0" ] || [ "$choice" == "" ]; then
                exit
            fi
            re='^[1-9][0-9]*$'
            if [[ $choice =~ $re ]] && [ -n "${prefixes_map[$choice]+isset}" ]; then
                branch_type="${prefixes_map[$choice]}"
                if [ -n "$branch_type" ]; then
                    branch_type_and_sep="${branch_type}${sep}"
                fi
                break
            else
                choice=$(echo "$choice" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')
                if [ -n "$choice" ]; then
                    re_prefix='^[a-zA-Z0-9]+$'
                    if [[ $choice =~ $re_prefix ]]; then
                        branch_type="$choice"
                        branch_type_and_sep="${branch_type}${sep}"
                        break
                    else
                        echo -e "${RED}Invalid prefix format! Use only letters and numbers.${ENDCOLOR}"
                        echo
                        continue
                    fi
                else
                    echo -e "${RED}Please enter a valid option number or custom prefix.${ENDCOLOR}"
                    echo
                    continue
                fi
            fi
        done
        echo
        echo -e "${YELLOW}Step 2.${ENDCOLOR} Enter the name of the branch"
        echo "Leave it blank if you want to exit"
        printf "${BOLD}git branch${ENDCOLOR}"
        read -p " ${branch_type_and_sep}" -e branch_name
        if [ -z "$branch_name" ]; then
            exit
        fi
        branch_name="${branch_type_and_sep}${branch_name##*( )}"
    fi
    if [[ "$branch_name" == "HEAD" ]] || [[ "$branch_name" == "$origin_name" ]]; then
        echo
        echo -e "${RED}This name is forbidden${ENDCOLOR}"
        exit
    fi
    from_branch=$current_branch
    if [ -z "${current}" ]; then
        echo
        switch $main_branch "true"
        echo -e "${YELLOW}Pulling '$origin_name/$main_branch'...${ENDCOLOR}"
        echo
        pull $main_branch $origin_name $editor
        from_branch=$main_branch
    fi
    create_output=$(git switch -c $branch_name 2>&1)
    create_code=$?
    echo
    if [ $create_code -eq 0 ]; then
        echo -e "${GREEN}${create_output} from '$from_branch'${ENDCOLOR}"
        changes=$(git_status)
        if [ -n "$changes" ]; then
            echo
            echo -e "${YELLOW}Moved changes:${ENDCOLOR}"
            echo -e "${changes}"
        fi
        exit
    fi
    if [[ $create_output == *"already exists"* ]]; then
        echo -e "${RED}Branch with name '${branch_name}' already exists!${ENDCOLOR}"
        exit $create_code
    fi
    echo -e "${RED}Cannot create '${branch_name}'! Error message:${ENDCOLOR}"
    echo "${create_output}"
    exit $create_code
}
function push_tag {
    if [ -z "$1" ] || [ "$1" == "" ]; then
        all="true"
        push_output=$(git push $origin_name --tags 2>&1)
    elif [ -n "$2" ]; then
        push_output=$(git push --delete $origin_name $1 2>&1)
    else
        push_output=$(git push $origin_name $1 2>&1)
    fi
    push_code=$?
    if [ -n "$delete" ]; then
        if [[ "$push_output" == *"remote ref does not exist"* ]]; then
            echo -e "${RED}Tag '$1' doesn't exist in the ${origin_name}${ENDCOLOR}"
            exit
        fi
        echo -e "${GREEN}Tag '$1' is deleted from the ${origin_name}!${ENDCOLOR}"
        exit
    fi
    repo=$(get_repo)
    if [ -n "$all" ]; then
        echo
        IFS=$'\n' read -rd '' -a lines_with_success <<< "$(sed -n '/\[new tag\]/p' <<< "$push_output")"
        number_of_tags=${#lines_with_success[@]}
        if [ $number_of_tags != 0 ]; then
            echo -e "${GREEN}Pushed successfully!${ENDCOLOR}"
            for index in "${!lines_with_success[@]}"
            do
                echo -e "\t$(sed -e 's#.*\-> \(\)#\1#' <<< "${lines_with_success[index]}" )"
            done
            echo
        fi
    fi
    if [ $push_code != 0 ] ; then
        if [[ "$push_output" == *"Updates were rejected because the tag already exists in the remote"* ]]; then
            echo -e "${RED}Some tags were rejected${ENDCOLOR}"
            IFS=$'\n' read -rd '' -a lines_with_rejected <<< "$(sed -n '/\[rejected\]/p' <<< "$push_output")"
            for index in "${!lines_with_rejected[@]}"
            do
                echo -e "\t$(sed -e 's#.*\-> \(\)#\1#' <<< "${lines_with_rejected[index]}" )"
            done
            echo
            echo -e "${YELLOW}Repo:${ENDCOLOR} ${repo}"
            exit
        fi
        echo -e "${RED}Cannot push! Error message:${ENDCOLOR}"
        echo "$push_output"
        exit $push_code
    fi
    if [[ $push_output == *"Everything up-to-date"* ]]; then
        echo -e "${GREEN}Everything up-to-date${ENDCOLOR}"
    elif [ -z "$all" ]; then
        echo -e "${GREEN}Successful push tag '$1'!${ENDCOLOR}"
    else
        echo -e "${GREEN}Successful push all local tags!${ENDCOLOR}"
    fi
    echo -e "${YELLOW}Repo:${ENDCOLOR}\t${repo}"
    if [ -z "$all" ]; then
        if [[ $repo == *"github"* ]]; then
            echo -e "${YELLOW}Tag:${ENDCOLOR}\t${repo}/releases/tag/$1"
        elif [[ $repo == *"gitlab"* ]]; then
            echo -e "${YELLOW}Tag:${ENDCOLOR}\t${repo}/-/tags/$1"
        fi
    fi
}
function tag_script {
    case "$1" in
        annotated|a|an)     annotated="true";;
        commit|c|co|cm)     select="true"; commit="true";;
        all|al)             select="true"; annotated="true";;
        push|ps|ph|p)       push="true"; select="true";;
        push-all|pa)        push="true";;
        delete|del|d)       delete="true"; select="true";;
        delete-all|da)      delete="true";;
        list|log|l)         list="true";;
        remote|re|r|fetch)  list="true"; remote="true";;
        help|h)             help="true";;
        *)
            wrong_mode "tag" $1
    esac
    header="GIT TAG"
    if [ -n "${annotated}" ] && [ -n "${commit}" ]; then
        header="$header ALL"
    elif [ -n "${annotated}" ]; then
        header="$header ANNOTATED"
    elif [ -n "${commit}" ]; then
        header="$header COMMIT"
    elif [ -n "${push}" ] && [ -n "${select}" ]; then
        header="$header PUSH"
    elif [ -n "${push}" ]; then
        header="$header PUSH ALL"
    elif [ -n "${delete}" ] && [ -n "${select}" ]; then
        header="$header DELETE"
    elif [ -n "${delete}" ]; then
        header="$header DELETE ALL"    
    elif [ -n "${list}" ]; then
        header="$header LIST"
    elif [ -n "${remote}" ]; then
        header="$header REMOTE"
    fi
    echo -e "${YELLOW}${header}${ENDCOLOR}"
    echo
    if [ -n "$help" ]; then
        echo -e "usage: ${YELLOW}gitb tag <mode>${ENDCOLOR}"
        echo
        echo -e "${YELLOW}Available modes${ENDCOLOR}"
        echo -e "<empty>\t\tCreate a new tag from the last commit"
        echo -e "annotated|a|an\tCreate a new annotated tag from the last commit"
        echo -e "commit|c|co|cm\tCreate a new tag from a selected commit"
        echo -e "all|al\t\tCreate a new annotated tag from a selected commit"
        echo -e "push|ps|ph|p\tSelect a local tag and push it to the remote repository"
        echo -e "push-all|pa\tPush all tags to the remote repository"
        echo -e "delete|del|d\tSelect a tag to delete"
        echo -e "delete-all|da\tDelete all local tags"
        echo -e "list|log|l\tPrint a list of local tags"
        echo -e "remote|fetch|r\tFetch tags from the remote repository and print it"
        echo -e "help|h\t\tShow this help"
        exit
    fi
    if [ -n "${remote}" ]; then
        echo -e "${YELLOW}Fetching tags from the remote...${ENDCOLOR}"
        fetch_output=$(git fetch $origin_name --tags 2>&1)
        check_code $? "$fetch_output" "fetch tags"
        echo
        if [ "$fetch_output" != "" ]; then
            echo -e "${YELLOW}New tags:${ENDCOLOR}"
            IFS=$'\n' read -rd '' -a lines_with_tags <<< "$(sed -n '/\[new tag\]/p' <<< "$fetch_output")"
            for index in "${!lines_with_tags[@]}"
            do
                echo -e "\t$(sed -e 's#.*\-> \(\)#\1#' <<< "${lines_with_tags[index]}" )"
            done
            echo
        fi
    fi
    count=9
    if [ -n "${delete}" ] || [ -n "${push}" ] || [ -n "${list}" ]; then
        count=999  # Show all tags
    fi
    tags_info_str=$(git for-each-ref --count=$count  --sort=-creatordate refs/tags --format="${BLUE_ES}%(refname:short)${ENDCOLOR_ES} | %(contents:subject) | ${YELLOW_ES}%(objectname:short)${ENDCOLOR_ES} | ${CYAN_ES}%(creatordate:human)${ENDCOLOR_ES}" | column -ts'|' )
    IFS=$'\n' read -rd '' -a tags_info <<<"$tags_info_str"
    number_of_tags=${#tags_info[@]}
    if [ $number_of_tags == 0 ]; then
        echo -e "${YELLOW}There is no local tags${ENDCOLOR}"
        if [ -n "${delete}" ] || [ -n "${push}" ]; then
            exit
        fi
    else
        tags_header="Last ${number_of_tags} local tags"
        if [ -n "${delete}" ] || [ -n "${list}" ]; then
            tags_header="All ${number_of_tags} local tags"
        fi
        echo -e "${YELLOW}${tags_header}${ENDCOLOR}"
        for index in "${!tags_info[@]}"
        do  
            tag_line="${tags_info[index]}"
            if [ -n "${delete}" ] || [ -n "${push}" ]; then
                echo -e "$(($index+1)). ${tag_line}"
            else
                echo -e "${tag_line}"
            fi
        done
    fi
    if [ -n "$list" ]; then
        exit
    fi
    if [ -n "$push" ] && [ -z "$select" ]; then
        echo
        echo -e "${YELLOW}Pushing all tags..."${ENDCOLOR}
        push_tag
        exit
    fi
    if [ -n "${delete}" ] && [ -z "$select" ]; then
        echo
        echo -e "${YELLOW}Do you really want to delete all local tags (y/n)?${ENDCOLOR}"
        git tag | xargs git tag -d 
        exit
    fi
    if [ -n "${delete}" ] || [ -n "$push" ]; then
        if [ $number_of_tags -gt 9 ]; then
            echo "00. Exit"
        else
            echo "0. Exit"
        fi
        echo
        if [ -n "${delete}" ]; then
            read_prefix="Enter tag number to delete: "
        else
            read_prefix="Enter tag number to push: "
        fi
        IFS=$'\n' read -rd '' -a tags <<<"$(git for-each-ref --count=$count  --sort=-creatordate refs/tags --format="%(refname:short)")"
        choose "${tags[@]}"
        tag_name=$choice_result
        echo
        if [ -n "${push}" ]; then
            echo -e "${YELLOW}Pushing..."${ENDCOLOR}
            echo
            push_tag $tag_name
            exit
        fi
        delete_result=$(git tag -d $tag_name 2>&1)
        check_code $? "$delete_result" "delete tag"
        echo -e "${GREEN}Successfully deleted tag '${tag_name}'!${ENDCOLOR}"
        echo
        echo -e "Do you want to delete this tag in the ${YELLOW}${origin_name}${ENDCOLOR} (y/n)?"
        yes_no_choice "\nDeleting..."
        push_tag $tag_name "true"
        exit
    fi
    echo
    if [ -n "$select" ]; then
        echo -e "${YELLOW}Select a commit for a new tag on branch '$current_branch'${ENDCOLOR}"
        choose_commit 9
        echo
        echo -e "${YELLOW}Selected commit${ENDCOLOR}"
    else
        commit_hash=$(git rev-parse HEAD)
        echo -e "${YELLOW}Last branch commit${ENDCOLOR}"
    fi
    commit_message=$(git log -1 --pretty=%B $commit_hash | cat)
    echo -e "${BLUE}[$current_branch ${commit_hash::7}]${ENDCOLOR} ${commit_message}"
    echo
    echo -e "${YELLOW}Enter the name for a new tag${ENDCOLOR}"
    echo -e "If this is a release tag, use version number in semver format like '1.0.0-alpha'"
    echo -e "Leave it blank to exit"
    if [ -n "${annotated}" ]; then
        prompt="$(echo -n -e "${BOLD}git tag -a${ENDCOLOR} ")"
    else
        prompt="$(echo -n -e "${BOLD}git tag${ENDCOLOR} ")"
    fi
    read -p "$prompt" -e tag_name
    if [ -z "$tag_name" ]; then
        exit
    fi
    if [[ "$tag_name" == "tag" ]] || [[ "$tag_name" == *" "* ]]; then
        echo
        echo -e "${RED}This name is forbidden!${ENDCOLOR}"
        exit
    fi
    if [ -n "$annotated" ]; then
        tag_file=".tagmsg__"
        touch $tag_file
        echo """
####
#### Write some words about the new tag '${tag_name}'
#### [$current_branch ${commit_hash::7}] ${commit_message}
#### 
#### You can place changelog here if this tag for a new release
""" >> $tag_file
        while [ true ]; do
            $editor $tag_file
            tag_message=$(cat $tag_file | sed '/^#/d')
            if [ -n "$tag_message" ]; then
                break
            fi
            echo
            echo -e "${YELLOW}Tag message cannot be empty${ENDCOLOR}"
            echo
            read -n 1 -p "Do you want to try for one more time? (y/n) " -s -e choice
            if [ "$choice" != "y" ]; then
                find . -name "$tag_file*" -delete
                exit
            fi    
        done
        find . -name "$tag_file*" -delete
    fi
    if [ -z "$select" ]; then
        commit_hash=""
    fi
    echo
    if [ -n "$annotated" ]; then
        tag_output=$(git tag -a -m """$tag_message""" $tag_name $commit_hash 2>&1)
    else
        tag_output=$(git tag $tag_name $commit_hash 2>&1)
    fi
    tag_code=$?
    if [ $tag_code != 0 ]; then
        if [[ $tag_output == *"already exists" ]]; then
            echo -e "${RED}Tag '${tag_name}' already exists!${ENDCOLOR}"
        else
            echo -e "${RED}Cannot create tag '${tag_name}'! Error message:${ENDCOLOR}"
            echo -e "$tag_output"
        fi
        exit
    fi
    if [ -n "$annotated" ]; then
        is_annotated=" annotated"
    fi
    if [ -n "$select" ]; then
        is_commit_hash=" from commit '${commit_hash}'"
    fi
    echo -e "${GREEN}Successfully created${is_annotated} tag '${tag_name}'${is_commit_hash}!${ENDCOLOR}"
    if [ -n "$tag_message" ]; then
        echo -e "$tag_message"
    fi
    echo
    echo -e "Do you want to push it to the ${YELLOW}${origin_name}${ENDCOLOR} (y/n)?"
    yes_no_choice "\nPushing..."
    push_tag $tag_name
}
function reset_script {
    case "$1" in
        soft|s)         soft="true";;
        undo|u)         undo="true";;
        interactive|i)  interactive="true";;
        ref|r)          
            ref="true"
            interactive="true"
        ;;
        help|h) help="true";;
        *)
            wrong_mode "reset" $1
    esac
    header="GIT RESET"
    if [ -n "${ref}" ]; then
        header="$header REFERENCE"
    elif [ -n "${undo}" ]; then
        header="$header UNDO"
    elif [ -n "${soft}" ]; then
        header="$header --soft"
    elif [ -n "${help}" ]; then
        header="$header"
    else
        header="$header --mixed"
    fi
    echo -e "${YELLOW}${header}${ENDCOLOR}"
    echo
    if [ -n "$help" ]; then
        echo -e "usage: ${YELLOW}gitb reset <mode>${ENDCOLOR}"
        echo
        echo -e "${YELLOW}Available modes${ENDCOLOR}"
        echo -e "<empty>\t\tReset last commit (git reset HEAD^ --mixed)"
        echo -e "soft|s\t\tReset last commit, but remain all fiels staged (git reset HEAD^ --soft)"
        echo -e "undo|u\t\tUndo last commit reset (git reset HEAD@{1})"
        echo -e "interactive|i\tSelect a commit to reset"
        echo -e "ref|r\t\tSelect a HEAD reference to reset"
        echo -e "help|h\t\tShow this help"
        exit
    fi
    echo $soft
    cancelled_commit=$(git log -n 1 --pretty="%s | ${YELLOW}%h${ENDCOLOR} | ${CYAN}%cd${ENDCOLOR} (${GREEN}%cr${ENDCOLOR})")
    cancelled_action=$(git reflog -n 1 --pretty="%gs | ${YELLOW}%h${ENDCOLOR} |  ${CYAN}%cd${ENDCOLOR} (${GREEN}%cr${ENDCOLOR})")
    if [ -n "$interactive" ]; then
        if [ -n "$ref" ]; then
            echo -e "${YELLOW}Select a ref to move into:${ENDCOLOR}"
            ref_list 31
            echo "0. Exit..."
            echo
            printf "Enter ref number: "
            choose "${refs_hash[@]}"
            commit_hash=$choice_result
            echo
        else
            echo -e "${YELLOW}Select a commit to reset:${ENDCOLOR}"
            choose_commit 9
        fi
    fi
    move_ref="HEAD^"
    if [ -n "$undo" ]; then
        move_ref="HEAD@{1}"
    elif [ -n "$commit_hash" ]; then
        move_ref=$commit_hash
    fi
    args="--mixed"
    if [ -n "$soft" ]; then
        args="--soft"
    fi
    reset_output=$(git reset $args $move_ref 2>&1)
    check_code $? "$reset_output" "reset"
    new_commit=$(git log -n 1 --pretty="%s | ${YELLOW}%h${ENDCOLOR} | ${CYAN}%cd${ENDCOLOR} (${GREEN}%cr${ENDCOLOR})")
    new_action=$(git reflog -n 1 --pretty="%gs | ${YELLOW}%h${ENDCOLOR} | ${CYAN}%cd${ENDCOLOR} (${GREEN}%cr${ENDCOLOR})")
    msg="${GREEN}New last commit:${ENDCOLOR}|${new_commit}"
    if [ -n "$ref" ] || [ -n "$undo" ]; then
        msg="${msg}\n${GREEN}New last action:${ENDCOLOR}|${new_action}"
    fi
    msg="${msg}\n${RED}Cancelled commit:${ENDCOLOR}|${cancelled_commit}"
    if [ -n "$ref" ] || [ -n "$undo" ]; then
        msg="${msg}\n${RED}Cancelled action:${ENDCOLOR}|${cancelled_action}"
    fi
    msg=$(echo -e "$msg" | column -ts'|')
    echo -e "$msg"
    echo
    echo -e "${YELLOW}Status after reset${ENDCOLOR}"
    git_status
    exit
}
function project_status {
    echo -e "${YELLOW}$project_name${ENDCOLOR} | ${CYAN}$repo_url${ENDCOLOR}"
    echo
    echo -e "${YELLOW}[$current_branch $(git log -n 1 --pretty="%h")]${ENDCOLOR}"
    echo -e "$(git --no-pager log -n 1 --pretty="%s")"
    echo -e "=============================="
    status=$(git_status)
    if [ -n "$status" ]; then
        echo -e "$status"
    else
        echo -e "${GREEN}There are no unstaged files${ENDCOLOR}"
    fi
}
function gitlog {
    git log --pretty="%C(Yellow)%h%C(reset) | %C(Cyan)%ad%C(reset) | %C(Blue)%an%C(reset) | %s (%C(Green)%cr%C(reset))"
}
function reflog {
    git reflog --pretty="%C(Yellow)%h%C(reset) | %C(Blue)%gd%C(reset) | %C(Cyan)%ad%C(reset) | %gs (%C(Green)%cr%C(reset))"
}
function last_commit {
    git --no-pager log -n 1 --pretty="%C(Yellow)%h%C(reset) | %s | %C(Blue)%an%C(reset) | %C(Green)%cr%C(reset) | %C(Cyan)%ad%C(reset)" 
}
function last_ref {
    git --no-pager reflog -n 1 --pretty="%C(Yellow)%h%C(reset) | %C(Cyan)%gd%C(reset) | %gs | %C(Green)%cr%C(reset) | %C(Cyan)%ad%C(reset)"
}
function print_help {
    echo -e "usage: ${YELLOW}gitb <command> <mode>${ENDCOLOR}"
    echo
    msg="${YELLOW}Command${ENDCOLOR}_\t${GREEN}Aliases${ENDCOLOR}_\t${BLUE}Description of ${BOLD}workflow${NORMAL}${BLUE} commands${ENDCOLOR}"
    msg="$msg\ncommit_c|co|com_Everything about commit creation"
    msg="$msg\npush_p|ps|pus_Pushing changes to a remote repository"
    msg="$msg\npull_pu|pl|pul_Pulling changes from a remote repository"
    msg="$msg\nbranch_b|br|bran_Managing branches"
    msg="$msg\ntag_t|tg_Managing tags"
    msg="$msg\nmerge_m|me_Merge changes to the current branch"
    msg="$msg\nrebase_r|re|base_Rebase current branch"
    msg="$msg\nreset_res_Easy to use git reset"
    msg="$msg\nconfig_cf|cfg|conf_Configurate gitbasher"
    msg="$msg\n_ _ _"
    msg="$msg\n${YELLOW}Command${ENDCOLOR}_\t${GREEN}Aliases${ENDCOLOR}_\t${BLUE}Description of ${BOLD}informational${NORMAL}${BLUE} commands${ENDCOLOR}"
    msg="$msg\nstatus_s|st_Info about repo and changed files"
    msg="$msg\nlog_l|lg_Open git log in a pretty format"
    msg="$msg\nreflog_rl|rlg_Open git reflog in a pretty format"
    msg="$msg\nlast-commit_lc|lastc_Show info about the last commit"
    msg="$msg\nlast-ref_lr|lastr_Show info about the last reference"
    echo -e "$(echo -e "$msg" | column -ts '_')"
    exit
}
project_name="$(get_repo_name)"
repo_url="$(get_repo)"
if [ $is_first == "true" ]; then 
    git config --local gitbasher.scopes ""
    echo -e "${GREEN}Thanks for using gitbasher in project '$project_name'${ENDCOLOR}"
    print_configuration
    echo
    echo -e "You can change these settings by using ${YELLOW}gitb cfg <name>${ENDCOLOR}"
    echo
fi
if [ -z $1 ] || [ "$1" == "--help" ] || [ "$1" == "help" ] || [ "$1" == "man" ]; then
    print_help
fi
case "$1" in
    commit|c|co|com)         
        commit_script $2
    ;;
    push|p|ps|pus)         
        push_script $2
    ;;
    pull|pu|pl|pul)         
        pull_script $2
    ;;
    merge|m|me)         
        merge_script $2
    ;;
    rebase|r|re|base)         
        rebase_script $2
    ;;
    branch|b|br|bran)         
        branch_script $2
    ;;
    tag|t|tg)         
        tag_script $2
    ;;
    config|cf|cfg|conf)         
        config_script $2
    ;;
    reset|res)
        reset_script $2
    ;;
    log|l|lg)
        gitlog
    ;;
    reflog|rl|rlg)
        reflog
    ;;
    last-commit|lc|lastc)
        last_commit
    ;;
    last-ref|lr|lastr)
        last_ref
    ;;
    status|s|st)
        project_status
    ;;
    *)
        print_help
    ;;
esac
exit $?
