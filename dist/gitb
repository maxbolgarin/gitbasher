#!/usr/bin/env bash
if [ "$1" == "init" ]; then
git init
fi
git_check=$(git branch --show-current 2>&1)
if [[ "$git_check" == *"fatal: not a git repository"* ]]; then
echo "You can use gitb only in a git repository"
exit
fi
if ((BASH_VERSINFO[0] < 4)); then
YELLOW=${YELLOW:-"e[33m"}
GREEN=${GREEN:-"e[32m"}
ENDCOLOR=${ENDCOLOR:-"e[0m"}
printf "Sorry, you need at least ${YELLOW}bash-4.0${ENDCOLOR} to run gitbasher.n
If your OS is debian-based, use:
${GREEN}apt install --only-upgrade bash${ENDCOLOR}n
If your OS is Mac, use:
${GREEN}brew install bash${ENDCOLOR}nn"
exit 1;
fi
RED="\e[31m"
GREEN="\e[32m"
YELLOW="\e[33m"
BLUE="\e[34m"
PURPLE="\e[35m"
CYAN="\e[36m"
GRAY="\e[37m"
ENDCOLOR="\e[0m"
BOLD="\033[1m"
NORMAL="\033[0m"
function get_config_value {
    value=$(git config --local --get "$1")
    if [ "$value" == "" ]; then
        value=$(git config --global --get "$1")
        if [ "$value" == "" ]; then
            value=$2
        fi
    fi
    echo -e "$value"
}
function set_config_value {
    if [ -z $3 ]; then
        git config --local "$1" "$2"
    else
        git config --global "$1" "$2"
    fi
}
function unset_config_value {
    git config --unset "$1"
    local global_config=$(git config --global --get "$1" 2>/dev/null)
    if [ -n "$global_config" ]; then
        echo
        echo -e "${YELLOW}Global $1 is also configured: ${BLUE}$global_config${ENDCOLOR}"
        echo -e "Do you want to clear it ${YELLOW}globally${ENDCOLOR} for all projects (y/n)?"
        yes_no_choice "\nClear AI proxy globally" "false"
        if [ $? -eq 0 ]; then
            git config --global --unset "$1" 2>/dev/null
            echo -e "${GREEN}$1 cleared globally${ENDCOLOR}"
        fi
    fi
}
function validate_git_url {
    local input="$1"
    validated_url=""
    if [ -z "$input" ]; then
        return 1
    fi
    local cleaned=$(echo "$input" | tr -d '\000-\037\177')
    if [[ "$cleaned" =~ ^https?://[a-zA-Z0-9.-]+/[a-zA-Z0-9._/-]+(.git)?$ ]] || \
       [[ "$cleaned" =~ ^git@[a-zA-Z0-9.-]+:[a-zA-Z0-9._/-]+(.git)?$ ]] || \
       [[ "$cleaned" =~ ^ssh://[a-zA-Z0-9@.-]+/[a-zA-Z0-9._/-]+(.git)?$ ]] || \
       [[ "$cleaned" =~ ^[a-zA-Z0-9._/-]+(.git)?$ ]]; then
        if [ ${#cleaned} -le 500 ]; then
            validated_url="$cleaned"
            return 0
        fi
    fi
    return 1
}
current_branch=$(git branch --show-current)
main_branch=$(get_config_value gitbasher.branch "main")
if [[ "$( git branch | grep "^[\s\*]*\s*main\s*$" )" == "" ]] && [[ "$( git branch | grep "^[\s\*]*\s*master\s*$" )" != "" ]]; then
    main_branch="master"
elif [[ "$(git branch | cat)" == "" ]]; then
    main_branch=$current_branch
fi
if [ "$(get_config_value gitbasher.branch "")" == "" ]; then
    git config --local gitbasher.branch "$main_branch"
fi
origin_name=$(git remote -v | head -n 1 | sed 's/\t.*//')
if [ "$origin_name" == "" ]; then 
    echo -e "${YELLOW}There is no configured remote in this repo!${ENDCOLOR}"
    echo
    echo -e "Use ${BLUE}git remote add origin <url>${ENDCOLOR} to add it manually"
    echo -e "Press '${BOLD}y${ENDCOLOR}' to add it now or an any key to exit"
    read -n 1 -s choice
    if [ "$choice" != "y" ]; then
        exit
    fi
    echo
    read -p "Remote repo URL: " -e remote_url
    if [ "$remote_url" == "" ]; then
        exit
    fi
    if ! validate_git_url "$remote_url"; then
        echo
        echo -e "${RED}Invalid git URL format!${ENDCOLOR}"
        echo -e "${YELLOW}Expected formats:${ENDCOLOR}"
        echo -e "  • https://github.com/user/repo.git"
        echo -e "  • git@github.com:user/repo.git"
        echo -e "  • ssh://git@server.com/repo.git"
        exit 1
    fi
    remote_url="$validated_url"
    remote_check=$(git ls-remote "$remote_url" 2>&1)
    if [[ "$remote_check" == *"does not appear to be a git"* ]]; then
        echo
        echo -e "${RED}'$remote_url' is not a git repository!${ENDCOLOR}"
        echo "Please make sure you have the correct access rights and the repository exists."
        exit
    fi
    git remote add origin "$remote_url"
    echo -e "${GREEN}Remote successfully added!${ENDCOLOR}"
    if [ "$remote_check" == "" ]; then
        echo -e "${YELLOW}Repository '$remote_url' is probably empty${ENDCOLOR}"
    fi
    echo
    origin_name=$(git remote -v | head -n 1 | sed 's/\t.*//')
fi
sep=$(get_config_value gitbasher.sep "-")
editor=$(get_config_value core.editor "vi")
ticket_name=$(get_config_value gitbasher.ticket "")
scopes=$(get_config_value gitbasher.scopes "")
is_first=$(get_config_value gitbasher.isfirst "true")
git config --local gitbasher.isfirst "false"
RED_ES="\x1b[31m"
GREEN_ES="\x1b[32m"
YELLOW_ES="\x1b[33m"
BLUE_ES="\x1b[34m"
PURPLE_ES="\x1b[35m"
CYAN_ES="\x1b[36m"
GRAY_ES="\x1b[37m"
ENDCOLOR_ES="\x1b[0m"
function sanitize_git_name {
    local input="$1"
    sanitized_git_name=""
    if [ -z "$input" ]; then
        return 1
    fi
    local cleaned=$(echo "$input" | sed 's/[^a-zA-Z0-9._/-]//g')
    cleaned=$(echo "$cleaned" | sed 's/^[./]*//;s/[./]*$//')
    if [[ "$cleaned" =~ \.\. ]] || [[ "$cleaned" =~ ^- ]] || [[ "$cleaned" =~ -$ ]] || \
       [[ "$cleaned" =~ ^@ ]] || [[ "$cleaned" == "HEAD" ]] || [[ "$cleaned" =~ ^refs/ ]]; then
        return 1
    fi
    if [ ${#cleaned} -lt 1 ] || [ ${#cleaned} -gt 255 ]; then
        return 1
    fi
    sanitized_git_name="$cleaned"
    return 0
}
function sanitize_file_path {
    local input="$1"
    sanitized_file_path=""
    if [ -z "$input" ]; then
        return 1
    fi
    local cleaned=$(echo "$input" | tr -d '\000-\010\013\014\016-\037\177')
    cleaned=$(echo "$cleaned" | sed 's/\.\.\///g')  # Remove ../
    cleaned=$(echo "$cleaned" | sed 's/;\s*rm\s/; /g')  # Remove rm commands
    cleaned=$(echo "$cleaned" | sed 's/&&\s*rm\s/\&\& /g')  # Remove rm commands
    cleaned=$(echo "$cleaned" | sed 's/|\s*rm\s/| /g')  # Remove rm commands
    if [ ${#cleaned} -gt 1000 ]; then
        return 1
    fi
    sanitized_file_path="$cleaned"
    return 0
}
function sanitize_commit_message {
    local input="$1"
    sanitized_commit_message=""
    if [ -z "$input" ]; then
        return 1
    fi
    local cleaned=$(echo "$input" | tr -d '\000-\010\013\014\016-\037\177')
    cleaned=$(echo "$cleaned" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')
    if [ ${#cleaned} -lt 1 ] || [ ${#cleaned} -gt 2000 ]; then
        return 1
    fi
    sanitized_commit_message="$cleaned"
    return 0
}
function sanitize_command {
    local input="$1"
    sanitized_command=""
    if [ -z "$input" ]; then
        return 1
    fi
    local cleaned=$(echo "$input" | sed 's/[^a-zA-Z0-9._/-]//g')
    if [[ "$cleaned" =~ \.\. ]] || [[ "$cleaned" == *";"* ]] || [[ "$cleaned" == *"|"* ]] || \
       [[ "$cleaned" == *"&"* ]] || [[ "$cleaned" == *"$"* ]] || [[ "$cleaned" == *"\`"* ]]; then
        return 1
    fi
    if [ ${#cleaned} -lt 1 ] || [ ${#cleaned} -gt 100 ] || [[ "$cleaned" =~ ^- ]]; then
        return 1
    fi
    sanitized_command="$cleaned"
    return 0
}
function sanitize_text_input {
    local input="$1"
    local max_length="${2:-500}"
    sanitized_text=""
    if [ -z "$input" ]; then
        return 1
    fi
    local cleaned=$(echo "$input" | tr -d '\000-\010\013\014\016-\037\177')
    cleaned=$(echo "$cleaned" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')
    if [ ${#cleaned} -lt 1 ] || [ ${#cleaned} -gt "$max_length" ]; then
        return 1
    fi
    sanitized_text="$cleaned"
    return 0
}
function validate_numeric_input {
    local input="$1"
    local min_val="$2"
    local max_val="$3"
    validated_number=""
    if [ -z "$input" ]; then
        return 1
    fi
    if ! [[ "$input" =~ ^[0-9]+$ ]]; then
        return 1
    fi
    local num=$((input))
    if [ -n "$min_val" ] && [ "$num" -lt "$min_val" ]; then
        return 1
    fi
    if [ -n "$max_val" ] && [ "$num" -gt "$max_val" ]; then
        return 1
    fi
    validated_number="$num"
    return 0
}
function validate_email {
    local input="$1"
    validated_email=""
    if [ -z "$input" ]; then
        return 1
    fi
    if [[ "$input" =~ ^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$ ]]; then
        if [ ${#input} -le 254 ]; then
            validated_email="$input"
            return 0
        fi
    fi
    return 1
}
function validate_scope_list {
    local input="$1"
    validated_scopes=""
    if [ -z "$input" ]; then
        return 1
    fi
    if [[ "$input" =~ ^([a-zA-Z]+ ){0,8}([a-zA-Z]+)$ ]]; then
        local word_count=$(echo "$input" | wc -w)
        if [ "$word_count" -le 9 ] && [ "$word_count" -ge 1 ]; then
            validated_scopes="$input"
            return 0
        fi
    fi
    return 1
}
function sanitize_choice_input {
    local input="$1"
    local pattern="${2:-^[yn0-9=]$}"
    sanitized_choice=""
    if [ -z "$input" ]; then
        return 1
    fi
    local cleaned=$(echo "$input" | tr '[:upper:]' '[:lower:]')
    if [[ "$cleaned" =~ $pattern ]]; then
        sanitized_choice="$cleaned"
        return 0
    fi
    return 1
}
function show_sanitization_error {
    local input_type="$1"
    local error_msg="$2"
    echo -e "${RED}Invalid $input_type input!${ENDCOLOR}" >&2
    if [ -n "$error_msg" ]; then
        echo -e "${YELLOW}$error_msg${ENDCOLOR}" >&2
    fi
    echo -e "${YELLOW}Please try again with valid input.${ENDCOLOR}" >&2
}
function wrong_mode {
    if [ -n "$2" ]; then
        echo -e "Unknown mode ${YELLOW}$2${ENDCOLOR} for ${YELLOW}gitb $1${ENDCOLOR}"
        echo -e "Use ${GREEN}gitb $1 help${ENDCOLOR} to get usage info"
        exit
    fi
}
function get_repo {
    local remote_name=${origin_name:-origin}
    repo=$(git config --get "remote.${remote_name}.url")
    repo="${repo/"com:"/"com/"}"
    repo="${repo/"io:"/"io/"}"
    repo="${repo/"org:"/"org/"}"
    repo="${repo/"net:"/"net/"}"
    repo="${repo/"dev:"/"dev/"}"
    repo="${repo/"ru:"/"ru/"}"
    repo="${repo/"git@"/"https://"}"
    repo="${repo/".git"/""}" 
    echo "$repo"
}
function get_repo_name {
    repo=$(get_repo)
    echo "${repo##*/}"
}
function print_configuration {
    echo -e "${YELLOW}Current configuration:${ENDCOLOR}"
    echo -e "\tuser.name:\t${YELLOW}$(get_config_value user.name)${ENDCOLOR}"
    echo -e "\tuser.email:\t${YELLOW}$(get_config_value user.email)${ENDCOLOR}"
    echo -e "\tdefault:\t${YELLOW}$main_branch${ENDCOLOR}"
    echo -e "\tseparator:\t${YELLOW}$sep${ENDCOLOR}"
    echo -e "\teditor:\t\t${YELLOW}$editor${ENDCOLOR}"
    if [ "$ticket_name" != "" ]; then
        echo -e "\tticket:\t\t${YELLOW}$ticket_name${ENDCOLOR}"
    fi
    if [ "$scopes" != "" ]; then
        echo -e "\tscopes:\t\t${YELLOW}$scopes${ENDCOLOR}"
    fi
    local ai_key=$(get_ai_api_key)
    if [ -n "$ai_key" ]; then
        ai_key=$(mask_api_key "$ai_key")
        echo -e "\tAI key:\t\t${GREEN}$ai_key${ENDCOLOR}"
    else
        echo -e "\tAI key:\t\t${RED}not set${ENDCOLOR}"
    fi
    local ai_proxy=$(get_ai_proxy)
    if [ -n "$ai_proxy" ]; then
        echo -e "\tAI proxy:\t${GREEN}$ai_proxy${ENDCOLOR}"
    else
        echo -e "\tAI proxy:\t${YELLOW}not set${ENDCOLOR}"
    fi
    local ai_history_limit=$(get_ai_commit_history_limit)
    echo -e "\tAI history:\t${GREEN}$ai_history_limit commits${ENDCOLOR}"
}
function escape {
    string="$1"
    sub="$2"
    escaped="\\$sub"
    echo "${string//${sub}/${escaped}}"
}
function check_code {
    if [ $1 != 0 ]; then
        echo
        echo
        echo -e "${RED}Error during $3!${ENDCOLOR}"
        echo -e "$2"
        if [ -n "$git_add" ]; then
            git restore --staged $git_add
        fi
        exit $1
    fi
}
function yes_no_choice {
    while [ true ]; do
        read -n 1 -s choice
        if [ "$choice" == "y" ]; then
            if [ -n "$1" ]; then
                echo -e "${YELLOW}$1${ENDCOLOR}"
                if [ -z $2 ]; then
                    echo
                fi
            fi
            return
        fi
        if [ "$choice" == "n" ]; then
            exit
        fi
    done
}
function choose {
    values=("$@")
    number_of_values=${#values[@]}
    while [ true ]; do
        if [ $number_of_values -gt 9 ]; then
            read -p "$read_prefix" -e -n 2 choice
        else
            read -p "$read_prefix" -n 1 -s choice
        fi
        if [ "$choice" == "0" ] || [ "$choice" == "00" ]; then
            if [ -n "$git_add" ]; then
                git restore --staged $git_add
            fi
            if [ $number_of_values -le 9 ]; then
                printf $choice
            fi
            exit
        fi
        re='^[0-9=]+$'
        if ! [[ $choice =~ $re ]]; then
            if [ -n "$git_add" ]; then
                git restore --staged $git_add
            fi
            exit
        fi
        if [ "$choice" == "=" ] || [ "$choice" == "==" ]; then
            pressed_alt="true"
            break
        fi
        index=$(($choice-1))
        choice_result=${values[index]}
        if [ -n "$choice_result" ]; then
            if [ $number_of_values -le 9 ]; then
                printf $choice
            fi
            break
        else
            if [ $number_of_values -gt 9 ]; then
                if [ -n "$git_add" ]; then
                    git restore --staged $git_add
                fi
                exit
            fi
        fi
    done
}
function git_status {
    status_output=$(git status --short)
    status_output=$(echo "$status_output" | sed "s/^ D/${RED_ES}\tDeleted: ${ENDCOLOR_ES}/")
    status_output=$(echo "$status_output" | sed "s/^D /${GREEN_ES}Staged\t${RED_ES}Deleted: ${ENDCOLOR_ES}/")
    status_output=$(echo "$status_output" | sed "s/^ M/${YELLOW_ES}\tModified:${ENDCOLOR_ES}/")
    status_output=$(echo "$status_output" | sed "s/^MM/${GRAY_ES}Old\t${YELLOW_ES}Modified:${ENDCOLOR_ES}/")
    status_output=$(echo "$status_output" | sed "s/^AM/${GRAY_ES}Old\t${YELLOW_ES}Modified:${ENDCOLOR_ES}/")
    status_output=$(echo "$status_output" | sed "s/^M /${GREEN_ES}Staged\t${YELLOW_ES}Modified:${ENDCOLOR_ES}/")
    status_output=$(echo "$status_output" | sed "s/^A/${GREEN_ES}Staged\tAdded:   ${ENDCOLOR_ES}/")
    status_output=$(echo "$status_output" | sed "s/^??/${GREEN_ES}\tAdded:   ${ENDCOLOR_ES}/")
    echo -e "$status_output"
}
function commit_list {
    ref=$3
    if [[ "$(git --no-pager log -n 1 2>&1)" == *"does not have any commits yet"* ]]; then
        if [[ "$3" == *"HEAD"* ]]; then
            ref="$(echo "$3" | sed 's/HEAD..//')"
        else
            return 
        fi
    fi
    IFS=$'\n' 
    read -rd '' -a commits_info <<<"$(git --no-pager log -n $1 --pretty="${YELLOW_ES}%h${ENDCOLOR_ES} | %s | ${BLUE_ES}%an${ENDCOLOR_ES} | ${GREEN_ES}%cr${ENDCOLOR_ES}" $ref | column -ts'|')"
    read -rd '' -a commits_hash <<<"$(git --no-pager log -n $1 --pretty="%h" $ref)"
    for index in "${!commits_info[@]}"
    do
        line=${commits_info[index]}
        if [ $2 == "number" ]; then
            line="$(($index+1)). ${line}"
        elif [ $2 == "tab" ]; then
            line="\t${line}"
        fi
        echo -e "$line"
    done
}
function ref_list {
    IFS=$'\n' 
    read -rd '' -a refs_info <<<"$(git --no-pager reflog -n $1 --pretty="${YELLOW_ES}%h${ENDCOLOR_ES} | ${BLUE_ES}%gd${ENDCOLOR_ES} | %gs | ${GREEN_ES}%cr${ENDCOLOR_ES}" | column -ts'|')"
    read -rd '' -a refs_hash <<<"$(git --no-pager reflog -n $1 --pretty="%gd")"
    refs_info=("${refs_info[@]:1}")
    refs_hash=("${refs_hash[@]:1}")
    for index in "${!refs_info[@]}"
    do
        line="$(($index+1)). ${refs_info[index]}"
        echo -e "$line"
    done
}
function choose_commit {
    commit_list $1 "number"
    if [ $1 -gt 9 ]; then
        echo "00. Exit"
    else
        echo "0. Exit"
    fi
    echo "Enter = to show more"
    echo
    read_prefix="Enter commit number: "
    choose "${commits_hash[@]}"
    commit_hash=$choice_result
    if [ -n "$pressed_alt" ]; then
        commit_list 50 "number"
        echo "00. Exit"
        echo
        choose "${commits_hash[@]}"
        commit_hash=$choice_result
    fi
    echo
}
function print_changes_stat {
    IFS=$'\n' read -rd '' -a stats <<< "$1"
    result_stat=""
    bottom_line=""
    number_of_stats=${#stats[@]}
    for index in "${!stats[@]}"
    do
        s=$(echo ${stats[index]} | sed -e 's/^[[:space:]]*//')
        s=$(sed "s/+/${GREEN_ES}+${ENDCOLOR_ES}/g" <<< ${s})
        s=$(sed "s/-/${RED_ES}-${ENDCOLOR_ES}/g" <<< ${s})
        if [ $(($index+1)) == $number_of_stats ]; then
            #s=$(sed '1 s/,/|/' <<< ${s})
            bottom_line="${s}"
            break
        fi
        result_stat="${result_stat}\n${s}"
    done
    echo -e "$(echo -e "${result_stat}" | column -ts'|')"
    echo -e "$bottom_line"
}
function get_push_list {
    push_list_check=$(git --no-pager log $3/$1..HEAD 2>&1)
    if [[ $push_list_check != *"unknown revision or path not in the working tree"* ]]; then
        push_list=$(commit_list 999 "tab" $3/$1..HEAD)
        history_from="$3/$1"
        return
    fi
    if [[ $push_list_check == *"unknown revision or path not in the working tree"* ]]; then
        if [[ $1 == $2 ]]; then
            push_list=$(commit_list 999 "tab")
            history_from="$3/$1"
            return
        fi
    fi
    base_commit=$(diff -u <(git rev-list --first-parent $1) <(git rev-list --first-parent $2) | sed -ne 's/^ //p' | head -1)
    if [ -n "$base_commit" ]; then
        push_list=$(commit_list 999 "tab" $base_commit..HEAD)
        history_from="${base_commit::7}"
    else
        push_list=$(commit_list 999 "tab" $3/$2..HEAD)
        history_from="$3/$2"
    fi
}
function list_branches {
    args="--sort=-committerdate"
    if [[ "$1" == "remote" ]]; then
        args="--sort=-committerdate -r"
    fi
    branches_str=$(git --no-pager branch $args --format="%(refname:short)")
    branches_info_str=$(git --no-pager branch $args --format="${BLUE_ES}%(refname:short)${ENDCOLOR_ES} | %(contents:subject) | ${YELLOW_ES}%(objectname:short)${ENDCOLOR_ES}  | ${GREEN_ES}%(committerdate:relative)${ENDCOLOR_ES}" | column -ts'|' )
    IFS=$'\n' 
    read -rd '' -a branches <<< "$branches_str"
    read -rd '' -a branches_info <<< "$branches_info_str"
    number_of_branches=${#branches[@]}
    if [[ "$1" == "remote" ]]; then
        ((number_of_branches=number_of_branches-1))
    fi
    if [[ "$number_of_branches" == 0 ]]; then
        echo
        echo -e "${YELLOW}There is no branches${ENDCOLOR}"
        to_exit="true"
        return
    fi
    branch_to_check="${branches[0]}"
    if [[ "$1" == "remote" ]]; then
        branch_to_check="${branches[1]}"
        branch_to_check="$(sed "s/remotes\///g" <<< ${branch_to_check})"
        branch_to_check="$(sed "s/${origin_name}\///g" <<< ${branch_to_check})"
    fi
    if [[ "$number_of_branches" == 1 ]] && [[ "${branch_to_check}" == "${current_branch}" ]]; then
        echo
        echo -e "There is only one branch: ${YELLOW}${current_branch}${ENDCOLOR}"
        to_exit="true"
        return
    fi
    if [[ "$1" == "delete" ]] && [[ "$number_of_branches" == 2 ]] && [[ "${current_branch}" != "${main_branch}" ]]; then
        echo
        echo -e "${YELLOW}There are no branches to delete${ENDCOLOR}"
        to_exit="true"
        return
    fi
    branches_first_main=(${main_branch})
    branches_info_first_main=("dummy")
    if [[ "$1" == "delete" ]]; then
        branches_first_main=()
        branches_info_first_main=()
    fi
    if [[ "$1" == "merge" ]] && [[ "$current_branch" == "$main_branch" ]]; then
        branches_first_main=()
        branches_info_first_main=()
    fi
    for index in "${!branches[@]}"
    do
        branch_to_check="${branches[index]}"
        if [[ "$1" == "delete" ]]; then
            if [[ "$branch_to_check" == "${current_branch}"* ]] || [[ "$branch_to_check" == "${main_branch}"* ]]; then
                continue    
            fi
        fi
        if [[ "$1" == "merge" ]]; then
            if [[ "$branch_to_check" == "${current_branch}"* ]]; then
                continue
            fi
        fi
        if [[ "$1" == "remote" ]]; then
            branch_to_check="$(sed "s/remotes\///g" <<< ${branch_to_check})"
            branch_to_check="$(sed "s/${origin_name}\///g" <<< ${branch_to_check})"
        fi
        if [[ "$branch_to_check" == "${main_branch}"* ]]; then
            branches_info_first_main[0]="${branches_info[index]}"
        elif [[ "$branch_to_check" != "HEAD->"* ]] && [[ "$branch_to_check" != "$origin_name" ]]; then 
            branches_first_main+=(${branches[index]})
            branches_info_first_main+=("${branches_info[index]}")
        fi
    done
    if [[ "${branches_info_first_main[0]}" == "dummy" ]]; then
        branches_info_first_main=("${branches_info_first_main[@]:1}")
        branches_first_main=("${branches_first_main[@]:1}")
    fi
    for index in "${!branches_info_first_main[@]}"
    do
        branch=$(escape "${branches_first_main[index]}" "/")
        if [[ "$1" == "remote" ]] && [[ "$branch" != "origin"* ]]; then
            branch="$origin_name\/$branch"
        fi
        branch_line="${branches_info_first_main[index]}"
        if [ "${branches_first_main[index]}" == "$current_branch" ]; then
            echo -e "$(($index+1)). * $branch_line"
        else
            echo -e "$(($index+1)).   $branch_line"
        fi
    done
}
function choose_branch {
    list_branches $1
    if [ -n "$to_exit" ]; then
        exit
    fi
    echo
    printf "Enter branch number: "
    choose "${branches_first_main[@]}"
    branch_name=$choice_result
    if [[ "$1" == "remote" ]]; then
        branch_name=$(sed "s/remotes\///g" <<< ${branch_name})
        branch_name=$(sed "s/${origin_name}\///g" <<< ${branch_name})
    fi
    echo
}
function switch {
    if ! git show-ref --verify --quiet refs/heads/$1; then
        if git show-ref --verify --quiet refs/remotes/${origin_name}/$1; then
            switch_output=$(git switch -c $1 ${origin_name}/$1 2>&1)
            switch_code=$?
        else
            switch_output=$(git switch $1 2>&1)
            switch_code=$?
        fi
    else
        switch_output=$(git switch $1 2>&1)
        switch_code=$?
    fi
    if [ "$switch_code" == 0 ]; then
        if [ "$current_branch" == "$1" ]; then
            echo -e "${GREEN}Already on '$1'${ENDCOLOR}"
        else
            echo -e "${GREEN}Switched to branch '$1'${ENDCOLOR}"
            changes=$(git_status)
            if [ -n "$changes" ] && [ -z $2 ]; then
                echo
                echo -e "${YELLOW}Moved changes:${ENDCOLOR}"
                echo -e "$changes"
            fi
        fi
        if [ -z $2 ]; then
            get_push_list $1 ${main_branch} ${origin_name}
            if [ -n "$push_list" ]; then
                echo
                count=$(echo -e "$push_list" | wc -l | sed 's/^ *//;s/ *$//')
                echo -e "Your branch ${YELLOW}$1${ENDCOLOR} is ahead ${YELLOW}${history_from}${ENDCOLOR} by ${BOLD}$count${ENDCOLOR} commits"
                echo -e "$push_list"
            fi
        fi
        return
    fi
    if [[ $switch_output == *"Your local changes to the following files would be overwritten"* ]]; then
        conflicts="$(echo "$switch_output" | tail -r | tail -n +3 | tail -r | tail -n +2)"
        echo -e "${RED}Changes would be overwritten by switch to '$1':${ENDCOLOR}"       
        echo -e "${conflicts//[[:blank:]]/}"
        echo
        echo -e "${YELLOW}Commit these files and try to switch for one more time${ENDCOLOR}"
        exit
    fi
    if [ $switch_code -ne 0 ]; then
        echo -e "${RED}Cannot switch to '$1'! Error message:${ENDCOLOR}"
        echo -e "$switch_output"
        exit $switch_code
    fi
}
readonly GOOGLE_API_URL="https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent"
function get_ai_api_key {
    get_config_value gitbasher.ai-api-key ""
}
function set_ai_api_key {
    set_config_value gitbasher.ai-api-key "$1"
}
function get_ai_proxy {
    get_config_value gitbasher.ai-proxy ""
}
function set_ai_proxy {
    set_config_value gitbasher.ai-proxy "$1"
}
function get_ai_diff_limit {
    get_config_value gitbasher.ai-diff-limit "50"
}
function set_ai_diff_limit {
    set_config_value gitbasher.ai-diff-limit "$1"
}
function get_ai_commit_history_limit {
    get_config_value gitbasher.ai-commit-history-limit "10"
}
function set_ai_commit_history_limit {
    set_config_value gitbasher.ai-commit-history-limit "$1"
}
function mask_api_key {
    local api_key="$1"
    if [ -z "$api_key" ]; then
        echo ""
        return
    fi
    local length=${#api_key}
    if [ $length -le 4 ]; then
        echo "$api_key"
        return
    fi
    local visible_chars="${api_key:(-4)}"
    echo "********${visible_chars}"
}
function get_limited_diff_for_ai {
    local diff_limit=$(get_ai_diff_limit)
    local max_chars=3000  # Approximate token limit (~750 tokens)
    local diff_content=$(git diff --cached | head -n "$diff_limit")
    local char_count=${#diff_content}
    if [ "$char_count" -gt "$max_chars" ]; then
        diff_content=$(echo "$diff_content" | head -c "$max_chars")
        diff_content="${diff_content}... [truncated for token limit]"
    fi
    echo "$diff_content"
}
function get_recent_commit_messages_for_ai {
    local limit=$(get_ai_commit_history_limit)  # Use configurable limit
    local max_chars=1000  # Character limit to save tokens
    local recent_commits=$(git log --no-merges --pretty=format:"%s" -n "$limit" 2>/dev/null | head -c "$max_chars")
    if [ -z "$recent_commits" ]; then
        echo "No commit history available."
        return
    fi
    echo "$recent_commits"
}
function validate_proxy_url {
    local proxy_url="$1"
    validated_proxy_url=""
    if [ -z "$proxy_url" ]; then
        return 1
    fi
    local cleaned_url=$(echo "$proxy_url" | sed 's/[^a-zA-Z0-9.:/@_%?&=-]//g')
    if [[ "$cleaned_url" =~ ^(https?|socks5)://([a-zA-Z0-9._%-]+(:([a-zA-Z0-9._%-]+))?@)?[a-zA-Z0-9.-]+:[0-9]+(/.*)?$ ]]; then
        validated_proxy_url="$cleaned_url"
        return 0
    elif [[ "$cleaned_url" =~ ^[a-zA-Z0-9.-]+:[0-9]+$ ]]; then
        validated_proxy_url="$cleaned_url"
        return 0
    else
        return 1
    fi
}
function secure_curl_with_api_key {
    local proxy_url="$1"
    local api_key="$2"
    local json_payload="$3"
    (
        unset HISTFILE
        local curl_cmd=(
            curl -s -X POST
            --connect-timeout 30
            --max-time 60
        )
        if [ -n "$proxy_url" ]; then
            curl_cmd+=(--proxy "$proxy_url")
        fi
        curl_cmd+=(
            "$GOOGLE_API_URL"
            -H "Content-Type: application/json"
            -H "x-goog-api-key: $api_key"
            -d "$json_payload"
        )
        "${curl_cmd[@]}" 2>&1
    )
}
function call_gemini_api {
    trap 'clear_sensitive_vars' EXIT INT TERM
    local prompt="$1"
    local api_key=$(get_ai_api_key)
    if [ -z "$api_key" ]; then
        echo -e "${RED}AI API key not configured. Set it with: gitb config${ENDCOLOR}" >&2
        clear_sensitive_vars
        return 1
    fi
    local escaped_prompt=$(echo "$prompt" | sed 's/\\/\\\\/g' | sed 's/"/\\"/g' | tr '\n' ' ' | sed 's/  */ /g')
    local json_payload="{
        \"contents\": [{
            \"parts\": [{
                \"text\": \"$escaped_prompt\"
            }]
        }],
        \"generationConfig\": {
            \"temperature\": 0.1,
            \"maxOutputTokens\": 100,
            \"topP\": 0.8,
            \"topK\": 10
        }
    }"
    local proxy_url=$(get_ai_proxy)
    local safe_proxy_url=""
    local response=""
    if [ -n "$proxy_url" ]; then
        if ! validate_proxy_url "$proxy_url"; then
            echo -e "${RED}Invalid proxy URL format: $proxy_url${ENDCOLOR}" >&2
            echo -e "${YELLOW}Expected format: protocol://host:port (e.g., http://proxy.example.com:8080)${ENDCOLOR}" >&2
            echo -e "${YELLOW}Or: host:port (e.g., proxy.example.com:8080)${ENDCOLOR}" >&2
            clear_sensitive_vars
            return 1
        fi
        safe_proxy_url="$validated_proxy_url"
        response=$(secure_curl_with_api_key "$safe_proxy_url" "$api_key" "$json_payload")
    else
        response=$(secure_curl_with_api_key "" "$api_key" "$json_payload")
    fi
    local curl_exit_code=$?
    if [ $curl_exit_code -ne 0 ] || [ -z "$response" ]; then
        echo
        echo -e "${RED}Failed to connect to AI service${ENDCOLOR}" >&2
        echo -e "${YELLOW}Debug Information:${ENDCOLOR}" >&2
        echo -e "  • Curl exit code: $curl_exit_code" >&2
        echo -e "  • Response length: ${#response}" >&2
        if [ -n "$safe_proxy_url" ]; then
            echo -e "  • Using proxy: $safe_proxy_url" >&2
            echo -e "${YELLOW}Proxy troubleshooting:${ENDCOLOR}" >&2
            echo -e "  • Test proxy: ${BOLD}curl --proxy '$safe_proxy_url' --connect-timeout 10 https://ifconfig.me${ENDCOLOR}" >&2
            echo -e "  • Test direct: ${BOLD}curl --connect-timeout 10 https://ifconfig.me${ENDCOLOR}" >&2
            echo -e "  • Configure different proxy: gitb cfg proxy" >&2
            echo -e "${YELLOW}Testing proxy connectivity...${ENDCOLOR}" >&2
            local proxy_test=$(curl --proxy "$safe_proxy_url" --connect-timeout 5 --max-time 10 -s https://ifconfig.me 2>&1)
            local proxy_test_code=$?
            if [ $proxy_test_code -eq 0 ]; then
                echo -e "  ✅ Proxy connection: Working" >&2
                echo -e "  📍 Your IP via proxy: $(echo "$proxy_test" | head -1)" >&2
            else
                echo -e "  ❌ Proxy connection: Failed (exit code: $proxy_test_code)" >&2
                echo -e "  📝 Error: $proxy_test" >&2
            fi
        else
            echo -e "  • No proxy configured" >&2
            echo -e "${YELLOW}Direct connection troubleshooting:${ENDCOLOR}" >&2
            echo -e "  • Test connection: ${BOLD}curl --connect-timeout 10 https://generativelanguage.googleapis.com${ENDCOLOR}" >&2
            echo -e "${YELLOW}Testing direct connectivity to Google AI...${ENDCOLOR}" >&2
            local direct_test=$(curl --connect-timeout 5 --max-time 10 -s -I https://generativelanguage.googleapis.com 2>&1)
            local direct_test_code=$?
            if [ $direct_test_code -eq 0 ]; then
                echo -e "  ✅ Google AI endpoint: Reachable" >&2
            else
                echo -e "  ❌ Google AI endpoint: Failed (exit code: $direct_test_code)" >&2
                echo -e "  📝 Error: $(echo "$direct_test" | head -1)" >&2
                echo -e "  💡 Consider configuring a proxy: gitb cfg proxy" >&2
            fi
        fi
        if [ -n "$response" ]; then
            echo -e "${YELLOW}Partial response received:${ENDCOLOR}" >&2
            echo "$response" | head -3 >&2
            echo -e "${YELLOW}...${ENDCOLOR}" >&2
        fi
        clear_sensitive_vars
        return 1
    fi
    local has_error=$(echo "$response" | grep -q '"error"' && echo "true" || echo "false")
    if [ "$has_error" = "true" ]; then
        local error_code=$(echo "$response" | grep -o '"code"[[:space:]]*:[[:space:]]*[0-9]*' | grep -o '[0-9]*')
        local error_message=$(echo "$response" | grep -o '"message"[[:space:]]*:[[:space:]]*"[^"]*"' | sed 's/"message"[[:space:]]*:[[:space:]]*"\([^"]*\)"/\1/')
        echo -e "${RED}AI API Error${ENDCOLOR}" >&2
        if [ -n "$error_code" ]; then
            echo -e "${RED}Error Code: $error_code${ENDCOLOR}" >&2
        fi
        if [ -n "$error_message" ]; then
            echo -e "${RED}Error Message: $error_message${ENDCOLOR}" >&2
        fi
        echo >&2
        case "$error_code" in
            400)
                if [[ "$error_message" == *"location is not supported"* ]]; then
                    echo -e "${YELLOW}⚠️  Geographic restriction: Google's Gemini API is not available in your region.${ENDCOLOR}" >&2
                    echo -e "${YELLOW}Solutions:${ENDCOLOR}" >&2
                    echo -e "${YELLOW}  • Configure proxy with: gitb cfg proxy${ENDCOLOR}" >&2
                    echo -e "${YELLOW}  • Use a VPN to connect from a supported region${ENDCOLOR}" >&2
                    echo -e "${YELLOW}  • Use manual commit messages for now${ENDCOLOR}" >&2
                else
                    echo -e "${YELLOW}⚠️  Bad request: Check your API configuration or prompt format.${ENDCOLOR}" >&2
                    echo -e "${YELLOW}Solutions:${ENDCOLOR}" >&2
                    echo -e "${YELLOW}  • Verify your API key is correct${ENDCOLOR}" >&2
                    echo -e "${YELLOW}  • Try again with a smaller commit diff${ENDCOLOR}" >&2
                fi
                ;;
            401|403)
                echo -e "${YELLOW}🔐 Authentication error: Invalid or expired API key.${ENDCOLOR}" >&2
                echo -e "${YELLOW}Solutions:${ENDCOLOR}" >&2
                echo -e "${YELLOW}  • Check your API key with: gitb cfg ai${ENDCOLOR}" >&2
                echo -e "${YELLOW}  • Generate a new API key at: https://makersuite.google.com/app/apikey${ENDCOLOR}" >&2
                echo -e "${YELLOW}  • Ensure your API key has proper permissions${ENDCOLOR}" >&2
                ;;
            429)
                echo -e "${YELLOW}⏱️  Rate limit exceeded: Too many requests.${ENDCOLOR}" >&2
                echo -e "${YELLOW}Solutions:${ENDCOLOR}" >&2
                echo -e "${YELLOW}  • Wait a few minutes and try again${ENDCOLOR}" >&2
                echo -e "${YELLOW}  • Consider upgrading your API plan for higher limits${ENDCOLOR}" >&2
                ;;
            500|502)
                echo -e "${YELLOW}🔧 Server error: Google's service is experiencing issues.${ENDCOLOR}" >&2
                echo -e "${YELLOW}Solutions:${ENDCOLOR}" >&2
                echo -e "${YELLOW}  • Try again in a few minutes${ENDCOLOR}" >&2
                echo -e "${YELLOW}  • Check Google's API status page${ENDCOLOR}" >&2
                ;;
            503)
                echo -e "${YELLOW}📊 Service overloaded: Google's servers are busy.${ENDCOLOR}" >&2
                echo -e "${YELLOW}Solutions:${ENDCOLOR}" >&2
                echo -e "${YELLOW}  • Try again in a few minutes${ENDCOLOR}" >&2
                echo -e "${YELLOW}  • Retry during off-peak hours${ENDCOLOR}" >&2
                ;;
            *)
                if [[ "$error_message" == *"suspended"* ]]; then
                    echo -e "${YELLOW}🚫 Account suspended: Your API access has been suspended.${ENDCOLOR}" >&2
                    echo -e "${YELLOW}Solutions:${ENDCOLOR}" >&2
                    echo -e "${YELLOW}  • Contact Google Support to resolve account issues${ENDCOLOR}" >&2
                    echo -e "${YELLOW}  • Check your Google Cloud Console for notices${ENDCOLOR}" >&2
                elif [[ "$error_message" == *"location is not supported"* ]]; then
                    echo -e "${YELLOW}⚠️  Geographic restriction: Google's Gemini API is not available in your region.${ENDCOLOR}" >&2
                    echo -e "${YELLOW}Solutions:${ENDCOLOR}" >&2
                    echo -e "${YELLOW}  • Configure proxy with: gitb cfg proxy${ENDCOLOR}" >&2
                    echo -e "${YELLOW}  • Use a VPN to connect from a supported region${ENDCOLOR}" >&2
                    echo -e "${YELLOW}  • Use manual commit messages for now${ENDCOLOR}" >&2
                else
                    echo -e "${YELLOW}❓ Unknown error occurred.${ENDCOLOR}" >&2
                    echo -e "${YELLOW}Solutions:${ENDCOLOR}" >&2
                    echo -e "${YELLOW}  • Check Google's API documentation${ENDCOLOR}" >&2
                    echo -e "${YELLOW}  • Try again later${ENDCOLOR}" >&2
                fi
                ;;
        esac
        clear_sensitive_vars
        return 1
    fi
    local ai_response=""
    ai_response=$(echo "$response" | sed -n 's/.*"text"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/p' | head -1)
    if [ -z "$ai_response" ]; then
        ai_response=$(echo "$response" | sed -n 's/.*"candidates".*"text"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/p' | head -1)
    fi
    if [ -z "$ai_response" ]; then
        ai_response=$(echo "$response" | sed -n 's/.*"content".*"parts".*"text"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/p' | head -1)
    fi
    if [ -n "$ai_response" ]; then
        ai_response=$(echo "$ai_response" | sed 's/\\n/\n/g' | sed 's/\\"/"/g' | sed 's/\\\\//g')
    fi
    if [ -z "$ai_response" ]; then
        echo -e "${RED}Failed to parse AI response${ENDCOLOR}" >&2
        echo -e "${YELLOW}Raw API response:${ENDCOLOR}" >&2
        echo "$response" | head -5 >&2
        echo -e "${YELLOW}...${ENDCOLOR}" >&2
        echo -e "${YELLOW}To see full response, enable debug mode in ai.sh${ENDCOLOR}" >&2
        clear_sensitive_vars
        return 1
    fi
    clear_sensitive_vars
    echo "$ai_response"
}
function check_ai_available {
    if ! command -v curl >/dev/null 2>&1; then
        echo -e "${RED}curl is required for AI functionality but not installed${ENDCOLOR}" >&2
        return 1
    fi
    local api_key=$(get_ai_api_key)
    if [ -z "$api_key" ]; then
        echo -e "${RED}AI API key not configured${ENDCOLOR}" >&2
        echo -e "${YELLOW}Configure it with: gitb cfg ai${ENDCOLOR}" >&2
        return 1
    fi
    return 0
}
function generate_ai_commit_message {
    local detected_scopes="$1"
    local staged_files=$(git diff --name-only --cached)
    if [ -z "$staged_files" ]; then
        echo -e "${RED}No staged files found${ENDCOLOR}" >&2
        return 1
    fi
    local diff_content=$(git diff --cached --stat)
    local diff_details=$(get_limited_diff_for_ai)
    local recent_commits=$(get_recent_commit_messages_for_ai)
    local prompt="Analyze the following git changes and generate a conventional commit message in the format 'type(scope): subject'.
Available types:
- feat: new feature, logic change or performance improvement
- fix: small changes, bug fix, fnixes of features
- refactor: code change that neither fixes a bug nor adds a feature, style changes, NO NEW BEAVIOUR
- test: adding missing tests or changing existing tests
- build: changes that affect the build system or external dependencies
- ci: changes to CI configuration files and scripts
- chore: maintenance and housekeeping
- docs: documentation changes
Recent commit messages from this repository (for style reference):
$recent_commits
Staged files:
$staged_files
File changes summary:
$diff_content"
    if [ -n "$detected_scopes" ]; then
        prompt="$prompt
Detected scopes from file paths (use one of these if relevant):
$detected_scopes"
    fi
    prompt="$prompt
Code changes (partial):
$diff_details
Generate ONLY the commit message in the format 'type(scope): subject'. The subject should:
- Explain the idea of the change in details
- Be short, it should not be more that 100 characters
- Be specific, don't be very general, so do NOT write 'improve existing feature' or 'fix bug'
- Be lowercase and not end with a period
- Follow the style and patterns from the recent commits shown above
If you can determine a meaningful scope from the file paths and LOGIC OF UPDATES, include it. If detected scopes are provided above, prefer using one of them. Otherwise, omit the scope.
Write ONLY the commit header in the format 'type(scope): subject', do not write body or footer after a new line!
Respond with only the commit message, nothing else."
    call_gemini_api "$prompt"
}
function generate_ai_commit_message_subject {
    local commit_prefix="$1"
    local detected_scopes="$2"
    local staged_files=$(git diff --name-only --cached)
    if [ -z "$staged_files" ]; then
        echo -e "${RED}No staged files found${ENDCOLOR}" >&2
        return 1
    fi
    local diff_content=$(git diff --cached --stat)
    local diff_details=$(get_limited_diff_for_ai)
    local recent_commits=$(get_recent_commit_messages_for_ai)
    local prompt="Analyze the following git changes and generate a conventional commit message that will be appended to $commit_prefix.
Recent commit messages from this repository (for style reference):
$recent_commits
Staged files:
$staged_files
File changes summary:
$diff_content
Code changes (partial):
$diff_details
Generate ONLY the commit message. The message should:
- Explain the idea of the change in details
- Be short, it should not be more that 100 characters with prefix
- Be specific, don't be very general, so do NOT write 'improve existing feature' or 'fix bug'
- Be lowercase and not end with a period
- Follow the style and patterns from the recent commits shown above
Write ONLY the commit message, do not write body or footer.
Respond with only the commit message without any other text, nothing else."
    call_gemini_api "$prompt"
}
function generate_ai_commit_message_full {
    local detected_scopes="$1"
    local staged_files=$(git diff --name-only --cached)
    if [ -z "$staged_files" ]; then
        echo -e "${RED}No staged files found${ENDCOLOR}" >&2
        return 1
    fi
    local diff_content=$(git diff --cached --stat)
    local diff_details=$(get_limited_diff_for_ai)
    local recent_commits=$(get_recent_commit_messages_for_ai)
    local prompt="Analyze the following git changes and generate a conventional commit message in the format 'type(scope): subject' with body.
Write a body for the commit message, where you can explain why you are making the change. The length of the body should be 1-2 sentences, not more.
Available types:
- feat: new feature, logic change or performance improvement
- fix: small changes, bug fix, fixes of features
- refactor: code change that neither fixes a bug nor adds a feature, style changes, NO NEW BEAVIOUR
- test: adding missing tests or changing existing tests
- build: changes that affect the build system or external dependencies
- ci: changes to CI configuration files and scripts
- chore: maintenance and housekeeping
- docs: documentation changes
Recent commit messages from this repository (for style reference):
$recent_commits
Staged files:
$staged_files
File changes summary:
$diff_content"
    if [ -n "$detected_scopes" ]; then
        prompt="$prompt
Detected scopes from file paths (use one of these if relevant):
$detected_scopes"
    fi
    prompt="$prompt
Code changes (partial):
$diff_details
Generate ONLY the commit message in the format 'type(scope): subject' with body. The subject should:
- Explain the idea of the change in details
- Be short, it should not be more that 100 characters in title and 1-2 sentences in body
- Be specific, don't be very general, so do NOT write 'improve existing feature' or 'fix bug'
- Be lowercase and not end with a period
- Follow the style and patterns from the recent commits shown above
If you can determine a meaningful scope from the file paths and LOGIC OF UPDATES, include it. If detected scopes are provided above, prefer using one of them. Otherwise, omit the scope.
The body should explain why you are making the change. The length of the body should be 1-2 sentences, not more.
Respond with only the full commit message, nothing else."
    call_gemini_api "$prompt"
}
function clear_sensitive_vars {
    api_key=""
    ai_key_input=""
    validated_proxy_url=""
    unset api_key 2>/dev/null
    unset ai_key_input 2>/dev/null
    unset AI_API_KEY 2>/dev/null
    unset GEMINI_API_KEY 2>/dev/null
    if [ -n "$BASH_VERSION" ]; then
        hash -r 2>/dev/null
    fi
}
function set_default_branch {
    echo -e "${YELLOW}Fetching remote branches...${ENDCOLOR}"
    echo
    fetch_output=$(git fetch 2>&1)
    check_code $? "$fetch_output" "fetch remote"
    prune_output=$(git remote prune $origin_name 2>&1)
    echo -e "Current gitbasher default branch: ${YELLOW}$main_branch${ENDCOLOR}"
    echo
    echo -e "${YELLOW}Select a branch to make it default in gitbasher${ENDCOLOR}"
    choose_branch "remote"
    echo 
    main_branch=$(set_config_value gitbasher.branch $branch_name)
    echo -e "${GREEN}Set '${branch_name}' as a default gitbasher branch in '${project_name}' repo${ENDCOLOR}"
    echo
    echo -e "Do you want to set it ${YELLOW}globally${ENDCOLOR} for all projects (y/n)?"
    yes_no_choice "\nSet '${branch_name}' globally" "true"
    main_branch=$(set_config_value gitbasher.branch $branch_name "true")
}
function set_sep {
    echo -e "${YELLOW}Select a branch name separator${ENDCOLOR}"
    echo
    echo -e "Separator is a symbol between type and name, e.g. ${YELLOW}name${sep}name${ENDCOLOR}"
    echo -e "Current separator: ${YELLOW}$sep${ENDCOLOR}"
    echo -e "1. type${YELLOW}/${ENDCOLOR}name"
    echo -e "2. type${YELLOW}_${ENDCOLOR}name"
    echo -e "3. type${YELLOW}-${ENDCOLOR}name"
    echo -e "4. type${YELLOW}.${ENDCOLOR}name"
    echo -e "5. type${YELLOW},${ENDCOLOR}name"
    echo -e "6. type${YELLOW}+${ENDCOLOR}name"
    echo -e "7. type${YELLOW}=${ENDCOLOR}name"
    echo -e "8. type${YELLOW}@${ENDCOLOR}name"
    echo "0. Exit without changes"
    declare -A seps=(
            [1]="/"
            [2]="_"
            [3]="-"
            [4]="."
            [5]=","
            [6]="+"
            [7]="="
            [8]="@"
        )
    while [ true ]; do
        read -n 1 -s choice
        if [ "$choice" == "0" ]; then
            exit
        fi
        re='^[0-9]+$'
        if ! [[ $choice =~ $re ]]; then
            continue
        fi
        new_sep="${seps[$choice]}"
        if [ -n "$new_sep" ]; then
            break
        fi
    done
    echo
    sep=$(set_config_value gitbasher.sep $new_sep)
    echo -e "${GREEN}Set '${sep}' as a branch name separator in '${project_name}' repo${ENDCOLOR}"
    echo
    echo -e "Do you want to set it ${YELLOW}globally${ENDCOLOR} for all projects (y/n)?"
    yes_no_choice "\nSet '${sep}' globally" "true"
    sep=$(set_config_value gitbasher.sep "$new_sep" "true")
}
function set_editor {
    echo -e "${YELLOW}Enter an editor for commit messages${ENDCOLOR}"
    echo
    echo -e "Enter the bin name of editor to run for creating commit messages (e.g. 'vi' or 'nano')"
    echo -e "It will override ${YELLOW}core.editor${ENDCOLOR} git config value, press Enter if you want to exit"
    echo -e "Current editor: ${YELLOW}${editor}${ENDCOLOR}"
    read -p "Editor: " choice
    if [ "$choice" == "" ]; then
        exit
    fi
    if ! sanitize_command "$choice"; then
        show_sanitization_error "editor" "Use only letters, numbers, dots, dashes, underscores, and slashes."
        exit 1
    fi
    choice="$sanitized_command"
    echo
    which_output=$(which "$choice")
    if [[ "${which_output}" == *"not found"* ]] || [[ "${which_output}" == "" ]]; then
        echo -e "${RED}Binary '${choice}' not found!${ENDCOLOR}"
        exit
    fi
    editor=$(set_config_value core.editor $choice)
    echo -e "${GREEN}Use editor '$editor' located at '$which_output'${ENDCOLOR}"
    echo
    echo -e "Do you want to set it ${YELLOW}globally${ENDCOLOR} for all projects (y/n)?"
    yes_no_choice "\nSet '${editor}' globally" "true"
    editor=$(set_config_value core.editor "$choice" "true")
}
function set_ticket {
    echo -e "${YELLOW}Enter a ticket prefix${ENDCOLOR}"
    echo
    if [ -z $ticket_name ]; then
        echo -e "${YELLOW}Ticket prefix is not set in gitbasher${ENDCOLOR}"
    else
        echo -e "Current ticket prefix: ${YELLOW}$ticket_name${ENDCOLOR}"
        echo -e "Press Enter to exit without changes or enter 0 to remove existing ticket prefix"
    fi
    read -p "Ticket prefix: " -e ticket_name
    if [ "$ticket_name" == "0" ]; then
        unset_config_value gitbasher.ticket
        echo
        echo -e "${GREEN}Ticket prefix removed from '${project_name}' repo${ENDCOLOR}"
        exit
    fi
    if [ -z $ticket_name ]; then
        exit
    fi
    if ! sanitize_text_input "$ticket_name" 50; then
        show_sanitization_error "ticket prefix" "Use printable characters only, max 50 characters."
        exit 1
    fi
    ticket_name="$sanitized_text"
    echo 
    ticket_name=$(set_config_value gitbasher.ticket $ticket_name)
    echo -e "${GREEN}Set '${ticket_name}' as a ticket name in '${project_name}' repo${ENDCOLOR}"
    echo
    echo -e "Do you want to set it ${YELLOW}globally${ENDCOLOR} for all projects (y/n)?"
    yes_no_choice "\nSet '${ticket_name}' globally" "true"
    ticket_name=$(set_config_value gitbasher.ticket $ticket_name "true")
}
function configure_ai_key {
    echo -e "${YELLOW}Enter AI API key${ENDCOLOR}"
    echo
    ai_api_key=$(get_ai_api_key)
    if [ -z "$ai_api_key" ]; then
        echo -e "${YELLOW}AI API key is not set${ENDCOLOR}"
    else
        echo -e "AI API key is ${GREEN}configured${ENDCOLOR}: ${BLUE}$(mask_api_key "$ai_api_key")${ENDCOLOR}"
    fi
    echo -e "Enter your ${YELLOW}Gemini API key${ENDCOLOR} to enable AI commit message generation"
    echo -e "Get your API key from: ${BLUE}https://aistudio.google.com/app/apikey${ENDCOLOR}"
    echo -e "Press Enter to exit without changes or enter 0 to remove existing key"
    echo
    echo -e "${YELLOW}API key enters silently, so you can't see it, but it is entered${ENDCOLOR}"
    read -p "API Key: " -s ai_key_input
    echo
    if [ "$ai_key_input" == "" ]; then
        exit
    fi
    if [ "$ai_key_input" == "0" ]; then
        unset_config_value gitbasher.ai-api-key
        echo
        echo -e "${GREEN}AI API key removed from '${project_name}' repo${ENDCOLOR}"
        exit
    fi
    echo
    if [[ ! "$ai_key_input" =~ ^AIza[A-Za-z0-9_-]{35}$ ]]; then
        echo -e "${RED}Warning: API key format doesn't match expected Gemini format${ENDCOLOR}"
        read -n 1 -p "Continue anyway? (y/n) " -s choice
        echo
        if [ "$choice" != "y" ] && [ "$choice" != "Y" ]; then
            exit
        fi
    fi
    ai_api_key=$(set_config_value gitbasher.ai-api-key "$ai_key_input")
    echo -e "${GREEN}AI API key configured for '${project_name}' repo${ENDCOLOR}: ${BLUE}$(mask_api_key "$ai_api_key")${ENDCOLOR}"
    echo
    echo -e "Do you want to set it ${YELLOW}globally${ENDCOLOR} for all projects (y/n)?"
    yes_no_choice "\nSet AI API key globally" "true"
    ai_api_key=$(set_config_value gitbasher.ai-api-key "$ai_key_input" "true")
}
function configure_ai_proxy {    
    echo -e "${YELLOW}Configure AI HTTP/SOCKS Proxy${ENDCOLOR}"
    echo
    ai_proxy=$(get_ai_proxy)
    if [ -z "$ai_proxy" ]; then
        echo -e "${YELLOW}AI proxy is not configured${ENDCOLOR}"
    else
        echo -e "Current AI proxy: ${GREEN}$ai_proxy${ENDCOLOR}"
    fi
    echo -e "Enter proxy URL to route AI requests through (useful for bypassing geo-restrictions)"
    echo -e ""
    echo -e "${BLUE}HTTP proxy formats:${ENDCOLOR}"
    echo -e "  • ${BLUE}http://proxy.example.com:8080${ENDCOLOR}"
    echo -e "  • ${BLUE}http://username:password@proxy.example.com:8080${ENDCOLOR}"
    echo -e "  • ${BLUE}http://[2001:db8::1]:8080${ENDCOLOR} (IPv6)"
    echo -e ""
    echo -e "Press Enter to exit without changes or enter 0 to remove existing proxy"
    read -p "Proxy URL: " ai_proxy_input
    if [ "$ai_proxy_input" == "" ]; then
        exit
    fi
    if [ "$ai_proxy_input" == "0" ]; then
        unset_config_value gitbasher.ai-proxy
        echo
        echo -e "${GREEN}AI proxy removed from '${project_name}' repo${ENDCOLOR}"
        exit
    fi
    echo
    if ! validate_proxy_url "$ai_proxy_input"; then
        echo -e "${RED}Invalid proxy URL format: $ai_proxy_input${ENDCOLOR}"
        echo -e "${YELLOW}Expected format: protocol://host:port (e.g., http://proxy.example.com:8080)${ENDCOLOR}"
        echo -e "${YELLOW}Or: host:port (e.g., proxy.example.com:8080)${ENDCOLOR}"
        echo -e "${YELLOW}Supported protocols: http, https, socks5${ENDCOLOR}"
        exit 1
    fi
    ai_proxy_input="$validated_proxy_url"
    set_ai_proxy "$ai_proxy_input"
    echo -e "${GREEN}AI proxy configured for '${project_name}' repo${ENDCOLOR}: ${BLUE}$ai_proxy_input${ENDCOLOR}"
    echo
    echo -e "${YELLOW}Example usage:${ENDCOLOR}"
    echo -e "  ${BLUE}gitb commit ai${ENDCOLOR}    - Generate commit with AI through proxy"
    echo -e "  ${BLUE}gitb commit aif${ENDCOLOR}   - Fast AI commit through proxy"
    echo
    echo -e "Do you want to set it ${YELLOW}globally${ENDCOLOR} for all projects (y/n)?"
    yes_no_choice "\nSet AI proxy globally" "true"
    set_ai_proxy "$ai_proxy_input"
    git config --global gitbasher.ai-proxy "$ai_proxy_input"
}
function configure_ai_history {
    echo -e "${YELLOW}Configure AI Commit History Limit${ENDCOLOR}"
    echo
    current_limit=$(get_ai_commit_history_limit)
    echo -e "Current limit: ${GREEN}$current_limit${ENDCOLOR} recent commits"
    echo
    echo -e "This setting controls how many recent commit messages are included in AI prompts"
    echo -e "to help the AI learn from your commit message patterns and style."
    echo -e ""
    echo -e "Recommended range: ${BLUE}5-15${ENDCOLOR} commits"
    echo -e "• Lower values (5-8): Faster, uses fewer tokens, focuses on recent patterns"
    echo -e "• Higher values (10-15): Better style learning, uses more tokens"
    echo
    echo -e "Press Enter to exit without changes"
    read -p "Number of recent commits to include: " limit_input
    if [ "$limit_input" == "" ]; then
        exit
    fi
    echo
    if ! validate_numeric_input "$limit_input" 1 100; then
        show_sanitization_error "commit history limit" "Please enter a positive number between 1 and 100."
        exit 1
    fi
    limit_input="$validated_number"
    if [ "$limit_input" -lt 5 ] || [ "$limit_input" -gt 20 ]; then
        echo -e "${YELLOW}Warning: Value outside recommended range (5-20)${ENDCOLOR}"
        if [ "$limit_input" -gt 20 ]; then
            echo -e "${YELLOW}High values may exceed token limits and slow down AI responses${ENDCOLOR}"
        fi
        read -n 1 -p "Continue anyway? (y/n) " -s choice
        echo
        if [ "$choice" != "y" ] && [ "$choice" != "Y" ]; then
            exit
        fi
    fi
    set_ai_commit_history_limit "$limit_input"
    echo -e "${GREEN}AI commit history limit set to ${limit_input} for '${project_name}' repo${ENDCOLOR}"
    echo
    echo -e "Do you want to set it ${YELLOW}globally${ENDCOLOR} for all projects (y/n)?"
    yes_no_choice "\nSet AI commit history limit globally" "true"
    git config --global gitbasher.ai-commit-history-limit "$limit_input"
}
function set_scopes {
    echo -e "${YELLOW}Enter a list of predefined scopes${ENDCOLOR}"
    echo
    if [ "$scopes" == "" ]; then
        echo -e "${YELLOW}Scopes list is not set${ENDCOLOR}"
    else
        echo -e "Current list of scopes: ${YELLOW}$scopes${ENDCOLOR}"
    fi
    echo -e "Use only english letters and space as separator, maximum is 9 scopes"
    if [ "$scopes" != "" ]; then
        echo -e "Press Enter to exit without changes or enter 0 to remove existing scopes"
    fi
    read -p "Scopes: " -e scopes_raw
    if [ "$scopes_raw" == "" ]; then
        exit
    fi
    if [ "$scopes_raw" == "0" ]; then
        unset_config_value gitbasher.scopes
        echo
        echo -e "${GREEN}Scopes list removed from '${project_name}' repo${ENDCOLOR}"
        exit
    fi
    echo
    if ! validate_scope_list "$scopes_raw"; then
        show_sanitization_error "scopes" "Use only letters and spaces, maximum 9 scopes (e.g., 'feat docs test')."
        exit 1
    fi
    scopes_raw="$validated_scopes"
    git config --local --replace-all gitbasher.scopes "$scopes_raw"
    scopes="$scopes_raw"
    echo -e "${GREEN}Set '${scopes}' as a scopes list in '${project_name}' repo${ENDCOLOR}"
    echo
    echo -e "Do you want to set it ${YELLOW}globally${ENDCOLOR} for all projects (y/n)?"
    yes_no_choice "\nSet '${scopes}' globally" "true"
    git config --global --replace-all gitbasher.scopes "$scopes_raw"
}
function delete_global {
    echo -e "${YELLOW}Unset global config${ENDCOLOR}"
    echo
    echo -e "Select a cfg to unset from global settings"
    global_default=$(git config --global --get gitbasher.branch)
    if [ "$global_default" != "" ]; then
        echo -e "1. Default branch: ${YELLOW}${global_default}${ENDCOLOR}"
    fi
    global_sep=$(git config --global --get gitbasher.sep)
    if [ "$global_sep" != "" ]; then
        echo -e "2. Branch separator: ${YELLOW}${global_sep}${ENDCOLOR}"
    fi
    global_editor=$(git config --global --get core.editor)
    if [ "$global_editor" != "" ]; then
        echo -e "3. Commit message editor: ${YELLOW}${global_editor}${ENDCOLOR}"
    fi
    global_ticket=$(git config --global --get gitbasher.ticket)
    if [ "$global_ticket" != "" ]; then
        echo -e "4. Ticket prefix: ${YELLOW}${global_ticket}${ENDCOLOR}"
    fi
    global_scopes=$(git config --global --get gitbasher.scopes)
    if [ "$global_scopes" != "" ]; then
        echo -e "5. Scopes list: ${YELLOW}${global_scopes}${ENDCOLOR}"
    fi
    global_ai_key=$(git config --global --get gitbasher.ai-api-key)
    if [ "$global_ai_key" != "" ]; then
        echo -e "6. AI API key: ${GREEN}configured${ENDCOLOR}"
    fi
    global_ai_proxy=$(git config --global --get gitbasher.ai-proxy)
    if [ "$global_ai_proxy" != "" ]; then
        echo -e "7. AI proxy: ${GREEN}$global_ai_proxy${ENDCOLOR}"
    fi
    global_ai_history=$(git config --global --get gitbasher.ai-commit-history-limit)
    if [ "$global_ai_history" != "" ]; then
        echo -e "8. AI commit history limit: ${GREEN}$global_ai_history${ENDCOLOR}"
    fi
    echo -e "0. Exit"
    read -n 1 -s choice
    re='^[012345678]+$'
    if ! [[ $choice =~ $re ]]; then
        echo -e "${RED}Invalid choice${ENDCOLOR}"
        return 1
    fi
    if [ "$choice" == "0" ]; then
        exit
    fi
    echo
    case "$choice" in
        1)  
            echo -e "${GREEN}Unset default branch from global settings${ENDCOLOR}"
            git config --global --unset gitbasher.branch
            ;;
        2)
            echo -e "${GREEN}Unset branch separator from global settings${ENDCOLOR}"
            git config --global --unset gitbasher.sep
            ;;
        3)
            echo -e "${GREEN}Unset commit message editor from global settings${ENDCOLOR}"
            git config --global --unset core.editor
            ;;
        4)
            echo -e "${GREEN}Unset ticket prefix from global settings${ENDCOLOR}"
            git config --global --unset gitbasher.ticket
            ;;
        5)
            echo -e "${GREEN}Unset scopes list from global settings${ENDCOLOR}"
            git config --global --unset gitbasher.scopes
            ;;
        6)
            echo -e "${GREEN}Unset AI API key from global settings${ENDCOLOR}"
            git config --global --unset gitbasher.ai-api-key
            ;;
        7)
            echo -e "${GREEN}Unset AI proxy from global settings${ENDCOLOR}"
            git config --global --unset gitbasher.ai-proxy
            ;;
        8)
            echo -e "${GREEN}Unset AI commit history limit from global settings${ENDCOLOR}"
            git config --global --unset gitbasher.ai-commit-history-limit
            ;;
    esac
}
function set_user {
    echo -e "${YELLOW}Set user name and email${ENDCOLOR}"
    echo
    echo -e "Current name: ${YELLOW}$(get_config_value user.name)${ENDCOLOR}"
    echo -e "Enter new name or press Enter if you don't want to change it"
    read -p "Name: " -e user_name
    echo
    echo -e "Current email: ${YELLOW}$(get_config_value user.email)${ENDCOLOR}"
    echo -e "Enter new email or press Enter if you don't want to change it"
    read -p "Email: " -e user_email
    if [ "$user_name" == "" ] && [ "$user_email" == "" ]; then
        exit
    fi
    if [ "$user_name" != "" ]; then
        if ! sanitize_text_input "$user_name" 100; then
            show_sanitization_error "user name" "Use printable characters only, max 100 characters."
            exit 1
        fi
        user_name="$sanitized_text"
    fi
    if [ "$user_email" != "" ]; then
        if ! validate_email "$user_email"; then
            show_sanitization_error "email" "Please enter a valid email address."
            exit 1
        fi
        user_email="$validated_email"
    fi
    echo
    if [ "$user_name" != "" ]; then
        echo -e "${GREEN}Set user name to '${user_name}'${ENDCOLOR}"
        git config --local --replace-all user.name "$user_name"
    fi
    if [ "$user_email" != "" ]; then
        echo -e "${GREEN}Set user email to '${user_email}'${ENDCOLOR}"
        git config --local --replace-all user.email "$user_email"
    fi
}
function config_script {
    case "$1" in
        default|def|d|b|main) set_default_cfg="true";;
        separator|sep)        set_sep_cfg="true";;
        editor|ed|e)          set_editor_cfg="true";;
        ticket|jira|ti|t)     set_ticket_cfg="true";;
        scopes|scope|sc|s)    set_scopes_cfg="true";;
        ai|llm|key)           set_ai_cfg="true";;
        proxy|prx|p)          set_proxy_cfg="true";;
        history|hist)         set_ai_history_cfg="true";;
        delete|unset|del)     delete_cfg="true";;
        user|name|email|u)    set_user_cfg="true";;
        help|h)               help="true";;
        *)                    wrong_mode "config" $1
    esac
    header="GIT CONFIG"
    if [ -n "${set_default_cfg}" ]; then
        header="$header DEFAULT BRANCH"
    elif [ -n "${set_sep_cfg}" ]; then
        header="$header BRANCH SEPARATOR"
    elif [ -n "${set_editor_cfg}" ]; then
        header="$header COMMIT MESSAGE EDITOR"
    elif [ -n "${set_ticket_cfg}" ]; then
        header="$header TICKET PREFIX"
    elif [ -n "${set_scopes_cfg}" ]; then
        header="$header SCOPES LIST"
    elif [ -n "${set_ai_cfg}" ]; then
        header="$header AI API KEY"
    elif [ -n "${set_proxy_cfg}" ]; then
        header="$header AI PROXY"
    elif [ -n "${set_ai_history_cfg}" ]; then
        header="$header AI COMMIT HISTORY"
    elif [ -n "${delete_cfg}" ]; then
        header="$header UNSET GLOBAL CONFIG"
    elif [ -n "${set_user_cfg}" ]; then
        header="$header USER NAME & EMAIL"
    fi
    echo -e "${YELLOW}${header}${ENDCOLOR}"
    echo
    if [ "$set_user_cfg" == "true" ]; then
        set_user
        exit
    fi
    if [ "$set_default_cfg" == "true" ]; then
        set_default_branch
        exit
    fi
    if [ "$set_sep_cfg" == "true" ]; then
        set_sep
        exit
    fi
    if [ "$set_editor_cfg" == "true" ]; then
        set_editor
        exit
    fi
    if [ "$set_ticket_cfg" == "true" ]; then
        set_ticket
        exit
    fi
    if [ "$set_scopes_cfg" == "true" ]; then
        set_scopes
        exit
    fi
    if [ "$set_ai_cfg" == "true" ]; then
        configure_ai_key
        exit
    fi
    if [ "$set_proxy_cfg" == "true" ]; then
        configure_ai_proxy
        exit
    fi
    if [ "$set_ai_history_cfg" == "true" ]; then
        configure_ai_history
        exit
    fi
    if [ "$delete_cfg" == "true" ]; then
        delete_global
        exit
    fi
    if [ -n "$help" ]; then
        echo -e "usage: ${YELLOW}gitb config <mode>${ENDCOLOR}"
        echo
        echo -e "${YELLOW}Available modes for configuration${ENDCOLOR}"
        echo -e "<empty>\t\t\tPrint current gitbasher configuration"
        echo -e "user|name|email|u\tSet user name and email"
        echo -e "default|def|d|b|main\tUpdate gitbasher's default branch (not in remote git repo!)"
        echo -e "separator|sep|s\t\tUpdate separator between type and name in branch"
        echo -e "editor|ed|e\t\tUpdate text editor for the commit messages"
        echo -e "ticket|ti|t|jira\tSet ticket prefix to help with commit/branch building"
        echo -e "scopes|sc|s\t\tSet a list of scopes to help with commit building"
        echo -e "ai|llm|key\t\tSet AI API key for commit message generation"
        echo -e "proxy|prx|p\t\tSet HTTP proxy for AI requests (bypass geo-restrictions)"
        echo -e "history|hist\t\tSet number of recent commits to include in AI prompts"
        echo -e "delete|unset|del\tUnset global configuration"
        exit
    fi
    print_configuration
}
function merge_script {
    case "$1" in
        main|master|m)          main="true";;
        to-main|to-master|tm)   to_main="true";;
        remote|r)               remote="true";;
        help|h)                 help="true";;
        *)
            wrong_mode "merge" $1
    esac
    header="GIT MERGE"
    if [ -n "${main}" ]; then
        header="$header MAIN"
    elif [ -n "${to_main}" ]; then
        header="$header TO MAIN"
    elif [ -n "${remote}" ]; then
        header="$header REMOTE"
    fi
    echo -e "${YELLOW}${header}${ENDCOLOR}"
    echo
    if [ -n "$help" ]; then
        echo -e "usage: ${YELLOW}gitb merge <mode>${ENDCOLOR}"
        echo
        echo -e "${YELLOW}Available modes${ENDCOLOR}"
        echo -e "<empty>\t\t\tSelect a branch to merge into the current one and fix conflicts"
        echo -e "main|master|m\t\tMerge $main_branch to the current branch and fix conflicts"
        echo -e "to-main|to-master|tm\tSwitch to $main_branch and merge the current branch into $main_branch"
        echo -e "remote|r\t\tFetch $origin_name and select a remote branch to merge into current"
        echo -e "help|h\t\t\tShow this help"
        echo
        echo -e "${YELLOW}Conflict resolution options (available during merge conflicts):${ENDCOLOR}"
        echo -e "Accept all incoming changes\tResolve all conflicts by accepting changes from the target branch"
        echo -e "Accept all current changes\tResolve all conflicts by keeping changes from your current branch"
        exit
    fi
    if [ -n "$main" ]; then
        if [ "$current_branch" == "${main_branch}" ]; then
            echo -e "${YELLOW}Already on ${main_branch}${ENDCOLOR}"
            exit
        fi
        merge_branch=${main_branch}
    elif [ -n "$to_main" ]; then
        if [ "$current_branch" == "${main_branch}" ]; then
            echo -e "${YELLOW}Already on ${main_branch}${ENDCOLOR}"
            exit
        fi
        merge_branch=${current_branch}
    elif [ -n "$remote" ]; then
        echo -e "${YELLOW}Fetching remote...${ENDCOLOR}"
        echo
        fetch_output=$(git fetch 2>&1)
        check_code $? "$fetch_output" "fetch remote"
        prune_output=$(git remote prune $origin_name 2>&1)
        echo -e "${YELLOW}Select which remote branch to merge into '${current_branch}'${ENDCOLOR}"
        choose_branch "remote"
        merge_branch=${branch_name}
        merge_from_origin=true
        echo
    else
        echo -e "${YELLOW}Select which branch to merge into '${current_branch}'${ENDCOLOR}"
        choose_branch "merge"
        merge_branch=${branch_name}
        echo
    fi
    if [ -z "$remote" ]; then
        echo -e "Do you want to fetch ${YELLOW}${origin_name}/${merge_branch}${ENDCOLOR} before merge (y/n)?"
        read -n 1 -s choice
        if [ "$choice" == "y" ]; then
            echo
            echo -e "${YELLOW}Fetching ${origin_name}/${merge_branch}...${ENDCOLOR}"
            fetch $merge_branch $origin_name
            merge_from_origin=true
        fi
        echo
    fi
    if [ -n "$to_main" ]; then
        switch $main_branch "true"
        echo
        current_branch=$main_branch
    fi
    commit_message_before_merge="$(git --no-pager log --pretty="%s" -1)"
    merge $merge_branch $origin_name $editor "merge" $merge_from_origin
    if [[ $merge_output == *"Already up to date"* ]]; then
        echo -e "${GREEN}Nothing to merge - already up to date${ENDCOLOR}"
        exit
    fi
    commit_message_after_merge="$(git --no-pager log --pretty="%s" -1)"
    if [[ "$commit_message_after_merge" != "$commit_message_before_merge" ]]; then
        echo -e "${GREEN}Successful merge!${ENDCOLOR} ${BLUE}[$merge_branch${ENDCOLOR} -> ${BLUE}$current_branch]${ENDCOLOR}"
        echo -e "$commit_message_after_merge"
    else
        echo -e "${GREEN}Successful fast-forward merge!${ENDCOLOR} ${BLUE}[$merge_branch${ENDCOLOR} -> ${BLUE}$current_branch]${ENDCOLOR}"
    fi
    changes=$(echo "$merge_output" | tail -n +3)
    if [[ $changes == *"conflict"* ]]; then
        commit_hash="$(git --no-pager log --pretty="%h" -1)"
        changes=$(git --no-pager show $commit_hash --stat --format="")
    fi
    if [ -n "$changes" ]; then
        echo
        print_changes_stat "$changes"
    fi
}
function merge {
    args=""
    if [ "$6" == "true" ]; then
        args="--ff-only"
    fi
    if [ "$5" == "true" ]; then
        merge_output=$(git merge $args $2/$1 2>&1)
    else
        merge_output=$(git merge $args $1 2>&1)
    fi
    merge_code=$?
    if [ $merge_code == 0 ] ; then
        return
    fi
    operation="$4"
    if [ "$operation" == "" ]; then
        operation="merge"
    fi
    if [[ $merge_output == *"Please commit your changes or stash them before you merge"* ]]; then
        echo -e "${RED}Cannot $operation! There are uncommited changes that will be overwritten by $operation${ENDCOLOR}"
        files_to_commit=$(echo "$merge_output" | tail -n +2 | tail -r | tail -n +4 | tail -r)
        echo -e "${YELLOW}Files with changes${ENDCOLOR}"
        echo "$files_to_commit"
        exit $merge_code
    fi
    if [[ $merge_output == *"possible to fast-forward"* ]]; then
        echo -e "${RED}Branches cannot be fast forwarded!${ENDCOLOR}"
        echo -e "You should use merge or rebase"
        exit $merge_code
    fi
    if [[ $merge_output != *"fix conflicts and then commit the result"* ]]; then
        echo -e "${RED}Cannot $operation! Error message:${ENDCOLOR}"
        echo "$merge_output"
        exit $merge_code
    fi
    echo -e "${RED}Cannot $operation! There are conflicts in staged files${ENDCOLOR}"
    resolve_conflicts $1 $2 $3
    merge_code=0
    echo
}
function resolve_conflicts {
    echo
    default_message="Merge branch '$2/$1' into '$current_branch'"
    echo -e "${YELLOW}You should resolve conflicts manually${ENDCOLOR}"
    echo -e "After resolving, select an option to continue"
    echo -e "1. Create a merge commit with a generated message:"
    printf "\t${YELLOW}${default_message}${ENDCOLOR}\n"
    echo -e "2. Create a merge commit with an entered message"
    echo -e "3. Abort merge and return to the original state: ${YELLOW}git merge --abort${ENDCOLOR}"
    echo -e "4. Accept all incoming changes: ${GREEN}git checkout --theirs .${ENDCOLOR}"
    echo -e "5. Accept all current changes: ${GREEN}git checkout --ours .${ENDCOLOR}"
    echo -e "0. Exit from this script ${BOLD}without${NORMAL} merge abort"
    echo
    echo -e "${YELLOW}Files with conflicts${ENDCOLOR}"
    IFS=$'\n' read -rd '' -a files_with_conflicts <<<"$(git --no-pager diff --name-only --diff-filter=U --relative)"
    for file in "${files_with_conflicts[@]}"; do
        echo -e "\t$file"
    done
    while [ true ]; do
        read -n 1 -s choice
        if [ "$choice" == "1" ] || [ "$choice" == "2" ]; then
            merge_commit $choice "${files_with_conflicts[@]}" "${default_message}" $1 $2 $3
            if [ "$merge_error" == "false" ]; then
                return
            fi
        fi
        if [ "$choice" == "3" ]; then
            echo
            echo -e "${YELLOW}Aborting merge...${ENDCOLOR}"
            git merge --abort
            exit $?
        fi
        if [ "$choice" == "4" ]; then
            echo
            echo -e "Are you sure you want to ${GREEN}accept all incoming changes${ENDCOLOR} and discard current changes (y/n)?"
            read -n 1 -s choice_yes
            if [ "$choice_yes" == "y" ]; then
                echo
                echo -e "${YELLOW}Accepting all incoming changes...${ENDCOLOR}"
                checkout_output=$(git checkout --theirs . 2>&1)
                checkout_code=$?
                if [ $checkout_code -ne 0 ]; then
                    echo -e "${RED}Failed to accept incoming changes:${ENDCOLOR}"
                    echo "$checkout_output"
                    continue
                fi
                git add .
                echo -e "${YELLOW}Creating merge commit with accepted incoming changes...${ENDCOLOR}"
                commit_result=$(git commit -m "$default_message" 2>&1)
                commit_code=$?
                if [ $commit_code -eq 0 ]; then
                    echo -e "${GREEN}Successfully accepted all incoming changes and created merge commit!${ENDCOLOR}"
                    return
                else
                    echo -e "${RED}Failed to create merge commit:${ENDCOLOR}"
                    echo "$commit_result"
                    exit $commit_code
                fi
            else
                echo -e "${YELLOW}Continuing...${ENDCOLOR}"
            fi
            continue
        fi
        if [ "$choice" == "5" ]; then
            echo
            echo -e "Are you sure you want to ${GREEN}accept all current changes${ENDCOLOR} and discard incoming changes (y/n)?"
            read -n 1 -s choice_yes
            if [ "$choice_yes" == "y" ]; then
                echo
                echo -e "${YELLOW}Accepting all current changes...${ENDCOLOR}"
                checkout_output=$(git checkout --ours . 2>&1)
                checkout_code=$?
                if [ $checkout_code -ne 0 ]; then
                    echo -e "${RED}Failed to accept current changes:${ENDCOLOR}"
                    echo "$checkout_output"
                    continue
                fi
                git add .
                echo -e "${YELLOW}Creating merge commit with accepted current changes...${ENDCOLOR}"
                commit_result=$(git commit -m "$default_message" 2>&1)
                commit_code=$?
                if [ $commit_code -eq 0 ]; then
                    echo -e "${GREEN}Successfully accepted all current changes and created merge commit!${ENDCOLOR}"
                    return
                else
                    echo -e "${RED}Failed to create merge commit:${ENDCOLOR}"
                    echo "$commit_result"
                    exit $commit_code
                fi
            else
                echo -e "${YELLOW}Continuing...${ENDCOLOR}"
            fi
            continue
        fi
        if [ "$choice" == "0" ]; then
            exit
        fi
    done
}
function merge_commit {
    merge_error="false"
    files_with_conflicts_one_line="$(echo "$2" | tr '\n' ' ' | sed 's/ $//')"
    files_with_conflicts_new="$(git --no-pager grep -l --name-only -E "[<=>]{7} HEAD" $files_with_conflicts_one_line)"
    if [ "$files_with_conflicts_new" != "" ]; then
        echo
        echo -e "${YELLOW}There are files with conflicts${ENDCOLOR}"
        echo -e "$(echo -e "${files_with_conflicts_new}" | tr ' ' '\n' | sed 's/^/\t/')"
        echo
        echo -e "Fix conflicts and press ${YELLOW}$1${ENDCOLOR} for one more time"
        merge_error="true"
        return
    fi
    echo
    echo -e "${YELLOW}Adding resolved files to commit...${ENDCOLOR}"
    git add -u
    if [ "$1" == "1" ]; then
        commit_message="$3"
        result=$(git commit -m "$commit_message" 2>&1)
        commit_status=$?
        if [[ $result != *"not staged for commit"* ]]; then
            check_code $commit_status "$result" "creating default merge commit"
        fi  
    else
        staged_with_tab="$(sed 's/^/####\t/' <<< "$2")"
        commitmsg_file=$(mktemp "/tmp/commitmsg.XXXXXX")
        echo """
####
#### Write a message about merge from '$5/$4' into '$4'. Lines starting with '#' will be ignored. 
#### 
#### On branch $4
#### Changes to be commited:
${staged_with_tab}
""" >> $commitmsg_file
        while [ true ]; do
            $6 $commitmsg_file
            commit_message=$(cat $commitmsg_file | sed '/^#/d')
            if [ -n "$commit_message" ]; then
                break
            fi
            echo
            echo -e "${YELLOW}Merge commit message cannot be empty${ENDCOLOR}"
            echo
            read -n 1 -p "Do you want to try for one more time? (y/n) " -s -e choice
            if [ "$choice" != "y" ]; then
                git restore --staged $files_with_conflicts_one_line
                rm -f "$commitmsg_file"
                merge_error="true"
                exit
            fi    
        done
        rm -f "$commitmsg_file"
        result=$(git commit -m """$commit_message""" 2>&1)
        if [[ $result != *"not staged for commit"* ]]; then
            check_code $? "$result" "creating merge commit"
        fi  
    fi
}
function rebase_script {
    case "$1" in
        main|master|m)           main="true";;
        interactive|i)           interactive="true";;
        autosquash|a|s|ia)        autosquash="true";;
        fastautosquash|fast|sf|f) fastautosquash="true";;
        help|h)                  help="true";;
        *)
            wrong_mode "rebase" $1
    esac
    header="GIT REBASE"
    if [ -n "${interactive}" ]; then
        header="$header INTERACTIVE"
    elif [ -n "${autosquash}" ]; then
        header="$header AUTOSQUASH"
    elif [ -n "${fastautosquash}" ]; then
        header="$header FAST AUTOSQUASH"
    elif [ -n "${main}" ]; then
        header="$header MAIN"
    fi
    echo -e "${YELLOW}${header}${ENDCOLOR}"
    echo
    if [ -n "$help" ]; then
        echo -e "usage: ${YELLOW}gitb rebase <mode>${ENDCOLOR}"
        echo
        echo -e "${YELLOW}Available modes${ENDCOLOR}"
        echo -e "<empty>\t\t\tSelect base branch to rebase current changes"
        echo -e "main|master|m\t\tRebase current branch onto default branch"
        echo -e "interactive|i\t\tSelect base commit in current branch and rebase in an interactive mode"
        echo -e "autosquash|a|s|ia\tRebase on the current local branch in an interactive mode with --autosquash"
        echo -e "fastautosquash|fast|f\tFast autosquash rebase - automatically merge fixup commits without interaction"
        echo -e "help|h\t\t\tShow this help"
        echo
        echo -e "${YELLOW}Conflict resolution options (available during rebase conflicts):${ENDCOLOR}"
        echo -e "Accept all incoming changes\tResolve all conflicts by accepting changes from the target branch"
        echo -e "Accept all current changes\tResolve all conflicts by keeping changes from your current branch"
        exit
    fi
    is_clean=$(git status | tail -n 1)
    if [ "$is_clean" != "nothing to commit, working tree clean" ]; then
        echo -e "${RED}Cannot rebase! There are uncommited changes:"
        git_status
        exit 1
    fi
    if [ -n "$main" ]; then
        if [ "$current_branch" == "${main_branch}" ]; then
            echo -e "${YELLOW}Already on ${main_branch}${ENDCOLOR}"
            exit
        fi
        new_base_branch=${main_branch}
    elif [ -n "$autosquash" ] || [ -n "$fastautosquash" ]; then
        new_base_branch=${current_branch}
    else
        echo -e "${YELLOW}Select which branch will become a new base for '${current_branch}'${ENDCOLOR}"
        choose_branch "rebase"
        new_base_branch=${branch_name}
        echo
    fi
    if [ -z "$autosquash" ] && [ -z "$fastautosquash" ]; then
        echo -e "Fetch ${YELLOW}${origin_name}/${new_base_branch}${ENDCOLOR} before rebase (y/n/0)?"
        read -n 1 -s choice
        if [ "$choice" == "0" ]; then
            exit
        fi
        if [ "$choice" == "y" ]; then
            echo
            echo -e "${YELLOW}Fetching ${origin_name}/${new_base_branch}...${ENDCOLOR}"
            fetch $new_base_branch $origin_name
            from_origin=true
        fi
        echo
    fi
    rebase_branch "$new_base_branch" "$origin_name" "$from_origin" "$interactive" "$autosquash" "$autosquash" "$fastautosquash"
    if [[ $rebase_output == *"is up to date"* ]]; then
        echo -e "${GREEN}Nothing to rebase - already up to date${ENDCOLOR}"
        exit
    fi
    if [ $rebase_code == 0 ] ; then
        echo -e "${GREEN}Successful rebase!${ENDCOLOR}"
        echo -e "${BLUE}[${new_base_branch}${ENDCOLOR} -> ${BLUE}${current_branch}]${ENDCOLOR}"
    else
        echo -e "${RED}Cannot rebase! Error message:${ENDCOLOR}"
        echo -e "$rebase_output"
    fi
}
function rebase_branch {
    ref=$1
    if [ "$3" == "true" ]; then
        ref=$2/$1
    fi
    if [ "$7" == "true" ]; then
        echo -e "${YELLOW}Finding fixup commits to squash automatically...${ENDCOLOR}"
        merge_base=$(git merge-base HEAD ${main_branch} 2>/dev/null)
        if [ -n "$merge_base" ] && [ "$merge_base" != "$(git rev-parse HEAD)" ]; then
            ref="$merge_base"
            echo -e "${YELLOW}Using merge-base with ${main_branch}: ${ref::7}${ENDCOLOR}"
        else
            commit_count=$(git rev-list --count HEAD 2>/dev/null || echo "0")
            if [ "$commit_count" -gt 50 ]; then
                ref="HEAD~50"
                echo -e "${YELLOW}Using HEAD~50 as base commit${ENDCOLOR}"
            else
                ref=$(git rev-list --max-parents=0 HEAD 2>/dev/null | tail -1)
                if [ -n "$ref" ]; then
                    echo -e "${YELLOW}Using root commit: ${ref::7}${ENDCOLOR}"
                else
                    ref="HEAD~10"  # fallback
                    echo -e "${YELLOW}Using HEAD~10 as fallback base commit${ENDCOLOR}"
                fi
            fi
        fi
        fixup_commits=$(git log --oneline --grep="^fixup!" $ref..HEAD 2>/dev/null || echo "")
        if [ -z "$fixup_commits" ]; then
            echo -e "${GREEN}No fixup commits found to squash${ENDCOLOR}"
            rebase_code=0
            rebase_output="No fixup commits to squash"
            return
        fi
        echo -e "${GREEN}Found fixup commits:${ENDCOLOR}"
        fixup_commits_with_dates=$(git log --format="${YELLOW}%h${ENDCOLOR} (${BLUE}%cr${ENDCOLOR}) ${BOLD}%s${ENDCOLOR}" --grep="^fixup!" $ref..HEAD 2>/dev/null || echo "")
        echo -e "$fixup_commits_with_dates" | sed 's/^/\t/'
        echo
        echo -e "Proceed with fast autosquash rebase (y/n/0)?"
        read -n 1 -s choice
        if [ "$choice" == "0" ]; then
            exit
        fi
        if [ "$choice" != "y" ]; then
            echo
            echo -e "${YELLOW}Rebase cancelled${ENDCOLOR}"
            exit
        fi
        echo
        echo -e "${YELLOW}Proceeding with fast autosquash rebase...${ENDCOLOR}"
        echo
        rebase_output=$(GIT_SEQUENCE_EDITOR=true git rebase -i --autosquash $ref 3>&2 2>&1 1>&3)
    elif [ "$5" == "true" ]; then
        if [ "$6" == "true" ]; then
            echo -e "Select a new ${BOLD}base${NORMAL} commit from which to squash fixup commits (third one or older):"
            choose_commit 20 "number" $ref
            ref="$commit_hash"
        fi
        rebase_output=$(git rebase -i --autosquash $ref 3>&2 2>&1 1>&3)
    elif [ "$4" == "true" ]; then
        rebase_output=$(git rebase -i $ref 3>&2 2>&1 1>&3)
    else
        rebase_output=$(git rebase $ref 3>&2 2>&1 1>&3)
    fi
    rebase_code=$?
    if [ $rebase_code == 0 ] ; then
        return
    fi
    if [[ $rebase_output == *"Please commit or stash them"* ]]; then
        echo -e "${RED}Cannot rebase! There are uncommited changes:"
        git_status
        exit $rebase_code
    fi
    if [[ $rebase_output == *"error: invalid"* ]]; then
        rebase_todo_errors "$rebase_output"
        echo
    fi
    if [[ $rebase_output == *"Resolve all conflicts manually"* ]] || [[ $rebase_output == *"previous cherry-pick is now empty"* ]]; then
        echo -e "${RED}Cannot rebase! There are conflicts${ENDCOLOR}"
        rebase_conflicts $rebase_output 
        echo
    fi
    if [[ $rebase_output != *"Successfully rebased"* ]]; then
        echo -e "${RED}Cannot rebase! Error message:${ENDCOLOR}"
        echo "$rebase_output"
        exit $rebase_code
    fi
}
function rebase_todo_errors {
    rebase_output=$1
    output_to_print=$1
    while [ true ]; do
        echo -e "${RED}Cannot rebase! Your rebase plan has errors:${ENDCOLOR}"
        echo "$(sed '$d' <<< $output_to_print)"
        echo
        echo -e "${YELLOW}You should fix errors${ENDCOLOR}"
        echo -e "1. Open editor to change rebase plan: ${BLUE}git rebase --edit-todo${ENDCOLOR}"
        echo -e "2. Abort rebase and return to the original state: ${YELLOW}git rebase --abort${ENDCOLOR}"
        echo -e "0. Exit from this script ${BOLD}without${NORMAL} rebase abort"
        while [ true ]; do
            read -n 1 -s choice
            re='^[012]+$'
            if [[ $choice =~ $re ]]; then
                break
            fi
        done
        if [ "$choice" == "1" ]; then
            todo_output=$(git rebase --edit-todo 3>&2 2>&1 1>&3)
            rebase_output=$(git rebase --continue 2>&1)
            rebase_code=$?
        elif [ "$choice" == "2" ]; then
            echo
            echo -e "${YELLOW}Aborting rebase...${ENDCOLOR}"
            git rebase --abort
            exit
        elif [ "$choice" == "0" ]; then
            exit $rebase_code
        fi
        if [ "$2" != "" ] ; then
            output_to_print=$todo_output
            if [[ $todo_output != *"can fix this with"* ]]; then
                break
            fi
        else
            output_to_print=$rebase_output
            if [[ $rebase_output != *"error: invalid"* ]]; then
                break
            fi
        fi
        echo
    done
}
function rebase_conflicts {
    print_menu="true"
    new_step="true"
    rebase_output=$1
    while [ true ]; do
        if [ "$print_menu" == "true" ]; then
            echo
            echo -e "${YELLOW}You should resolve conflicts manually${ENDCOLOR}"
            echo -e "After resolving, select an option to continue"
            echo -e "1. Add changes and continue: ${YELLOW}git rebase --continue${ENDCOLOR}"
            echo -e "2. Open editor to change rebase plan: ${BLUE}git rebase --edit-todo${ENDCOLOR}"
            echo -e "3. Throw away the commit from the history: ${RED}git rebase --skip${ENDCOLOR}"
            echo -e "4. Abort rebase and return to the original state: ${YELLOW}git rebase --abort${ENDCOLOR}"
            echo -e "5. Accept all incoming changes: ${GREEN}git checkout --theirs .${ENDCOLOR}"
            echo -e "6. Accept all current changes: ${GREEN}git checkout --ours .${ENDCOLOR}"
            echo -e "0. Exit from this script ${BOLD}without${NORMAL} rebase abort"
            print_menu="false"
        fi
        if [ "$new_step" == "true" ]; then
            status=$(git status)
            current_step=$(echo "$status" | sed -n 's/.*Last commands done (\([0-9]*\) commands done):/\1/p')
            if [ "$current_step" == "" ]; then
                current_step=$(echo "$status" | sed -n 's/.*Last command done (\([0-9]*\) command done):/\1/p')
            fi
            remaining_steps=$(echo "$status" | sed -n 's/.*Next commands to do (\([0-9]*\) remaining commands):/\1/p')
            total_steps=$((current_step + remaining_steps))
            commit_name=$(echo "$status" | sed -n '/done):/,/Next command/p' | sed 's/^[ \t]*//;s/[ \t]*$//' | sed '/^[LN(]/d' | tail -n 1 )
            commit_name=$(echo "$commit_name" | sed 's/^[ \t]*//;s/[ \t]*$//' | sed "s/\([a-z]* [0-9a-f]*\)/${BLUE_ES}\[\1\]${ENDCOLOR_ES}/")
            files=$(echo "$status" | sed -n '/^Unmerged paths:/,/^$/p' | sed '/^Unmerged paths:/d;/^$/d;/^ *(/d')
            files=$(sed "s/\(.*\)both modified:/\1${YELLOW_ES}modified:${ENDCOLOR_ES}/" <<< "${files}")
            files=$(sed "s/\(.*\)both added:/\1${YELLOW_ES}added:${ENDCOLOR_ES}/" <<< "${files}")
            echo
            echo -e "${GREEN}Step $current_step/$total_steps:${ENDCOLOR} $commit_name"
            if [ "$files" != "" ]; then
                echo -e "$files"
            else
                echo
                echo -e "${YELLOW}The previous commit is now empty due to conflict resolution${ENDCOLOR}"
                echo -e "${GREEN}You can skip this commit by pressing ${BOLD}3${ENDCOLOR}"
                force_skip="true"
            fi
            new_step="false"
        fi
        while [ true ]; do
            read -n 1 -s choice
            re='^[0123456]+$'
            if [[ $choice =~ $re ]]; then
                break
            fi
        done
        if [ "$choice" == "1" ]; then
            files_with_conflicts_one_line="$(tr '\n' ' ' <<< "$(git --no-pager diff --name-only --diff-filter=U --relative)")"
            if [ -n "$files_with_conflicts_one_line" ] && [ "$files_with_conflicts_one_line" != " " ]; then
                files_with_conflicts_new="$(git grep -l --name-only -E "[<=>]{7}" $files_with_conflicts_one_line 2>/dev/null || echo "")"
                if [ "$files_with_conflicts_new" != "" ]; then
                    echo
                    echo -e "${YELLOW}There are files with conflicts${ENDCOLOR}"
                    echo -e "$(echo -e "${files_with_conflicts_new}" | tr ' ' '\n' | sed 's/^/\t/')"
                    continue
                fi
            fi
            git add .
            rebase_output=$(git -c core.editor=true rebase --continue 2>&1)
            rebase_code=$?
            if [[ $rebase_output == *"Successfully rebased"* ]]; then
                return
            fi
            if [[ $rebase_output != *"CONFLICT"* ]]; then
                echo -e "${RED}Cannot rebase! Error message:${ENDCOLOR}"
                echo "$rebase_output"
                exit $rebase_code
            fi
            new_step="true"
            continue
        fi
        if [ "$choice" == "2" ]; then
            todo_output=$(git rebase --edit-todo 3>&2 2>&1 1>&3)
            rebase_output=$(git rebase --continue 2>&1)
            if [[ $todo_output == *"error: invalid"* ]]; then
                echo
                rebase_todo_errors "$todo_output" "true"
                print_menu="true"
                new_step="true"
            fi
            echo
            echo -e "${YELLOW}Successfull plan edit, continuing...${ENDCOLOR}"
            continue
        fi
        if [ "$choice" == "3" ]; then
            if [ "$force_skip" != "true" ]; then
                echo
                echo -e "Are you sure you want to ${RED}skip${ENDCOLOR} commit and ${RED}throw it away${ENDCOLOR} (y/n)?"
                read -n 1 -s choice_yes
                if [ "$choice_yes" != "y" ]; then
                    echo -e "${YELLOW}Continuing...${ENDCOLOR}"
                    continue
                fi
            fi
            force_skip="false"
            rebase_output=$(git rebase --skip 2>&1)
            rebase_code=$?
            if [[ $rebase_output == *"Successfully rebased"* ]]; then
                echo
                return
            fi
            echo -e "${YELLOW}Skipping commit${ENDCOLOR}"
            new_step="true"
            continue
        fi
        if [ "$choice" == "4" ]; then
            echo
            echo -e "Are you sure you want to ${YELLOW}abort rebase${ENDCOLOR} (y/n)?"
            read -n 1 -s choice_yes
            if [ "$choice_yes" == "y" ]; then
                echo
                echo -e "${YELLOW}Aborting rebase...${ENDCOLOR}"
                git rebase --abort
                exit $?
            else
                echo -e "${YELLOW}Continuing...${ENDCOLOR}"
            fi
            continue
        fi
        if [ "$choice" == "5" ]; then
            echo
            echo -e "Are you sure you want to ${GREEN}accept all incoming changes${ENDCOLOR} and discard current changes (y/n)?"
            read -n 1 -s choice_yes
            if [ "$choice_yes" == "y" ]; then
                echo
                echo -e "${YELLOW}Accepting all incoming changes...${ENDCOLOR}"
                checkout_output=$(git checkout --theirs . 2>&1)
                checkout_code=$?
                if [ $checkout_code -ne 0 ]; then
                    echo -e "${RED}Failed to accept incoming changes:${ENDCOLOR}"
                    echo "$checkout_output"
                    continue
                fi
                git add .
                rebase_output=$(git -c core.editor=true rebase --continue 2>&1)
                rebase_code=$?
                if [[ $rebase_output == *"Successfully rebased"* ]]; then
                    echo -e "${GREEN}Successfully accepted all incoming changes and continued rebase!${ENDCOLOR}"
                    return
                fi
                if [[ $rebase_output != *"CONFLICT"* ]]; then
                    echo -e "${RED}Cannot rebase! Error message:${ENDCOLOR}"
                    echo "$rebase_output"
                    exit $rebase_code
                fi
                echo -e "${GREEN}Accepted all incoming changes, moving to next conflict${ENDCOLOR}"
                new_step="true"
            else
                echo -e "${YELLOW}Continuing...${ENDCOLOR}"
            fi
            continue
        fi
        if [ "$choice" == "6" ]; then
            echo
            echo -e "Are you sure you want to ${GREEN}accept all current changes${ENDCOLOR} and discard incoming changes (y/n)?"
            read -n 1 -s choice_yes
            if [ "$choice_yes" == "y" ]; then
                echo
                echo -e "${YELLOW}Accepting all current changes...${ENDCOLOR}"
                conflicted_files=$(git --no-pager diff --name-only --diff-filter=U --relative)
                if [ -n "$conflicted_files" ]; then
                    checkout_failed_files=""
                    while IFS= read -r file; do
                        if [ -n "$file" ]; then
                            checkout_output=$(git checkout --ours "$file" 2>&1)
                            checkout_code=$?
                            if [ $checkout_code -ne 0 ]; then
                                git rm --cached "$file" 2>/dev/null || git reset HEAD "$file" 2>/dev/null
                                checkout_failed_files="$checkout_failed_files\n\t$file (removed - didn't exist in our branch)"
                            fi
                        fi
                    done <<< "$conflicted_files"
                    if [ -n "$checkout_failed_files" ]; then
                        echo -e "${YELLOW}Some files were removed because they don't exist in your current branch:${ENDCOLOR}"
                        echo -e "$checkout_failed_files"
                    fi
                else
                    echo -e "${YELLOW}No conflicted files found${ENDCOLOR}"
                fi
                git add .
                rebase_output=$(git -c core.editor=true rebase --continue 2>&1)
                rebase_code=$?
                if [[ $rebase_output == *"Successfully rebased"* ]]; then
                    echo -e "${GREEN}Successfully accepted all current changes and continued rebase!${ENDCOLOR}"
                    return
                fi
                if [[ $rebase_output != *"CONFLICT"* ]]; then
                    echo -e "${RED}Cannot rebase! Error message:${ENDCOLOR}"
                    echo "$rebase_output"
                    exit $rebase_code
                fi
                echo -e "${GREEN}Accepted all current changes, moving to next conflict${ENDCOLOR}"
                new_step="true"
            else
                echo -e "${YELLOW}Continuing...${ENDCOLOR}"
            fi
            continue
        fi
        if [ "$choice" == "0" ]; then
            exit
        fi
    done
}
function pull_script {
    case "$1" in
        fetch|fe)           fetch="true";;
        all|fa)             fetch="true"; all="true";;
        upd|u)              update="true";;
        ffonly|ff)          ffonly="true";;
        merge|m)            merge="true";;
        rebase|r)           rebase="true";;
        interactive|ri|rs)  rebase="true"; interactive="true";;
        help|h)             help="true";;
        *)
            wrong_mode "pull" $1
    esac
    header_msg="GIT PULL"
    if [ -n "${fetch}" ]; then
        if [ -n "${all}" ]; then
            header_msg="$header_msg FETCH ALL"
        else
            header_msg="$header_msg FETCH"
        fi
    elif [ -n "${rebase}" ]; then
        if [ -n "${interactive}" ]; then
            header_msg="$header_msg INTERACTIVE REBASE"
        else
            header_msg="$header_msg REBASE"
        fi
    elif [ -n "${ffonly}" ]; then
        header_msg="$header_msg FAST FORWARD ONLY"
    elif [ -n "${merge}" ]; then
        header_msg="$header_msg MERGE"
    elif [ -n "${update}" ]; then
        header_msg="$header_msg REMOTE UPDATE"
    fi
    echo -e "${YELLOW}${header_msg}${ENDCOLOR}"
    echo
    if [ -n "$help" ]; then
        echo -e "usage: ${YELLOW}gitb pull${ENDCOLOR}"
        echo
        echo -e "${YELLOW}Available modes${ENDCOLOR}"
        echo -e "<empty>\t\t\tFetch current branch, try to fast-forward or ask about strategy"
        echo -e "fetch|fe\t\tFetch current branch without merge"    
        echo -e "all|fa\t\t\tFetch all without merge"
        echo -e "upd|u\t\t\tRun git remote update to fetch all branches"
        echo -e "ffonly|ff\t\tFetch and then merge in fast forward only mode"
        echo -e "merge|m\t\t\tFetch current branch and then merge it"
        echo -e "rebase|r\t\tFetch current branch and then rebase"
        echo -e "interactive|ri|rs\tFetch current branch and then rebase in interactive mode with --autosquash"
        echo -e "help|h\t\t\tShow this help"
        exit
    fi
    if [ -n "$rebase" ]; then
        mode="rebase"
    elif [ -n "$merge" ]; then
        mode="merge"
    fi
    if [ -n "$fetch" ]; then
        if [ -n "$all" ]; then
            echo -e "${YELLOW}Fetching all...${ENDCOLOR}"
        else
            echo -e "${YELLOW}Fetching '$origin_name/$current_branch'...${ENDCOLOR}"
        fi
        echo
        fetch $current_branch $origin_name $all
        if [ $fetch_code == 0 ] ; then
            commits=$(commit_list 999 "tab" HEAD..$origin_name/$current_branch)
            if [ "$commits" != "" ]; then
                if [ -n "$all" ]; then
                    echo -e "${GREEN}Successfully fetched all!${ENDCOLOR}"
                else
                    echo -e "${GREEN}Successfully fetched '$origin_name/$current_branch'!${ENDCOLOR}"
                fi
                if [ "$fetch_output" != "" ]; then
                    echo
                    echo -e "$fetch_output"
                fi
                echo
                count=$(echo -e "$commits" | wc -l | sed 's/^ *//;s/ *$//')
                echo -e "Your branch is behind ${YELLOW}$origin_name/$current_branch${ENDCOLOR} by ${BOLD}$count${ENDCOLOR} commits"
                echo -e "$commits"
            else
                echo -e "${GREEN}Already up to date${ENDCOLOR}"
            fi
        fi
        exit
    fi
    if [ -n "$update" ]; then
        echo -e "${YELLOW}Updating from remote...${ENDCOLOR}"
        echo
        update_output=$(git remote update 2>&1)
        update_code=$?
        if [ $update_code == 0 ] ; then
            commits=$(commit_list 999 "tab" HEAD..$origin_name/$current_branch)
            if [ "$commits" != "" ]; then
                echo -e "${GREEN}Successfully updated from remote!${ENDCOLOR}"
                if [ "$update_output" != "" ]; then
                    echo
                    echo -e "$update_output"
                fi
                echo
                count=$(echo -e "$commits" | wc -l | sed 's/^ *//;s/ *$//')
                echo -e "Your branch is behind ${YELLOW}$origin_name/$current_branch${ENDCOLOR} by ${BOLD}$count${ENDCOLOR} commits"
                echo -e "$commits"
            else
                echo -e "${GREEN}Already up to date${ENDCOLOR}"
            fi
            exit
        fi
        echo -e "${RED}Cannot update! Error message:${ENDCOLOR}"
        echo -e "${update_output}"
        exit $update_code
    fi
    echo -e "${YELLOW}Pulling '$origin_name/$current_branch'...${ENDCOLOR}"
    echo
    pull $current_branch $origin_name $editor $mode $ffonly 
    exit
}
function fetch {
    if [ -n "$3" ]; then
        fetch_output=$(git fetch --all 2>&1)
        fetch_code=$?
    else
        fetch_output=$(git fetch $2 $1 2>&1)
        fetch_code=$?
    fi
    if [ $fetch_code == 0 ] ; then
        return
    fi
    if [[ ${fetch_output} != *"couldn't find remote ref"* ]]; then
        echo -e "${RED}Cannot fetch '$1'! Error message:${ENDCOLOR}"
        echo -e "${fetch_output}"
        exit $fetch_code
    fi
    echo -e "${YELLOW}There is no '$1' in $2${ENDCOLOR}"
}
function pull {
    fetch $1 $2
    if [ $fetch_code != 0 ] ; then
        return
    fi
    merge_output=$(git merge --ff-only $2/$1 2>&1)
    merge_code=$?
    mode="fast-forward"
    if [[ $merge_output == *"Already up to date"* ]]; then  
        echo -e "${GREEN}Already up to date${ENDCOLOR}"
        return
    fi
    if [ $merge_code != 0 ] ; then
        if [[ $merge_output != *"possible to fast-forward"* ]]; then
            echo -e "${RED}Cannot pull! Error message:${ENDCOLOR}"
            echo "$merge_output"
            exit $merge_code
        fi
        commits=$(commit_list 999 "tab" HEAD..$origin_name/$current_branch)
        count=$(echo -e "$commits" | wc -l | sed 's/^ *//;s/ *$//')
        echo -e "Your branch is behind ${YELLOW}$origin_name/$current_branch${ENDCOLOR} by ${BOLD}$count${ENDCOLOR} commits"
        echo -e "$commits"
        echo
        mode=$4
        if [ "$4" == "merge" ]; then
            echo -e "${YELLOW}Merging...${ENDCOLOR}"
            choice="1"
        elif [ "$4" == "rebase" ]; then
            echo -e "${YELLOW}Rebasing...${ENDCOLOR}"
            choice="2"
        else
            echo -e "${RED}Cannot fast forward!${ENDCOLOR} Choose an option:"
            echo -e "1. ${BLUE}Merge.${ENDCOLOR} It saves commit's timeline, but creates a merge commit with message:"
            echo -e "\t\t${YELLOW}Merge remote-tracking branch '$origin_name/$current_branch' into $current_branch${ENDCOLOR}"
            echo -e "2. ${BLUE}Rebase.${ENDCOLOR} It takes all new local commits and places them on top of the remote branch"
            read -n 1 -s choice
            re='^[12]+$'
            if ! [[ $choice =~ $re ]]; then
                exit 0
            fi
        fi
        echo
        if [ "$choice" == "1" ]; then
            merge $1 $2 $3 "pull" "true" $5
            mode="merge"
            if [ $merge_code != 0 ] ; then
                echo
           fi
        else 
           rebase_branch $1 $2 "true" $interactive $interactive
           mode="rebase"
           if [ $rebase_code != 0 ] ; then
                echo
           fi
        fi
    fi
    echo -e "${GREEN}Successfully pulled with $mode!${ENDCOLOR}"
    if [ "$mode" == "merge" ] || [ "$mode" == "fast-forward" ]; then 
        echo
        if [ $merge_code == 0 ] ; then
            if [[ $merge_output == *"made by the"* ]]; then
                changes=$(echo "$merge_output" | tail -n +3)
            else
                changes=$(echo "$merge_output" | tail -n +2)
            fi
            if [[ -n "$changes" ]]; then
                print_changes_stat "$changes"
            fi
        else
            commit_hash="$(git --no-pager log --pretty="%h" -1)"
            changes=$(git --no-pager show $commit_hash --stat --format="")
            if [[ -n "$changes" ]]; then
                print_changes_stat "$changes"
            fi
        fi
    fi
}
function push {
    push_output=$(git push $1 ${origin_name} ${current_branch} 2>&1)
    push_code=$?
    if [ $push_code -eq 0 ] ; then 
        echo -e "${GREEN}Successful push!${ENDCOLOR}"
        repo=$(get_repo)
        echo -e "${YELLOW}Repo:${ENDCOLOR}\t${repo}"
        if [[ ${current_branch} != ${main_branch} ]]; then
            link=$(echo "$push_output" | grep "https://" | sed 's|^remote:[[:space:]]*||')
            if [[ $repo == *"github"* ]]; then
                if [ "$link" != "" ]; then
                    echo -e "${YELLOW}New PR:${ENDCOLOR}\t${link}"
                else
                    echo -e "${YELLOW}PRs:${ENDCOLOR}\t${repo}/pulls"
                fi
            elif [[ $repo == *"gitlab"* ]]; then
                is_new=$(echo "$push_output" | grep "create a merge request")
                if [ "$is_new" != "" ]; then
                    echo -e "${YELLOW}New MR:${ENDCOLOR}\t${link}"
                else
                    if [ "$mr_link" != "" ]; then
                        echo -e "${YELLOW}MR:${ENDCOLOR}\t${link}"
                    else
                        echo -e "${YELLOW}MRs:${ENDCOLOR}\t${repo}/merge_requests"
                    fi
                fi
            fi
        fi
        exit
    fi
    if [[ $push_output != *"[rejected]"* ]]; then
        echo -e "${RED}Cannot push! Error message:${ENDCOLOR}"
        echo "$push_output"
        exit $push_code
    fi
}
function push_script {
    case "$1" in
        yes|y)      fast="true";;
        force|f)    force="true";;
        list|log|l) list="true";;
        help|h)     help="true";;
        *)
            wrong_mode "push" $1
    esac
    header_msg="GIT PUSH"
    if [ -n "${fast}" ]; then
        header_msg="${YELLOW}$header_msg FAST${ENDCOLOR}"
    elif [ -n "${force}" ]; then
        header_msg="${RED}$header_msg FORCE${ENDCOLOR}"
    elif [ -n "${list}" ]; then
        header_msg="${YELLOW}$header_msg LIST${ENDCOLOR}"
    else
        header_msg="${YELLOW}$header_msg${ENDCOLOR}"
    fi
    echo -e "${header_msg}"
    echo
    if [ -n "$help" ]; then
        echo -e "usage: ${YELLOW}gitb push <mode>${ENDCOLOR}"
        echo
        echo -e "${YELLOW}Available modes${ENDCOLOR}"
        echo -e "<empty>\t\tPrint list of commits, push them to current branch or pull changes first"
        echo -e "yes|y\t\tSame as <empty> but without pressing 'y'"
        echo -e "force|f\t\tSame as <empty> but with --force"
        echo -e "list|log|l\tPrint a list of unpushed local commits without actual pushing it"
        echo -e "help|h\t\tShow this help"
        exit
    fi
    get_push_list ${current_branch} ${main_branch} ${origin_name}
    if [ -z "$push_list" ]; then
        echo -e "${GREEN}Nothing to push${ENDCOLOR}"
        exit
    fi
    if [ "${history_from}" != "${origin_name}/${current_branch}" ]; then
        echo -e "Branch ${YELLOW}${current_branch}${ENDCOLOR} doesn't exist in the ${YELLOW}${origin_name}${ENDCOLOR}, get commits diff from the base commit"
    fi
    count=$(echo -e "$push_list" | wc -l | sed 's/^ *//;s/ *$//')
    echo -e "Your branch is ahead ${YELLOW}${history_from}${ENDCOLOR} by ${BOLD}$count${ENDCOLOR} commits"
    echo -e "$push_list"
    if [ -n "$list" ]; then
        exit
    fi
    echo
    if [ -n "${force}" ]; then
        force_arg=" --force"
    fi
    if [ -z "${fast}" ]; then
        echo -e "Do you want to push${RED}${force_arg}${ENDCOLOR} this commits to ${YELLOW}${origin_name}/${current_branch}${ENDCOLOR} (y/n)?"
        if [ "${current_branch}" == "${main_branch}" ]; then
            echo -e "${RED}Warning!${ENDCOLOR} You are going to push right in the default ${YELLOW}${main_branch}${ENDCOLOR} branch"
        fi
        yes_no_choice "Pushing..."
    else
        echo -e "${YELLOW}Pushing...${ENDCOLOR}"
        echo
    fi
    push $force_arg
    echo -e "${RED}Cannot push!${ENDCOLOR} There are unpulled changes in ${YELLOW}${origin_name}/${current_branch}${ENDCOLOR}"
    echo
    echo -e "Do you want to pull ${YELLOW}${origin_name}/${current_branch}${ENDCOLOR} (y/n)?"
    yes_no_choice "Pulling..."
    pull $current_branch $origin_name $editor
    echo
    echo -e "${YELLOW}Pushing...${ENDCOLOR}"
    echo
    push $force_arg
}
function cleanup_on_exit {
    if [ -n "$1" ]; then
        git restore --staged $1
    fi
}
function detect_scopes_from_staged_files {
    detected_scopes=""
    local staged_files=$(git diff --name-only --cached)
    if [ -n "$staged_files" ]; then
        declare -A scope_counts
        declare -A scope_depths
        while IFS= read -r file; do
            if [ -n "$file" ]; then
                IFS='/' read -r -a path_components <<< "$file"
                for i in "${!path_components[@]}"; do
                    component="${path_components[$i]}"
                    if [ -n "$component" ]; then
                        if [ $i -eq $((${#path_components[@]} - 1)) ]; then
                            component_no_ext="${component%.*}"
                            component_no_ext_lower="${component_no_ext,,}"
                            scope_counts["$component_no_ext_lower"]=$((${scope_counts["$component_no_ext_lower"]:-0} + 1))
                            current_depth=$((i + 1))
                            if [ -z "${scope_depths["$component_no_ext_lower"]}" ] || [ $current_depth -lt ${scope_depths["$component_no_ext_lower"]} ]; then
                                scope_depths["$component_no_ext_lower"]=$current_depth
                            fi
                        else
                            component_lower="${component,,}"
                            if [[ ! "$component_lower" =~ ^(src|lib|test|tests|spec|specs|build|dist|node_modules|vendor|tmp|temp|cache|logs|log)$ ]]; then
                                scope_counts["$component_lower"]=$((${scope_counts["$component_lower"]:-0} + 1))
                                current_depth=$((i + 1))
                                if [ -z "${scope_depths["$component_lower"]}" ] || [ $current_depth -lt ${scope_depths["$component_lower"]} ]; then
                                    scope_depths["$component_lower"]=$current_depth
                                fi
                            fi
                        fi
                    fi
                done
            fi
        done <<< "$staged_files"
        max_count=0
        for token in "${!scope_counts[@]}"; do
            if [ ${scope_counts["$token"]} -gt $max_count ]; then
                max_count=${scope_counts["$token"]}
            fi
        done
        total_unique_tokens=${#scope_counts[@]}
        detected_scopes_array=()
        for token in "${!scope_counts[@]}"; do
            count=${scope_counts["$token"]}
            depth=${scope_depths["$token"]}
            if [ $total_unique_tokens -le 7 ]; then
                detected_scopes_array+=("$count:$depth:$token")
            elif [ $max_count -gt 1 ]; then
                if [ $count -gt 1 ]; then
                    detected_scopes_array+=("$count:$depth:$token")
                fi
            else
                detected_scopes_array+=("$count:$depth:$token")
            fi
        done
        if [ ${#detected_scopes_array[@]} -gt 0 ]; then
            filename_entries=()
            directory_entries=()
            for entry in "${detected_scopes_array[@]}"; do
                count="${entry%%:*}"  # Extract count (first field)
                rest="${entry#*:}"    # Remove count
                depth="${rest%%:*}"   # Extract depth (second field)
                token="${rest#*:}"    # Extract token (third field)
                if [ $depth -ge 4 ]; then  # Assume depth 4+ are likely filenames
                    filename_entries+=("$entry")
                else
                    directory_entries+=("$entry")
                fi
            done
            IFS=$'\n' filename_sorted=($(printf '%s\n' "${filename_entries[@]}" | sort -t':' -k1,1nr -k2,2n -k3,3))
            unset IFS
            IFS=$'\n' directory_sorted=($(printf '%s\n' "${directory_entries[@]}" | sort -t':' -k1,1nr -k2,2n -k3,3))
            unset IFS
            detected_scopes_sorted=("${filename_sorted[@]}" "${directory_sorted[@]}")
            final_scopes=()
            count=0
            for entry in "${detected_scopes_sorted[@]}"; do
                if [ $count -ge 9 ]; then
                    break
                fi
                token="${entry##*:}"  # Extract token after last colon
                final_scopes+=("$token")
                count=$((count + 1))
            done
            detected_scopes="${final_scopes[*]}"
        fi
    fi
}
function handle_ai_commit_generation {
    local step="$1"
    local ai_mode="$2"
    local commit_prefix="$3"
    echo
    if [ "$ai_mode" = "full" ]; then
        echo -e "${YELLOW}Step ${step}.${ENDCOLOR} Generating ${YELLOW}multiline commit message${ENDCOLOR} using AI..."
    elif [ "$ai_mode" = "subject" ]; then
        echo -e "${YELLOW}Step ${step}.${ENDCOLOR} Generating ${YELLOW}commit message subject${ENDCOLOR} using AI..."
    else
        echo -e "${YELLOW}Step ${step}.${ENDCOLOR} Generating ${YELLOW}commit message${ENDCOLOR} using AI..."
    fi
    if ! check_ai_available; then
        cleanup_on_exit "$git_add"
        exit 1
    fi
    detect_scopes_from_staged_files
    local ai_commit_message
    if [ "$ai_mode" = "full" ]; then
        ai_commit_message=$(generate_ai_commit_message_full "$detected_scopes")
    elif [ "$ai_mode" = "subject" ]; then
        ai_commit_message=$(generate_ai_commit_message_subject "$commit_prefix" "$detected_scopes")
    else
        ai_commit_message=$(generate_ai_commit_message "$detected_scopes")
    fi
    if [ $? -ne 0 ] || [ -z "$ai_commit_message" ]; then
        echo
        echo -e "${RED}Failed to generate AI commit message${ENDCOLOR}"
        cleanup_on_exit "$git_add"
        exit 1
    fi
    ai_commit_message=$(echo "$ai_commit_message" | sed 's/^"//;s/"$//' | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')
    echo
    echo -e "${GREEN}AI generated commit message:${ENDCOLOR}"
    echo -e "${BOLD}$ai_commit_message${ENDCOLOR}"
    echo
    read -n 1 -p "Use this commit message? (y/n/e to edit/0 to exit) " -s choice
    echo
    if [ "$ai_mode" != "subject" ] && [ "$choice" != "0" ]; then
        echo
    fi
    if [ "$choice" = "y" ] || [ "$choice" = "Y" ]; then
        commit="$ai_commit_message"
        if [ "$ai_mode" = "subject" ]; then
            echo
        fi
        result=$(git commit -m """$commit""" 2>&1)
        check_code $? "$result" "commit"
        git config --unset gitbasher.cached-git-add 2>/dev/null
        after_commit
        if [ -n "${push}" ]; then
            echo
            push_script y
        fi
        exit
    elif [ "$choice" = "e" ] || [ "$choice" = "E" ]; then
        if [ "$ai_mode" = "full" ]; then
            echo -e "${YELLOW}Edit the AI generated message:${ENDCOLOR}"
            commitmsg_file=$(mktemp "/tmp/commitmsg.XXXXXX")
            echo "$ai_commit_message" > $commitmsg_file
            while [ true ]; do
                $editor $commitmsg_file
                commit_message=$(cat $commitmsg_file | sed '/^#/d')
                if [ -n "$commit_message" ]; then
                    break
                fi
                echo
                echo -e "${YELLOW}Commit message cannot be empty${ENDCOLOR}"
                echo
                read -n 1 -p "Try for one more time? (y/n) " -s -e choice
                if [ "$choice" != "y" ]; then
                    cleanup_on_exit "$git_add"
                    rm -f "$commitmsg_file"
                    exit
                fi    
            done
            commit_message=$(cat $commitmsg_file)
            rm -f "$commitmsg_file"
            echo
        else
            if [ "$ai_mode" = "subject" ]; then
                echo
            fi
            echo -e "${YELLOW}Edit the AI generated message:${ENDCOLOR}"
            read -p "" -e -i "$ai_commit_message" commit_message
        fi
        if [ -z "$commit_message" ]; then
            cleanup_on_exit "$git_add"
            exit
        fi
        commit="$commit_message"
        echo
        result=$(git commit -m """$commit""" 2>&1)
        check_code $? "$result" "commit"
        git config --unset gitbasher.cached-git-add 2>/dev/null
        after_commit
        if [ -n "${push}" ]; then
            echo
            push_script y
        fi
        exit
    elif [ "$choice" = "0" ]; then
        cleanup_on_exit "$git_add"
        exit
    else
        if [ "$ai_mode" = "subject" ]; then
            echo
        fi
        echo -e "${YELLOW}Falling back to manual commit message creation...${ENDCOLOR}"
        if [ "$ai_mode" = "subject" ]; then
            echo
        fi
    fi
}
function after_commit {
    if [ -n "$1" ]; then
        echo -e "${GREEN}Successful commit $1!${ENDCOLOR}"
    else
        echo -e "${GREEN}Successful commit!${ENDCOLOR}"
    fi
    echo
    commit_hash=$(git rev-parse HEAD)
    echo -e "${BLUE}[$current_branch ${commit_hash::7}]${ENDCOLOR}"
    if [ -z "${commit}" ]; then
        echo $(git log -1 --pretty=%B | cat)
    else
        printf "$commit\n"
    fi
    echo
    print_changes_stat "$(git --no-pager show $commit_hash --stat --format="")"
    if [ -z "${fast}" ] && [ -z "${push}" ]; then
        echo
        echo -e "Push your changes: ${YELLOW}gitb push${ENDCOLOR}"
        echo -e "Undo commit: ${YELLOW}gitb reset${ENDCOLOR}"
    fi
}
function commit_script {
    case "$1" in
        scope|s)            ;; # general commit with scope
        msg|m)              msg="true";;
        ticket|jira|j|t)    ticket="true";;
        fast|f)             fast="true";;
        fasts|fs|sf)        fast="true"; scope="true";;
        staged|st)          staged="true";;
        push|pu|p)          push="true";;
        fastp|fp|pf)        fast="true"; push="true";;
        fastsp|fsp|fps)     fast="true"; push="true"; scope="true";;
        fixup|fix|x)        fixup="true";;
        fixupp|fixp|xp|px)  fixup="true"; push="true";;
        fixupst|xst|stx)    fixup="true"; staged="true";;
        fastfix|fx|xf)      fixup="true"; fast="true";;
        fastfixp|fxp|xfp)   fixup="true"; fast="true"; push="true";;
        amend|am|a)         amend="true";;
        amendst|ast|sta)    amend="true"; staged="true";;
        amendf|amf|af|fa)   amend="true"; fast="true";;
        last|l)             last="true";;
        revert|rev)         revert="true";;
        llm|ai|i)           llm="true";;
        llmf|aif|if)        llm="true"; fast="true";;
        llmp|aip|ip)        llm="true"; push="true";;
        llmst|aist|ist)     llm="true"; staged="true";;
        llmfp|aifp|ifp|ipf) llm="true"; fast="true"; push="true";;
        llms|ais|is)        llm="true"; scope="true";;
        llmsf|aisf|isf)     llm="true"; scope="true"; fast="true";;
        llmsfp|aisfp|isfp)  llm="true"; scope="true"; fast="true"; push="true";;
        llmm|aim|im)        llm="true"; msg="true";;
        llmmf|aimf|imf)     llm="true"; msg="true"; fast="true";;
        llmmfp|aimfp|imfp)  llm="true"; msg="true"; fast="true"; push="true";;
        help|h)             help="true";;
        *)
            wrong_mode "commit" $1
    esac
    header_msg="GIT COMMIT"
    if [ -n "${llm}" ]; then
        header_msg="$header_msg AI"
    fi
    if [ -n "${staged}" ]; then
        header_msg="$header_msg STAGED"
    elif [ -n "${fast}" ]; then
        if [ -n "${push}" ]; then
            if [ -n "${fixup}" ]; then
                header_msg="$header_msg FAST FIXUP & PUSH"
            else
                header_msg="$header_msg FAST & PUSH"
            fi
        elif [ -n "${fixup}" ]; then
            header_msg="$header_msg FAST FIXUP"
        else
            header_msg="$header_msg FAST"
        fi
    elif [ -n "${fixup}" ]; then
        if [ -n "${push}" ]; then
            header_msg="$header_msg FIXUP & PUSH"
        else
            header_msg="$header_msg FIXUP"
        fi
    elif [ -n "${push}" ]; then
        header_msg="$header_msg & PUSH"
    elif [ -n "${msg}" ]; then
        header_msg="$header_msg MSG"
    elif [ -n "${ticket}" ]; then
        header_msg="$header_msg TICKET"
    elif [ -n "${amend}" ]; then
        header_msg="$header_msg AMEND LAST"
    elif [ -n "${last}" ]; then
        header_msg="$header_msg LAST"
    elif [ -n "${revert}" ]; then
        header_msg="$header_msg REVERT"
    fi
    echo -e "${YELLOW}${header_msg}${ENDCOLOR}"
    echo
    if [ -n "$help" ]; then
        echo -e "usage: ${YELLOW}gitb commit <mode>${ENDCOLOR}"
        echo
        echo -e "${YELLOW}Available modes${ENDCOLOR}"
        echo -e "<empty>\t\tSelect files to commit and create a conventional message in format: 'type(scope): message'"
        echo -e "fast|f\t\tAdd all files (git add .) and create a conventional commit message without scope"
        echo -e "fasts|fs|sf\tAdd all files (git add .) and create a conventional commit message with scope"
        echo -e "staged|st\tUse already staged files for commit (skip git add step)"
        echo -e "push|pu|p\tCreate a conventional commit and push changes at the end"
        echo -e "fastp|fp|pf\tCreate a conventional commit in the fast mode and push changes"
        echo -e "fastsp|fsp|fps\tCreate a conventional commit in the fast mode with scope and push changes"
        echo -e "fixup|fix|x\tSelect files and commit to make a --fixup commit (git commit --fixup <hash>)"
        echo -e "fixupp|fixp|xp\tSelect files and commit to make a --fixup commit and push changes"
        echo -e "fixupst|xst|stx\tSelect files and commit to make a --fixup commit (git commit --fixup <hash>)"
        echo -e "fastfix|fx|xf\tAdd all files (git add .) and commit to make a --fixup commit"
        echo -e "fastfixp|fxp\tAdd all files (git add .) and commit to make a --fixup commit and push"
        echo -e "msg|m\t\tSame as <empty>, but create multiline commit message using text editor"
        echo -e "ticket|t\tSame as <empty>, but add tracker's ticket info to the end of the commit header"
        echo -e "amend|am|a\tSelect files and add them to the last commit without message edit (git commit --amend --no-edit)"
        echo -e "amendst|ast|sta\tSelect files and add them to the last commit without message edit (git commit --amend --no-edit)"
        echo -e "amendf|amf|af\tAdd all fiels to the last commit without message edit (git commit --amend --no-edit)"
        echo -e "last|l\t\tChange commit message to the last one"
        echo -e "revert|rev\tSelect a commit to revert (git revert -no-edit <commit>)"
        echo -e "llm|ai|i\tUse AI to generate commit message based on staged changes"
        echo -e "llmf|aif|if\tUse AI to generate commit message in the fast mode (git add .) without confirmation"
        echo -e "llmp|aip|ip\tUse AI to generate commit message and push changes"
        echo -e "llmfp|aifp|ifp\tUse AI to generate commit message in the fast mode and push changes"
        echo -e "llmst|aist|ist\tUse AI to generate commit message in the staged mode"
        echo -e "llms|ais|is\tUse AI to generate commit summary with manual type and scope enter"
        echo -e "llmsf|aisf|isf\tUse AI to generate commit summary with manual type and scope enter in the fast mode (git add .)"
        echo -e "llmsfp|aisfp|isfp\tUse AI to generate commit summary with manual type and scope enter in the fast mode and push changes"
        echo -e "llmm|aim|im\tUse AI to generate multiline commit message with body"
        echo -e "llmmf|aimf|imf\tUse AI to generate multiline commit message with body in the fast mode (git add .)"
        echo -e "llmmfp|aimfp|imfp\tUse AI to generate multiline commit message with body in the fast mode and push changes"
        echo -e "help|h\t\tShow this help"
        git config --unset gitbasher.cached-git-add 2>/dev/null
        exit
    fi
    if [ -n "$last" ]; then
        git config --unset gitbasher.cached-git-add 2>/dev/null
        git commit --amend
        exit
    fi
    is_clean=$(git status | tail -n 1)
    if [ "$is_clean" = "nothing to commit, working tree clean" ]; then
        if [ -z "${revert}" ]; then
            git config --unset gitbasher.cached-git-add 2>/dev/null
            echo -e "${GREEN}Nothing to commit, working tree clean${ENDCOLOR}"
            exit
        fi
    elif [ -n "${revert}" ]; then
        echo -e "${RED}Cannot revert! There are uncommited changes:${ENDCOLOR}"
        exit
    fi
    if [ -n "${staged}" ]; then
        staged_files_check=$(git diff --name-only --cached)
        if [ -z "$staged_files_check" ]; then
            echo -e "${RED}No staged files found!${ENDCOLOR}"
            exit 1
        fi
        echo -e "${YELLOW}Using already staged files:${ENDCOLOR}"
        staged_display="$(sed 's/^/\t/' <<< "$staged_files_check")"
        echo -e "${GREEN}${staged_display}${ENDCOLOR}"
    fi
    if [ -n "${revert}" ]; then
        echo -e "${YELLOW}Step 1.${ENDCOLOR} Select a commit to ${YELLOW}revert${ENDCOLOR} it:"
        choose_commit 20
        result=$(git revert --no-edit ${commit_hash} 2>&1)
        check_code $? "$result" "revert"
        after_commit "revert"
        exit
    fi
    if [ -z "${fast}" ] && [ -z "${staged}" ]; then 
        echo -e "${YELLOW}Changed files${ENDCOLOR}"
        git_status
    fi
    saved_git_add=""
    if [ -z "${fast}" ] && [ -z "${staged}" ]; then
        saved_git_add=$(git config --get gitbasher.cached-git-add 2>/dev/null)
        if [ -n "$saved_git_add" ]; then
            echo
            echo -e "${YELLOW}Found previous git add arguments:${ENDCOLOR} ${BOLD}$saved_git_add${ENDCOLOR}"
            read -n 1 -p "Use them? (y/n) " -s choice
            echo
            if [ "$choice" = "y" ] || [ "$choice" = "Y" ]; then
                git add $saved_git_add
                if [ $? -eq 0 ]; then
                    git_add="$saved_git_add"
                    use_saved_git_add="true"
                else
                    echo
                    echo -e "${RED}Failed to apply saved git add arguments, continuing normally${ENDCOLOR}"
                    git config --unset gitbasher.cached-git-add 2>/dev/null
                fi
                echo
            else
                git config --unset gitbasher.cached-git-add 2>/dev/null
            fi
        fi
    fi
    if [ -n "${staged}" ]; then
        git_add=""
        git config --unset gitbasher.cached-git-add 2>/dev/null
    elif [ -n "${fast}" ]; then
        git add .
        git_add="."
        git config --unset gitbasher.cached-git-add 2>/dev/null
    elif [ -n "${use_saved_git_add}" ]; then
        echo -e "${YELLOW}Step 1.${ENDCOLOR} Using saved git add arguments: ${BOLD}$git_add${ENDCOLOR}"
        echo
    else
        echo
        printf "${YELLOW}Step 1.${ENDCOLOR} List files for "
        if [ -n "${fixup}" ]; then
            printf "${YELLOW}--fixup${ENDCOLOR} "
        elif [ -n "${squash}" ]; then
            printf "${YELLOW}--squash${ENDCOLOR} "
        elif [ -n "${amend}" ]; then
            printf "${YELLOW}--amend${ENDCOLOR} "
        fi
        if [ -n "${amend}" ]; then
            printf "to the last commit in the ${YELLOW}${current_branch}${ENDCOLOR} branch\n"
        else
            printf "commit to the ${YELLOW}${current_branch}${ENDCOLOR} branch\n"
        fi
        echo "Press Enter if you want to exit"
        while [ true ]; do
            read -p "$(echo -n -e "${BOLD}git add${ENDCOLOR} ")" -e git_add
            if [ "$git_add" == "" ]; then
                exit
            fi
            if ! sanitize_file_path "$git_add"; then
                show_sanitization_error "file path" "Invalid file path or pattern. Avoid dangerous characters and sequences."
                continue
            fi
            git_add="$sanitized_file_path"
            result=$(git add $git_add 2>&1)
            code=$?
            staged_files_list="$(git diff --name-only --cached)"
            if [ $code -eq 0 ] && [ -n "$staged_files_list" ]; then
                git config gitbasher.cached-git-add "$git_add"
                break
            else
                if [[ "$git_add" != *"*" ]]; then
                    echo
                    git_add_with_star="${git_add}*"
                    echo -e "${YELLOW}No files were staged! Trying with wildcard:${ENDCOLOR} ${BOLD}git add $git_add_with_star${ENDCOLOR}"
                    result_star=$(git add $git_add_with_star 2>&1)
                    code_star=$?
                    staged_files_list_star="$(git diff --name-only --cached)"
                    if [ $code_star -eq 0 ] && [ -n "$staged_files_list_star" ]; then
                        git config gitbasher.cached-git-add "$git_add_with_star"
                        git_add="$git_add_with_star"
                        break
                    else
                        echo -e "${RED}Failed to add files with wildcard:${ENDCOLOR} ${BOLD}$result_star${ENDCOLOR}"
                        echo
                    fi
                else
                    echo "$result"
                fi
            fi
        done
        echo
    fi
    if [ -z "${staged}" ]; then
        echo -e "${YELLOW}Staged files:${ENDCOLOR}"
        staged="$(sed 's/^/\t/' <<< "$(git diff --name-only --cached)")"
        echo -e "${GREEN}${staged}${ENDCOLOR}"
    else
        staged="$(sed 's/^/\t/' <<< "$(git diff --name-only --cached)")"
    fi
    if [ -n "${llm}" ] && [ -z "${scope}" ]; then
        if [ -n "${fast}" ] || [ -n "${staged}" ]; then
            step="1"
        else
            step="2"
        fi
        type="simple"
        if [ -n "${msg}" ]; then
            type="full"
        fi
        handle_ai_commit_generation "$step" "$type" ""
    fi
    if [ -n "${fixup}" ]; then
        echo
        step="2"
        if [ -n "${fast}" ] || [ -n "${staged}" ]; then
            step="1"
        fi
        echo -e "${YELLOW}Step ${step}.${ENDCOLOR} Select a commit to ${YELLOW}--fixup${ENDCOLOR}:"
        if [ -n "${fast}" ] || [ -n "${staged}" ]; then
            choose_commit 9
        else
            choose_commit 19
        fi
        result=$(git commit --fixup $commit_hash 2>&1)
        check_code $? "$result" "fixup"
        git config --unset gitbasher.cached-git-add 2>/dev/null
        after_commit "fixup"
        if [ -n "${push}" ]; then
            echo
            push_script y
        fi
        exit
    fi
    if [ -n "${amend}" ]; then
        result=$(git commit --amend --no-edit 2>&1)
        check_code $? "$result" "amend"
        git config --unset gitbasher.cached-git-add 2>/dev/null
        echo
        after_commit "amend"
        exit
    fi
    echo
    step="2"
    if [ -n "${fast}" ] || [ -n "${staged}" ]; then
        step="1"
    fi
    echo -e "${YELLOW}Step ${step}.${ENDCOLOR} What ${YELLOW}type${ENDCOLOR} of changes do you want to commit?"
    echo -e "Final meesage will be ${YELLOW}<type>${ENDCOLOR}(${BLUE}<scope>${ENDCOLOR}): ${BLUE}<summary>${ENDCOLOR}"
    echo -e "1. ${BOLD}feat${ENDCOLOR}:\tnew feature, logic change or performance improvement"
    echo -e "2. ${BOLD}fix${ENDCOLOR}:\t\tsmall changes, eg. bug fix"
    echo -e "3. ${BOLD}refactor${ENDCOLOR}:\tcode change that neither fixes a bug nor adds a feature, style changes"
    echo -e "4. ${BOLD}test${ENDCOLOR}:\tadding missing tests or changing existing tests"
    echo -e "5. ${BOLD}build${ENDCOLOR}:\tchanges that affect the build system or external dependencies"
    echo -e "6. ${BOLD}ci${ENDCOLOR}:\t\tchanges to CI configuration files and scripts"
    echo -e "7. ${BOLD}chore${ENDCOLOR}:\tmaintanance and housekeeping"
    echo -e "8. ${BOLD}docs${ENDCOLOR}:\tdocumentation changes"
    echo -e "9.  \t\twrite plain commit without type and scope"
    echo -e "0. Exit without changes"
    declare -A types=(
        [1]="feat"
        [2]="fix"
        [3]="refactor"
        [4]="test"
        [5]="build"
        [6]="ci"
        [7]="chore"
        [8]="docs"
    )
    while [ true ]; do
        read -n 1 -s choice
        if [ "$choice" == "0" ]; then
            cleanup_on_exit "$git_add"
            exit
        fi
        re='^[0-9]+$'
        if ! [[ $choice =~ $re ]]; then
            continue
        fi
        if [ "$choice" == "9" ]; then
            is_empty="true"
            break
        fi
        commit_type="${types[$choice]}"
        if [ -n "$commit_type" ]; then
            break
        fi
    done
    commit=""
    if [ -z "$is_empty" ]; then
        commit="$commit_type"
    fi
    if [ -z "$is_empty" ] && ([ -z "$fast" ] || [ -n "$scope" ]); then
        step="3"
        if [ -n "${fast}" ] || [ -n "${staged}" ]; then
            step="2"
        fi
        echo
        echo -e "${YELLOW}Step ${step}.${ENDCOLOR} Enter a ${YELLOW}scope${ENDCOLOR} of changes to provide some additional context"
        echo -e "Final meesage will be ${BLUE}${commit_type}${ENDCOLOR}(${YELLOW}<scope>${ENDCOLOR}): ${BLUE}<summary>${ENDCOLOR}"
        echo -e "Press Enter to continue without scope or enter 0 to exit without changes"
        detect_scopes_from_staged_files
        all_scopes=""
        if [ -n "$scopes" ]; then
            all_scopes="$scopes"
        elif [ -n "$detected_scopes" ]; then
            all_scopes="$detected_scopes"
        fi
        if [ -n "$all_scopes" ]; then
           IFS=' ' read -r -a scopes_array <<< "$all_scopes"
           res=""
           for i in "${!scopes_array[@]}"; do
                scope_display="${scopes_array[$i]}"
                res="$res$((i+1)). ${BOLD}${scope_display}${ENDCOLOR}|"
           done
           echo -e "You can select one of the ${YELLOW}detected scopes${ENDCOLOR}: $(echo $res | column -ts'|')"            
        fi
        while [ true ]; do
            read -p "<scope>: " -e commit_scope
            if [ "$commit_scope" == "0" ]; then
                cleanup_on_exit "$git_add"
                exit
            fi
            if [ -z "$commit_scope" ]; then
                commit="$commit: "
                break
            fi
            re_number='^[1-9][0-9]*$'
            if [[ $commit_scope =~ $re_number ]] && [ -n "$all_scopes" ]; then
                IFS=' ' read -r -a scopes_array <<< "$all_scopes"
                index=$((commit_scope - 1))
                if [ $index -ge 0 ] && [ $index -lt ${#scopes_array[@]} ]; then
                    selected_scope="${scopes_array[$index]}"
                    commit_scope="${selected_scope#*}"
                    commit="$commit($commit_scope): "
                    break
                else
                    echo -e "${RED}Invalid scope index! Please choose from 1-${#scopes_array[@]} or enter custom scope.${ENDCOLOR}"
                    continue
                fi
            else
                if ! sanitize_git_name "$commit_scope"; then
                    show_sanitization_error "scope" "Use only letters, numbers, hyphens, underscores, dots, and slashes."
                    continue
                fi
                commit_scope="$sanitized_git_name"
                commit="$commit($commit_scope): "
                break
            fi
        done
    fi
    if [ -z "$is_empty" ] && ([ -n "$fast" ]) && [ -z "$scope" ]; then
        commit="$commit: "
    fi
    if [ -n "${fast}" ]; then
        if [ -n "$scope" ]; then
            step="3"
        else
            step="2"
        fi
    elif [ -n "$is_empty" ] || [ -n "${staged}" ]; then
        step="3"
    else
        step="4"
    fi
    if [ -n "${llm}" ] && [ -n "${scope}" ]; then
        handle_ai_commit_generation "$step" "subject" "$commit"
    else
        echo
    fi
    echo -e "${YELLOW}Step ${step}.${ENDCOLOR} Write a ${YELLOW}summary${ENDCOLOR} about your changes"
    if [ -n "$is_empty" ]; then
        echo -e "Final meesage will be ${YELLOW}<summary>${ENDCOLOR}"
    elif [ "$commit_scope" == "" ]; then
        echo -e "Final meesage will be ${BLUE}${commit_type}${ENDCOLOR}: ${YELLOW}<summary>${ENDCOLOR}"
    else
        echo -e "Final meesage will be ${BLUE}${commit_type}${ENDCOLOR}(${BLUE}${commit_scope}${ENDCOLOR}): ${YELLOW}<summary>${ENDCOLOR}"
    fi
    echo -e "Press Enter if you want to exit"
    if [ -n "$msg" ]; then
        commitmsg_file=$(mktemp "/tmp/commitmsg.XXXXXX")
        staged_with_tab="$(sed 's/^/####\t/' <<< "${staged}")"
        echo """
####
#### Step ${step}. Write only <summary> about your changes without type and scope. 
#### It will be appended to '${commit}'. 
#### Lines starting with '#' will be ignored. 
#### 
#### On branch ${current_branch}
#### Changes to be commited:
${staged_with_tab}
####
#### Here is expected format:
#### ${commit}<summary>
#### <BLANK LINE>
#### <optional body>
#### <BLANK LINE>
#### <optional footer>
####
#### Summary should provide a succinct description of the change:
####     use the imperative, present tense: 'change' not 'changed' nor 'changes'
####     no dot (.) at the end
####     don't capitalize the first letter
####
#### The body is optional and should explain why you are making the change. 
####
#### The footer is optional and should contain any information about 'Breaking Changes'.
#### Breaking Change section should start with the phrase 'BREAKING CHANGE: ' followed by a summary of the breaking change.
####
#### Similarly, a Deprecation section should start with 'DEPRECATED: ' followed by a short description of what is deprecated.
""" >> $commitmsg_file
        while [ true ]; do
            $editor $commitmsg_file
            commit_message=$(cat $commitmsg_file | sed '/^#/d')
            if [ -n "$commit_message" ]; then
                break
            fi
            echo
            echo -e "${YELLOW}Commit message cannot be empty${ENDCOLOR}"
            echo
            read -n 1 -p "Try for one more time? (y/n) " -s -e choice
            if [ "$choice" != "y" ]; then
                cleanup_on_exit "$git_add"
                rm -f "$commitmsg_file"
                exit
            fi    
        done
        rm -f "$commitmsg_file"
    else
        read -p "$(echo -n -e "${commit}")" -e commit_message
        if [ -z "$commit_message" ]; then
            cleanup_on_exit "$git_add"
            exit
        fi
        if ! sanitize_commit_message "$commit_message"; then
            show_sanitization_error "commit message" "Use printable characters only, 1-2000 characters."
            cleanup_on_exit "$git_add"
            exit 1
        fi
        commit_message="$sanitized_commit_message"
    fi
    if [ -n "${ticket}" ]; then
        echo
        echo -e "${YELLOW}Step 5.${ENDCOLOR} Enter the number of a resolved issue (e.g. in JIRA or Youtrack)"
        echo -e "It will be added to the end of the summary header"
        echo -e "Press Enter to continue or 0 to exit without changes"
        if [ -n "$ticket_name" ]; then
            read -p "${ticket_name}${sep}" -e commit_ticket
        else 
            read -p "<ticket>: " -e commit_ticket
        fi
        if [ "$commit_ticket" == "0" ]; then
            cleanup_on_exit "$git_add"
            exit
        fi
        if [ "$commit_ticket" != "" ]; then
            if ! sanitize_text_input "$commit_ticket" 50; then
                show_sanitization_error "ticket" "Use printable characters only, max 50 characters."
                cleanup_on_exit "$git_add"
                exit 1
            fi
            commit_ticket="$sanitized_text"
            summary=$(echo "$commit_message" | head -n 1)
            remaining_message=""
            if [ "$summary" != "$commit_message" ]; then
                remaining_message=$(echo "$commit_message" | tail -n +2)
                remaining_message="""
    $remaining_message"
            fi
            if [ -n "$ticket_name" ]; then
                commit_ticket="${ticket_name}${sep}${commit_ticket}"
            fi
            commit_message="$summary ($commit_ticket)$remaining_message"
        fi
    fi
    commit="${commit}${commit_message}"
    echo
    result=$(git commit -m """$commit""" 2>&1)
    check_code $? "$result" "commit"
    git config --unset gitbasher.cached-git-add 2>/dev/null
    after_commit
    if [ -n "${push}" ]; then
        echo
        push_script y
    fi
}
function branch_script {
    case "$1" in
        list|l)      list="true";;
        remote|r|re) remote="true";;
        main|def|m)  main="true";;
        new|n|c)          
            new="true"
            current="true"    
        ;;
        newd|nd|cd)        
            new="true"
        ;;
        delete|del|d) delete="true";;
        tag|t)        tag="true";;
        help|h)       help="true";;
        *)
            wrong_mode "branch" $1
    esac
    header="GIT BRANCH"
    if [ -n "${remote}" ]; then
        header="$header REMOTE"
    elif [ -n "${main}" ]; then
        header="$header DEFAULT"
    elif [ -n "${current}" ]; then
        header="$header NEW"
    elif [ -n "${new}" ]; then
        header="$header NEW FROM DEFAULT"
    elif [ -n "${list}" ]; then
        header="$header LIST"
    elif [ -n "${delete}" ]; then
        header="$header DELETE"
    elif [ -n "${tag}" ]; then
        header="$header TAG"
    fi
    echo -e "${YELLOW}${header}${ENDCOLOR}"
    echo
    if [ -n "$help" ]; then
        echo -e "usage: ${YELLOW}gitb branch <mode>${ENDCOLOR}"
        echo
        echo -e "${YELLOW}Available modes${ENDCOLOR}"
        echo -e "<empty>\t\tSelect a local branch to switch"
        echo -e "list|l\t\tPrint a list of local branches"
        echo -e "remote|re|r\tFetch $origin_name and select a remote branch to switch"
        echo -e "main|def|m\tSwitch to $main_branch without additional confirmations"
        echo -e "tag|t\t\tCheckout to a specific tag"
        echo -e "new|n|c\t\tBuild a conventional name and create a new branch from $main_branch"
        echo -e "newd|nd\t\tBuild a conventional name, switch to $main_branch, pull it and create new branch"
        echo -e "delete|del|d\tSelect a local branch to delete"
        echo -e "help|h\t\tShow this help"
        exit
    fi
    if [[ -n "${main}" ]]; then
        switch ${main_branch}
        exit
    fi
    if [[ -n "${tag}" ]]; then
        echo -e "${YELLOW}Do you want to fetch remote tags first?${ENDCOLOR}"
        read -n 1 -p "Fetch remote? (y/n) " choice
        echo
        if [ "$choice" = "y" ] || [ "$choice" = "Y" ]; then
            echo
            echo -e "${YELLOW}Fetching remote tags...${ENDCOLOR}"
            fetch_output=$(git fetch --tags 2>&1)
            check_code $? "$fetch_output" "fetch remote tags"
        fi
        echo
        echo -e "${YELLOW}Select a tag to checkout:${ENDCOLOR}"
        tags_info_str=$(git for-each-ref --count=999  --sort=-creatordate refs/tags --format="${BLUE_ES}%(refname:short)${ENDCOLOR_ES} | %(contents:subject) | ${YELLOW_ES}%(objectname:short)${ENDCOLOR_ES} | ${CYAN_ES}%(creatordate:human)${ENDCOLOR_ES}" | column -ts'|' )
        IFS=$'\n' read -rd '' -a tags_info <<<"$tags_info_str"
        if [ -z "$tags_info" ]; then
            echo -e "${RED}No tags found in this repository${ENDCOLOR}"
            exit
        fi
        for index in "${!tags_info[@]}"; do
            echo -e "$(($index+1)). ${tags_info[index]}"
        done
        echo "0. Exit without changes"
        echo
        while [ true ]; do
            read -p "Select tag number: " choice
            if [ "$choice" == "0" ] || [ "$choice" == "" ]; then
                exit
            fi
            re='^[1-9][0-9]*$'
            if [[ $choice =~ $re ]]; then
                index=$((choice - 1))
                if [ $index -ge 0 ] && [ $index -lt ${#tags_info[@]} ]; then
                    selected_tag=$(git for-each-ref --count=999 --sort=-creatordate refs/tags --format='%(refname:short)' | sed -n "$((index+1))p")
                    break
                else
                    echo -e "${RED}Invalid tag number! Please choose from 1-${#tags_info[@]}.${ENDCOLOR}"
                    echo
                    continue
                fi
            else
                echo -e "${RED}Please enter a valid tag number.${ENDCOLOR}"
                echo
                continue
            fi
        done
        echo
        echo -e "${YELLOW}Checking out to tag ${selected_tag}...${ENDCOLOR}"
        echo
        checkout_output=$(git checkout $selected_tag 2>&1)
        checkout_code=$?
        if [ $checkout_code -eq 0 ]; then
            echo -e "${GREEN}Successfully checked out to tag '${selected_tag}'${ENDCOLOR}"
            echo -e "${YELLOW}Note: You are now in 'detached HEAD' state${ENDCOLOR}"
            echo -e "If you want to make changes, create a new branch: ${YELLOW}gitb branch new${ENDCOLOR}"
        else
            echo -e "${RED}Failed to checkout to tag ${selected_tag}! Error message:${ENDCOLOR}"
            echo "${checkout_output}"
            exit $checkout_code
        fi
        exit
    fi
    if [[ -z "$new" ]] && [[ -z "$remote" ]] && [[ -z "$delete" ]] && [[ -z "$list" ]] && [[ -z "$tag" ]]; then
        echo -e "${YELLOW}Select a branch to switch from '${current_branch}'${ENDCOLOR}:"
        choose_branch
        echo
        switch ${branch_name}
        exit
    elif [[ -z "$new" ]] && [[ -n "$remote" ]] && [[ -z "$delete" ]] && [[ -z "$tag" ]]; then
        echo -e "${YELLOW}Fetching remote...${ENDCOLOR}"
        echo
        fetch_output=$(git fetch 2>&1)
        check_code $? "$fetch_output" "fetch remote"
        prune_output=$(git remote prune $origin_name 2>&1)
        echo -e "${YELLOW}Switch from '${current_branch}' to the remote branch${ENDCOLOR}"
        choose_branch "remote"
        echo
        switch ${branch_name}
        exit
    elif [[ -z "$new" ]] && [[ -n "$delete" ]] && [[ -z "$tag" ]]; then
        IFS=$'\n' read -rd '' -a merged_branches <<<"$(git branch -v --sort=-committerdate --merged | cat 2>&1)"
        merged_branches_without_main=()
        for index in "${!merged_branches[@]}"
        do
            branch_with_info="$(echo "${merged_branches[index]}" | sed -e 's/^[[:space:]]*//')"
            if [[ ${branch_with_info} != "${main_branch}"* ]] && [[ ${branch_with_info} != "*"* ]] ; then
                merged_branches_without_main+=("$branch_with_info")
            fi
        done
        number_of_branches=${#merged_branches_without_main[@]}
        if [ $number_of_branches != 0 ]; then
            echo -e "${YELLOW}Do you want to delete merged local branches?${ENDCOLOR}"
            echo -e "These are branches without new changes regarding ${YELLOW}${main_branch}${ENDCOLOR}"
            for index in "${!merged_branches_without_main[@]}"
            do
                printf "\t${merged_branches_without_main[index]}\n"
            done
            printf "\nAnswer (y/n): "
            while [ true ]; do
                read -n 1 -s choice
                if [ "$choice" == "y" ]; then
                    printf "y\n\n"
                    branches_to_delete="$(git branch --merged | egrep -v "(^\*|master|main|develop|${main_branch})" | xargs)"
                    IFS=$' ' read -rd '' -a branches <<<"$branches_to_delete"
                    for index in "${!branches[@]}"
                    do
                        branch_to_delete="$(echo "${branches[index]}" | xargs)"
                        delete_output=$(git branch -d $branch_to_delete 2>&1)
                        delete_code=$?
                        if [ $delete_code == 0 ]; then
                            echo -e "${GREEN}Branch '$branch_to_delete' is deleted!${ENDCOLOR}"
                        else
                            echo -e "${RED}Cannot delete branch '$branch_to_delete'!${ENDCOLOR}"
                            echo -e "${delete_output}"
                            break
                        fi
                    done
                    echo
                    break
                else
                    printf "n\n\n"
                    break
                fi
            done
        fi
        echo -e "${YELLOW}Delete a local branch${ENDCOLOR}"
        choose_branch "delete"
        echo
        delete_output=$(git branch -d $branch_name 2>&1)
        delete_code=$?
        if [ "$delete_code" == 0 ]; then
            echo -e "${GREEN}Branch '$branch_name' is deleted!${ENDCOLOR}"
        elif [[ ${delete_output} == *"is not fully merged"* ]]; then
            echo -e "${RED}The branch '$branch_name' is not fully merged${ENDCOLOR}"
            echo "Do you want to force delete (-D flag) this branch?"
            printf "Answer (y/n): "
            while [ true ]; do
                read -n 1 -s choice
                if [ "$choice" == "y" ]; then
                    printf "y\n\n"
                    delete_output=$(git branch -D $branch_name 2>&1)
                    delete_code=$?
                    if [ "$delete_code" != 0 ]; then
                        echo -e "${RED}Cannot delete branch '$branch_name'! Error message:${ENDCOLOR}"
                        echo -e "${delete_output}"
                        exit
                    fi
                    echo -e "${GREEN}Branch '$branch_name' is deleted!${ENDCOLOR}"
                    break
                elif [ "$choice" == "n" ]; then
                    printf "n\n"
                    exit
                fi
            done
        else
            echo -e "${RED}Cannot delete branch '$branch_name'! Error message:${ENDCOLOR}"
            echo -e "${delete_output}"
            exit
        fi
        remote_check=$(git --no-pager log $origin_name/$branch_name..HEAD 2>&1)
        if [[ $remote_check != *"unknown revision or path not in the working tree"* ]]; then
            echo
            echo -e "${YELLOW}Do you want to delete this branch in the remote?${ENDCOLOR}"
            printf "Answer (y/n): "
            while [ true ]; do
                read -n 1 -s choice
                if [ "$choice" == "y" ]; then
                    printf "y\n\n"
                    echo -e "${YELLOW}Deleting...${YELLOW}"
                    push_output=$(git push $origin_name -d $branch_name 2>&1)
                    push_code=$?
                    echo
                    if [ "$push_code" != 0 ]; then
                        echo -e "${RED}Cannot delete branch '$branch_name'! Error message:${ENDCOLOR}"
                        echo -e "${delete_output}"
                        exit
                    fi
                    echo -e "${GREEN}Branch '$branch_name' is deleted in the remote!${ENDCOLOR}"
                    break
                elif [ "$choice" == "n" ]; then
                    printf "n\n"
                    exit
                fi
            done
        fi
        exit
    fi
    if [ -n "$current" ]; then
        echo -e "${YELLOW}Current local branches:${ENDCOLOR}"
        list_branches
    else
         echo -e "It will switch to ${BOLD}${BLUE}${main_branch}${ENDCOLOR} and pull it first"
    fi
    if [ -n "$list" ]; then
        exit
    fi
    echo
    detected_prefixes=""
    all_branches=$(git branch -a --format='%(refname:short)' 2>/dev/null | sed 's|origin/||g' | sort -u)
    if [ -n "$all_branches" ]; then
        declare -A prefix_candidates
        while IFS= read -r branch; do
            if [ -n "$branch" ] && [[ "$branch" != "$main_branch" ]] && [[ "$branch" != "HEAD" ]]; then
                if [[ "$branch" =~ ^([a-zA-Z0-9]+)[-_/](.+)$ ]]; then
                    prefix="${BASH_REMATCH[1]}"
                    if [[ ${#prefix} -ge 2 ]] && [[ ! "$prefix" =~ ^(dev|tmp|old|new|test)$ ]]; then
                        prefix_candidates["$prefix"]=1
                    fi
                fi
            fi
        done <<< "$all_branches"
        detected_prefixes_array=()
        for prefix in "${!prefix_candidates[@]}"; do
            detected_prefixes_array+=("$prefix")
        done
        if [ ${#detected_prefixes_array[@]} -gt 0 ]; then
            IFS=$'\n' detected_prefixes_sorted=($(sort <<<"${detected_prefixes_array[*]}"))
            unset IFS
            detected_prefixes="${detected_prefixes_sorted[*]}"
        fi
    fi
    all_prefixes=""
    if [ -n "$ticket_name" ]; then
        if [ -n "$detected_prefixes" ]; then
            all_prefixes="$ticket_name $detected_prefixes"
        else
            all_prefixes="$ticket_name"
        fi
    elif [ -n "$detected_prefixes" ]; then
        all_prefixes="$detected_prefixes"
    fi
    branch_type=""
    branch_type_and_sep=""
    if [ -z "$all_prefixes" ]; then
        echo -e "${YELLOW}Step 1.${ENDCOLOR} Enter the full name of the branch"
        echo "Press Enter if you want to exit"
        printf "${BOLD}git branch${ENDCOLOR} "
        read -e branch_name
        if [ -z "$branch_name" ]; then
            exit
        fi
        if ! sanitize_git_name "$branch_name"; then
            show_sanitization_error "branch name" "Use only letters, numbers, dots, dashes, underscores, and slashes."
            exit 1
        fi
        branch_name="$sanitized_git_name"
    else
        branch_to_show=$current_branch
        if [ -z "$current" ]; then
            branch_to_show=$main_branch
        fi
        echo -e "${YELLOW}Step 1.${ENDCOLOR} Enter a ${YELLOW}prefix${ENDCOLOR} for your new branch from ${BOLD}${BLUE}${branch_to_show}${ENDCOLOR}"
        echo -e "A branch will be created with '${YELLOW}${sep}${ENDCOLOR}' as a separator (e.g., ${YELLOW}prefix${sep}name${ENDCOLOR})"
        echo -e "Press Enter to continue without prefix or enter 0 to exit without changes"
        IFS=' ' read -r -a prefixes_array <<< "$all_prefixes"
        declare -A prefixes_map
        res=""
        for i in "${!prefixes_array[@]}"; do
            option=$((i+1))
            prefixes_map["$option"]="${prefixes_array[$i]}"
            res="$res$option. ${BOLD}${prefixes_array[$i]}${ENDCOLOR}|"
        done
        no_prefix_option=$((${#prefixes_array[@]}+1))
        prefixes_map["$no_prefix_option"]=""
        echo -e "You can select one of the ${YELLOW}detected prefixes${ENDCOLOR}: $(echo $res | column -ts'|')"
        while [ true ]; do
            read -p "<prefix>: " choice
            if [ "$choice" == "0" ]; then
                exit
            fi
            if [ "$choice" == "" ]; then
                branch_type=""
                branch_type_and_sep=""
                break
            fi
            re='^[1-9][0-9]*$'
            if [[ $choice =~ $re ]] && [ -n "${prefixes_map[$choice]+isset}" ]; then
                branch_type="${prefixes_map[$choice]}"
                if [ -n "$branch_type" ]; then
                    branch_type_and_sep="${branch_type}${sep}"
                fi
                break
            else
                if [ -n "$choice" ]; then
                    if ! sanitize_git_name "$choice"; then
                        show_sanitization_error "branch prefix" "Use only letters, numbers, dots, dashes, underscores, and slashes."
                        echo
                        continue
                    fi
                    branch_type="$sanitized_git_name"
                    branch_type_and_sep="${branch_type}${sep}"
                    break
                else
                    echo -e "${RED}Please enter a valid option number or custom prefix.${ENDCOLOR}"
                    echo
                    continue
                fi
            fi
        done
        echo
        echo -e "${YELLOW}Step 2.${ENDCOLOR} Enter the ${YELLOW}name${ENDCOLOR} of the branch"
        echo "Press Enter if you want to exit"
        printf "${BOLD}git branch${ENDCOLOR}"
        read -p " ${branch_type_and_sep}" -e branch_name
        if [ -z "$branch_name" ]; then
            exit
        fi
        if ! sanitize_git_name "$branch_name"; then
            show_sanitization_error "branch name" "Use only letters, numbers, dots, dashes, underscores, and slashes."
            exit 1
        fi
        branch_name="${branch_type_and_sep}${sanitized_git_name}"
    fi
    if [[ "$branch_name" == "HEAD" ]] || [[ "$branch_name" == "$origin_name" ]]; then
        echo
        echo -e "${RED}This name is forbidden${ENDCOLOR}"
        exit
    fi
    from_branch=$current_branch
    if [ -z "${current}" ]; then
        echo
        switch $main_branch "true"
        echo -e "${YELLOW}Pulling '$origin_name/$main_branch'...${ENDCOLOR}"
        echo
        pull $main_branch $origin_name $editor
        from_branch=$main_branch
    fi
    create_output=$(git switch -c $branch_name 2>&1)
    create_code=$?
    echo
    if [ $create_code -eq 0 ]; then
        echo -e "${GREEN}${create_output} from '$from_branch'${ENDCOLOR}"
        changes=$(git_status)
        if [ -n "$changes" ]; then
            echo
            echo -e "${YELLOW}Moved changes:${ENDCOLOR}"
            echo -e "${changes}"
        fi
        exit
    fi
    if [[ $create_output == *"already exists"* ]]; then
        echo -e "${RED}Branch with name '${branch_name}' already exists!${ENDCOLOR}"
        exit $create_code
    fi
    echo -e "${RED}Cannot create '${branch_name}'! Error message:${ENDCOLOR}"
    echo "${create_output}"
    exit $create_code
}
function push_tag {
    if [ -z "$1" ] || [ "$1" == "" ]; then
        all="true"
        push_output=$(git push $origin_name --tags 2>&1)
    elif [ -n "$2" ]; then
        push_output=$(git push --delete $origin_name $1 2>&1)
    else
        push_output=$(git push $origin_name $1 2>&1)
    fi
    push_code=$?
    if [ -n "$delete" ]; then
        if [[ "$push_output" == *"remote ref does not exist"* ]]; then
            echo -e "${RED}Tag '$1' doesn't exist in the ${origin_name}${ENDCOLOR}"
            exit
        fi
        echo -e "${GREEN}Tag '$1' is deleted from the ${origin_name}!${ENDCOLOR}"
        exit
    fi
    repo=$(get_repo)
    if [ -n "$all" ]; then
        echo
        IFS=$'\n' read -rd '' -a lines_with_success <<< "$(sed -n '/\[new tag\]/p' <<< "$push_output")"
        number_of_tags=${#lines_with_success[@]}
        if [ $number_of_tags != 0 ]; then
            echo -e "${GREEN}Pushed successfully!${ENDCOLOR}"
            for index in "${!lines_with_success[@]}"
            do
                echo -e "\t$(sed -e 's#.*\-> \(\)#\1#' <<< "${lines_with_success[index]}" )"
            done
            echo
        fi
    fi
    if [ $push_code != 0 ] ; then
        if [[ "$push_output" == *"Updates were rejected because the tag already exists in the remote"* ]]; then
            echo -e "${RED}Some tags were rejected${ENDCOLOR}"
            IFS=$'\n' read -rd '' -a lines_with_rejected <<< "$(sed -n '/\[rejected\]/p' <<< "$push_output")"
            for index in "${!lines_with_rejected[@]}"
            do
                echo -e "\t$(sed -e 's#.*\-> \(\)#\1#' <<< "${lines_with_rejected[index]}" )"
            done
            echo
            echo -e "${YELLOW}Repo:${ENDCOLOR} ${repo}"
            exit
        fi
        echo -e "${RED}Cannot push! Error message:${ENDCOLOR}"
        echo "$push_output"
        exit $push_code
    fi
    if [[ $push_output == *"Everything up-to-date"* ]]; then
        echo -e "${GREEN}Everything up-to-date${ENDCOLOR}"
    elif [ -z "$all" ]; then
        echo -e "${GREEN}Successful push tag '$1'!${ENDCOLOR}"
    else
        echo -e "${GREEN}Successful push all local tags!${ENDCOLOR}"
    fi
    echo -e "${YELLOW}Repo:${ENDCOLOR}\t${repo}"
    if [ -z "$all" ]; then
        if [[ $repo == *"github"* ]]; then
            echo -e "${YELLOW}Tag:${ENDCOLOR}\t${repo}/releases/tag/$1"
        elif [[ $repo == *"gitlab"* ]]; then
            echo -e "${YELLOW}Tag:${ENDCOLOR}\t${repo}/-/tags/$1"
        fi
    fi
}
function tag_script {
    case "$1" in
        annotated|a|an)     annotated="true";;
        commit|c|co|cm)     select="true"; commit="true";;
        all|al)             select="true"; annotated="true";;
        push|ps|ph|p)       push="true"; select="true";;
        push-all|pa)        push="true";;
        delete|del|d)       delete="true"; select="true";;
        delete-all|da)      delete="true";;
        list|log|l)         list="true";;
        remote|re|r|fetch)  list="true"; remote="true";;
        help|h)             help="true";;
        *)
            wrong_mode "tag" $1
    esac
    header="GIT TAG"
    if [ -n "${annotated}" ] && [ -n "${commit}" ]; then
        header="$header ALL"
    elif [ -n "${annotated}" ]; then
        header="$header ANNOTATED"
    elif [ -n "${commit}" ]; then
        header="$header COMMIT"
    elif [ -n "${push}" ] && [ -n "${select}" ]; then
        header="$header PUSH"
    elif [ -n "${push}" ]; then
        header="$header PUSH ALL"
    elif [ -n "${delete}" ] && [ -n "${select}" ]; then
        header="$header DELETE"
    elif [ -n "${delete}" ]; then
        header="$header DELETE ALL"    
    elif [ -n "${list}" ]; then
        header="$header LIST"
    elif [ -n "${remote}" ]; then
        header="$header REMOTE"
    fi
    echo -e "${YELLOW}${header}${ENDCOLOR}"
    echo
    if [ -n "$help" ]; then
        echo -e "usage: ${YELLOW}gitb tag <mode>${ENDCOLOR}"
        echo
        echo -e "${YELLOW}Available modes${ENDCOLOR}"
        echo -e "<empty>\t\tCreate a new tag from the last commit"
        echo -e "annotated|a|an\tCreate a new annotated tag from the last commit"
        echo -e "commit|c|co|cm\tCreate a new tag from a selected commit"
        echo -e "all|al\t\tCreate a new annotated tag from a selected commit"
        echo -e "push|ps|ph|p\tSelect a local tag and push it to the remote repository"
        echo -e "push-all|pa\tPush all tags to the remote repository"
        echo -e "delete|del|d\tSelect a tag to delete"
        echo -e "delete-all|da\tDelete all local tags"
        echo -e "list|log|l\tPrint a list of local tags"
        echo -e "remote|fetch|r\tFetch tags from the remote repository and print it"
        echo -e "help|h\t\tShow this help"
        exit
    fi
    if [ -n "${remote}" ]; then
        echo -e "${YELLOW}Fetching tags from the remote...${ENDCOLOR}"
        fetch_output=$(git fetch $origin_name --tags 2>&1)
        check_code $? "$fetch_output" "fetch tags"
        echo
        if [ "$fetch_output" != "" ]; then
            echo -e "${YELLOW}New tags:${ENDCOLOR}"
            IFS=$'\n' read -rd '' -a lines_with_tags <<< "$(sed -n '/\[new tag\]/p' <<< "$fetch_output")"
            for index in "${!lines_with_tags[@]}"
            do
                echo -e "\t$(sed -e 's#.*\-> \(\)#\1#' <<< "${lines_with_tags[index]}" )"
            done
            echo
        fi
    fi
    count=9
    if [ -n "${delete}" ] || [ -n "${push}" ] || [ -n "${list}" ]; then
        count=999  # Show all tags
    fi
    tags_info_str=$(git for-each-ref --count=$count  --sort=-creatordate refs/tags --format="${BLUE_ES}%(refname:short)${ENDCOLOR_ES} | %(contents:subject) | ${YELLOW_ES}%(objectname:short)${ENDCOLOR_ES} | ${CYAN_ES}%(creatordate:human)${ENDCOLOR_ES}" | column -ts'|' )
    IFS=$'\n' read -rd '' -a tags_info <<<"$tags_info_str"
    number_of_tags=${#tags_info[@]}
    if [ $number_of_tags == 0 ]; then
        echo -e "${YELLOW}There is no local tags${ENDCOLOR}"
        if [ -n "${delete}" ] || [ -n "${push}" ]; then
            exit
        fi
    else
        tags_header="Last ${number_of_tags} local tags"
        if [ -n "${delete}" ] || [ -n "${list}" ]; then
            tags_header="All ${number_of_tags} local tags"
        fi
        echo -e "${YELLOW}${tags_header}${ENDCOLOR}"
        for index in "${!tags_info[@]}"
        do  
            tag_line="${tags_info[index]}"
            if [ -n "${delete}" ] || [ -n "${push}" ]; then
                echo -e "$(($index+1)). ${tag_line}"
            else
                echo -e "${tag_line}"
            fi
        done
    fi
    if [ -n "$list" ]; then
        exit
    fi
    if [ -n "$push" ] && [ -z "$select" ]; then
        echo
        echo -e "${YELLOW}Pushing all tags..."${ENDCOLOR}
        push_tag
        exit
    fi
    if [ -n "${delete}" ] && [ -z "$select" ]; then
        echo
        echo -e "${YELLOW}Do you really want to delete all local tags (y/n)?${ENDCOLOR}"
        git tag | xargs git tag -d 
        exit
    fi
    if [ -n "${delete}" ] || [ -n "$push" ]; then
        if [ $number_of_tags -gt 9 ]; then
            echo "00. Exit"
        else
            echo "0. Exit"
        fi
        echo
        if [ -n "${delete}" ]; then
            read_prefix="Enter tag number to delete: "
        else
            read_prefix="Enter tag number to push: "
        fi
        IFS=$'\n' read -rd '' -a tags <<<"$(git for-each-ref --count=$count  --sort=-creatordate refs/tags --format="%(refname:short)")"
        choose "${tags[@]}"
        tag_name=$choice_result
        echo
        if [ -n "${push}" ]; then
            echo -e "${YELLOW}Pushing..."${ENDCOLOR}
            echo
            push_tag $tag_name
            exit
        fi
        delete_result=$(git tag -d $tag_name 2>&1)
        check_code $? "$delete_result" "delete tag"
        echo -e "${GREEN}Successfully deleted tag '${tag_name}'!${ENDCOLOR}"
        echo
        echo -e "Do you want to delete this tag in the ${YELLOW}${origin_name}${ENDCOLOR} (y/n)?"
        yes_no_choice "\nDeleting..."
        push_tag $tag_name "true"
        exit
    fi
    echo
    if [ -n "$select" ]; then
        echo -e "${YELLOW}Select a commit for a new tag on branch '$current_branch'${ENDCOLOR}"
        choose_commit 9
        echo
        echo -e "${YELLOW}Selected commit${ENDCOLOR}"
    else
        commit_hash=$(git rev-parse HEAD)
        echo -e "${YELLOW}Last branch commit${ENDCOLOR}"
    fi
    commit_message=$(git log -1 --pretty=%B $commit_hash | cat)
    echo -e "${BLUE}[$current_branch ${commit_hash::7}]${ENDCOLOR} ${commit_message}"
    echo
    echo -e "${YELLOW}Enter the name for a new tag${ENDCOLOR}"
    echo -e "If this is a release tag, use version number in semver format like '1.0.0-alpha'"
    echo -e "Press Enter if you want to exit"
    if [ -n "${annotated}" ]; then
        prompt="$(echo -n -e "${BOLD}git tag -a${ENDCOLOR} ")"
    else
        prompt="$(echo -n -e "${BOLD}git tag${ENDCOLOR} ")"
    fi
    read -p "$prompt" -e tag_name
    if [ -z "$tag_name" ]; then
        exit
    fi
    if ! sanitize_git_name "$tag_name"; then
        show_sanitization_error "tag name" "Use only letters, numbers, dots, dashes, underscores, and slashes."
        exit 1
    fi
    tag_name="$sanitized_git_name"
    if [[ "$tag_name" == "tag" ]]; then
        echo
        echo -e "${RED}This name is forbidden!${ENDCOLOR}"
        exit
    fi
    if [ -n "$annotated" ]; then
        tag_file=".tagmsg__"
        touch $tag_file
        echo """
####
#### Write some words about the new tag '${tag_name}'
#### [$current_branch ${commit_hash::7}] ${commit_message}
#### 
#### You can place changelog here if this tag for a new release
""" >> $tag_file
        while [ true ]; do
            $editor $tag_file
            tag_message=$(cat $tag_file | sed '/^#/d')
            if [ -n "$tag_message" ]; then
                break
            fi
            echo
            echo -e "${YELLOW}Tag message cannot be empty${ENDCOLOR}"
            echo
            read -n 1 -p "Do you want to try for one more time? (y/n) " -s -e choice
            if [ "$choice" != "y" ]; then
                find . -name "$tag_file*" -delete
                exit
            fi    
        done
        find . -name "$tag_file*" -delete
    fi
    if [ -z "$select" ]; then
        commit_hash=""
    fi
    echo
    if [ -n "$annotated" ]; then
        tag_output=$(git tag -a -m """$tag_message""" $tag_name $commit_hash 2>&1)
    else
        tag_output=$(git tag $tag_name $commit_hash 2>&1)
    fi
    tag_code=$?
    if [ $tag_code != 0 ]; then
        if [[ $tag_output == *"already exists" ]]; then
            echo -e "${RED}Tag '${tag_name}' already exists!${ENDCOLOR}"
        else
            echo -e "${RED}Cannot create tag '${tag_name}'! Error message:${ENDCOLOR}"
            echo -e "$tag_output"
        fi
        exit
    fi
    if [ -n "$annotated" ]; then
        is_annotated=" annotated"
    fi
    if [ -n "$select" ]; then
        is_commit_hash=" from commit '${commit_hash}'"
    fi
    echo -e "${GREEN}Successfully created${is_annotated} tag '${tag_name}'${is_commit_hash}!${ENDCOLOR}"
    if [ -n "$tag_message" ]; then
        echo -e "$tag_message"
    fi
    echo
    echo -e "Do you want to push it to the ${YELLOW}${origin_name}${ENDCOLOR} (y/n)?"
    yes_no_choice "\nPushing..."
    push_tag $tag_name
}
function reset_script {
    case "$1" in
        soft|s)         soft="true";;
        undo|u)         undo="true";;
        interactive|i)  interactive="true";;
        ref|r)          
            ref="true"
            interactive="true"
        ;;
        help|h) help="true";;
        *)
            wrong_mode "reset" $1
    esac
    header="GIT RESET"
    if [ -n "${ref}" ]; then
        header="$header REFERENCE"
    elif [ -n "${undo}" ]; then
        header="$header UNDO"
    elif [ -n "${soft}" ]; then
        header="$header --soft"
    elif [ -n "${help}" ]; then
        header="$header"
    else
        header="$header --mixed"
    fi
    echo -e "${YELLOW}${header}${ENDCOLOR}"
    echo
    if [ -n "$help" ]; then
        echo -e "usage: ${YELLOW}gitb reset <mode>${ENDCOLOR}"
        echo
        echo -e "${YELLOW}Available modes${ENDCOLOR}"
        echo -e "<empty>\t\tReset last commit (git reset HEAD^ --mixed)"
        echo -e "soft|s\t\tReset last commit, but remain all fiels staged (git reset HEAD^ --soft)"
        echo -e "undo|u\t\tUndo last commit reset (git reset HEAD@{1})"
        echo -e "interactive|i\tSelect a commit to reset"
        echo -e "ref|r\t\tSelect a HEAD reference to reset"
        echo -e "help|h\t\tShow this help"
        exit
    fi
    cancelled_commit=$(git log -n 1 --pretty="%s | ${YELLOW}%h${ENDCOLOR} | ${CYAN}%cd${ENDCOLOR} (${GREEN}%cr${ENDCOLOR})")
    cancelled_action=$(git reflog -n 1 --pretty="%gs | ${YELLOW}%h${ENDCOLOR} |  ${CYAN}%cd${ENDCOLOR} (${GREEN}%cr${ENDCOLOR})")
    if [ -n "$interactive" ]; then
        if [ -n "$ref" ]; then
            echo -e "${YELLOW}Select a ref to move into:${ENDCOLOR}"
            ref_list 31
            echo "0. Exit..."
            echo
            printf "Enter ref number: "
            choose "${refs_hash[@]}"
            commit_hash=$choice_result
            echo
        else
            echo -e "${YELLOW}Select a commit to reset:${ENDCOLOR}"
            choose_commit 9
        fi
    fi
    move_ref="HEAD^"
    if [ -n "$undo" ]; then
        move_ref="HEAD@{1}"
    elif [ -n "$commit_hash" ]; then
        move_ref=$commit_hash
    fi
    args="--mixed"
    if [ -n "$soft" ]; then
        args="--soft"
    fi
    reset_output=$(git reset $args $move_ref 2>&1)
    check_code $? "$reset_output" "reset"
    new_commit=$(git log -n 1 --pretty="%s | ${YELLOW}%h${ENDCOLOR} | ${CYAN}%cd${ENDCOLOR} (${GREEN}%cr${ENDCOLOR})")
    new_action=$(git reflog -n 1 --pretty="%gs | ${YELLOW}%h${ENDCOLOR} | ${CYAN}%cd${ENDCOLOR} (${GREEN}%cr${ENDCOLOR})")
    msg="${GREEN}New last commit:${ENDCOLOR}|${new_commit}"
    if [ -n "$ref" ] || [ -n "$undo" ]; then
        msg="${msg}\n${GREEN}New last action:${ENDCOLOR}|${new_action}"
    fi
    msg="${msg}\n${RED}Cancelled commit:${ENDCOLOR}|${cancelled_commit}"
    if [ -n "$ref" ] || [ -n "$undo" ]; then
        msg="${msg}\n${RED}Cancelled action:${ENDCOLOR}|${cancelled_action}"
    fi
    msg=$(echo -e "$msg" | column -ts'|')
    echo -e "$msg"
    echo
    echo -e "${YELLOW}Status after reset${ENDCOLOR}"
    git_status
    exit
}
function select_files_for_stash {
    echo -e "${YELLOW}Select files to stash:${ENDCOLOR}"
    echo
    git_status
    echo
    echo -e "Enter file patterns or paths to stash (like ${BOLD}git add${ENDCOLOR} command)"
    echo "Press Enter if you want to exit"
    while [ true ]; do
        read -p "$(echo -n -e "${BOLD}files to stash${ENDCOLOR} ")" -e git_add
        if [ "$git_add" == "" ]; then
            exit
        fi
        if ! sanitize_file_path "$git_add"; then
            show_sanitization_error "file pattern" "Invalid file path or pattern. Avoid dangerous characters and sequences."
            continue
        fi
        git_add="$sanitized_file_path"
        test_result=$(git add --dry-run "$git_add" 2>&1)
        test_code=$?
        if [ $test_code -eq 0 ] && [ -n "$test_result" ]; then
            break
        else
            if [[ "$test_result" == *"did not match any files"* ]] && [[ "$git_add" != *"*" ]]; then
                git_add_with_star="${git_add}*"
                echo -e "${YELLOW}Trying with wildcard:${ENDCOLOR} ${BOLD}$git_add_with_star${ENDCOLOR}"
                test_result_star=$(git add --dry-run "$git_add_with_star" 2>&1)
                if [ $? -eq 0 ] && [ -n "$test_result_star" ]; then
                    git_add="$git_add_with_star"
                    break
                else
                    echo -e "${RED}No changed files match pattern: $git_add_with_star${ENDCOLOR}"
                    echo
                fi
            else
                echo -e "${RED}No changed files match pattern: $git_add${ENDCOLOR}"
                echo
            fi
        fi
    done
}
function list_stashes {
    IFS=$'\n' read -rd '' -a stashes_info <<<"$(git stash list --pretty=format:"${YELLOW_ES}%gd${ENDCOLOR_ES} | %s | ${BLUE_ES}%cr${ENDCOLOR_ES}")"
    IFS=$'\n' read -rd '' -a stashes_refs <<<"$(git stash list --pretty=format:"%gd")"
    if [ ${#stashes_info[@]} -eq 0 ]; then
        echo -e "${GREEN}No stashes found${ENDCOLOR}"
        return 1
    fi
    echo -e "${YELLOW}Available stashes:${ENDCOLOR}"
    echo
    for index in "${!stashes_info[@]}"; do
        stash_line="${stashes_info[index]}"
        formatted_line=$(echo "$stash_line" | sed 's/ | /\t/g')
        echo -e "$(($index+1)). $formatted_line"
    done
    echo
    return 0
}
function choose_stash {
    if ! list_stashes; then
        return 1
    fi
    if [ ${#stashes_refs[@]} -gt 9 ]; then
        echo "00. Exit"
    else
        echo "0. Exit"
    fi
    echo
    read_prefix="Select stash number: "
    choose "${stashes_refs[@]}"
    echo
    selected_stash=$choice_result
}
function show_stash {
    echo -e "${YELLOW}Stash details for $1${ENDCOLOR}"
    echo
    git stash show -p "$1"
}
function stash_script {
    case "$1" in
        select|sel)     select_mode="true";;
        all)            all_mode="true";;
        list|l)         list_mode="true";;
        pop|p)          pop_mode="true";;
        show|s)         show_mode="true";;
        drop|d)         drop_mode="true";;
        apply|a)        apply_mode="true";;
        help|h)         help="true";;
        *)
            if [ -n "$1" ]; then
                wrong_mode "stash" "$1"
            fi
            interactive="true"
    esac
    header_msg="GIT STASH"
    if [ -n "${select_mode}" ]; then
        header_msg="${YELLOW}$header_msg SELECT${ENDCOLOR}"
    elif [ -n "${all_mode}" ]; then
        header_msg="${YELLOW}$header_msg ALL${ENDCOLOR}"
    elif [ -n "${list_mode}" ]; then
        header_msg="${YELLOW}$header_msg LIST${ENDCOLOR}"
    elif [ -n "${pop_mode}" ]; then
        header_msg="${YELLOW}$header_msg POP${ENDCOLOR}"
    elif [ -n "${show_mode}" ]; then
        header_msg="${YELLOW}$header_msg SHOW${ENDCOLOR}"
    elif [ -n "${drop_mode}" ]; then
        header_msg="${RED}$header_msg DROP${ENDCOLOR}"
    elif [ -n "${apply_mode}" ]; then
        header_msg="${YELLOW}$header_msg APPLY${ENDCOLOR}"
    else
        header_msg="${YELLOW}$header_msg${ENDCOLOR}"
    fi
    echo -e "${header_msg}"
    echo
    if [ -n "$help" ]; then
        echo -e "usage: ${YELLOW}gitb stash <mode>${ENDCOLOR}"
        echo
        echo -e "${YELLOW}Available modes${ENDCOLOR}"
        echo -e "<empty>\t\tShow interactive menu"
        echo -e "select|sel\tSelect files to stash"
        echo -e "all\t\tStash all changes"
        echo -e "list|l\t\tList all stashes"
        echo -e "pop|p\t\tPop from selected stash"
        echo -e "show|s\t\tShow stash contents"
        echo -e "apply|a\t\tApply selected stash without removing it"
        echo -e "drop|d\t\tDrop selected stash"
        echo -e "help|h\t\tShow this help"
        exit
    fi
    if [ -n "$interactive" ]; then
        echo -e "${YELLOW}What do you want to do?${ENDCOLOR}"
        echo
        echo "1. Select files to stash"
        echo "2. Stash all changes"
        echo "3. List all stashes"
        echo "4. Pop from stash"
        echo "5. Show stash contents"
        echo "6. Apply stash (without removing)"
        echo "7. Drop stash"
        echo "0. Exit"
        read -n 1 -s choice
        echo
        case "$choice" in
            1) select_mode="true";;
            2) all_mode="true";;
            3) list_mode="true";;
            4) pop_mode="true";;
            5) show_mode="true";;
            6) apply_mode="true";;
            7) drop_mode="true";;
            0) exit;;
            *) echo -e "${RED}Invalid option${ENDCOLOR}"; exit 1;;
        esac
    fi
    if [ -n "$select_mode" ]; then
        select_files_for_stash
        echo
        echo -e "${YELLOW}Changed files to stash:${ENDCOLOR}"
        files_to_stash=$(git add --dry-run "$git_add" 2>/dev/null | sed 's/^add /\t/' | sed "s/'//g")
        echo -e "${GREEN}$files_to_stash${ENDCOLOR}"
        echo
        read -p "Enter stash message: " stash_message
        if [ -z "$stash_message" ]; then
            exit 0
        fi
        if ! sanitize_text_input "$stash_message" 200; then
            show_sanitization_error "stash message" "Use printable characters only, max 200 characters."
            exit 1
        fi
        stash_message="$sanitized_text"
        echo -e "${YELLOW}Stashing selected files...${ENDCOLOR}"
        echo
        result=$(git add $git_add 2>&1)
        if [ $? -ne 0 ]; then
            echo -e "${RED}Failed to stage files! Error:${ENDCOLOR}"
            echo "$result"
            exit 1
        fi
        stash_output=$(git stash push -m "$stash_message" --staged 2>&1)
        stash_code=$?
        if [ $stash_code -eq 0 ]; then
            echo -e "${GREEN}Successfully stashed selected files!${ENDCOLOR}"
            echo "$stash_output"
        else
            echo -e "${RED}Failed to stash files! Error:${ENDCOLOR}"
            echo "$stash_output"
            git restore --staged $git_add 2>/dev/null
            exit $stash_code
        fi
    fi
    if [ -n "$all_mode" ]; then
        if git diff --quiet && git diff --cached --quiet; then
            echo -e "${GREEN}No changes to stash${ENDCOLOR}"
            exit
        fi
        read -p "Enter stash message: " stash_message
        if [ -z "$stash_message" ]; then
            exit 0
        fi
        if ! sanitize_text_input "$stash_message" 200; then
            show_sanitization_error "stash message" "Use printable characters only, max 200 characters."
            exit 1
        fi
        stash_message="$sanitized_text"
        echo -e "${YELLOW}Stashing all changes...${ENDCOLOR}"
        echo
        stash_output=$(git stash push -m "$stash_message" --include-untracked 2>&1)
        stash_code=$?
        if [ $stash_code -eq 0 ]; then
            echo -e "${GREEN}Successfully stashed all changes!${ENDCOLOR}"
            echo "$stash_output"
        else
            echo -e "${RED}Failed to stash changes! Error:${ENDCOLOR}"
            echo "$stash_output"
            exit $stash_code
        fi
    fi
    if [ -n "$list_mode" ]; then
        if ! list_stashes; then
            exit
        fi
    fi
    if [ -n "$pop_mode" ]; then
        if ! choose_stash; then
            exit 1
        fi
        echo -e "${YELLOW}Popping from stash $selected_stash...${ENDCOLOR}"
        echo
        pop_output=$(git stash pop "$selected_stash" 2>&1)
        pop_code=$?
        if [ $pop_code -eq 0 ]; then
            echo -e "${GREEN}Successfully popped from stash!${ENDCOLOR}"
            echo "$pop_output"
        else
            echo -e "${RED}Failed to pop from stash! Error:${ENDCOLOR}"
            echo "$pop_output"
            exit $pop_code
        fi
    fi
    if [ -n "$show_mode" ]; then
        if ! choose_stash; then
            exit 1
        fi
        show_stash "$selected_stash"
    fi
    if [ -n "$apply_mode" ]; then
        if ! choose_stash; then
            exit 1
        fi
        echo -e "${YELLOW}Applying stash $selected_stash...${ENDCOLOR}"
        echo
        apply_output=$(git stash apply "$selected_stash" 2>&1)
        apply_code=$?
        if [ $apply_code -eq 0 ]; then
            echo -e "${GREEN}Successfully applied stash!${ENDCOLOR}"
            echo "$apply_output"
        else
            echo -e "${RED}Failed to apply stash! Error:${ENDCOLOR}"
            echo "$apply_output"
            exit $apply_code
        fi
    fi
    if [ -n "$drop_mode" ]; then
        if ! choose_stash; then
            exit 1
        fi
        echo
        echo -e "${RED}Are you sure you want to drop stash $selected_stash? This cannot be undone!${ENDCOLOR}"
        echo -e "Do you want to continue (y/n)?"
        yes_no_choice "Dropping stash"
        drop_output=$(git stash drop "$selected_stash" 2>&1)
        drop_code=$?
        if [ $drop_code -eq 0 ]; then
            echo -e "${GREEN}Successfully dropped stash!${ENDCOLOR}"
            echo "$drop_output"
        else
            echo -e "${RED}Failed to drop stash! Error:${ENDCOLOR}"
            echo "$drop_output"
            exit $drop_code
        fi
    fi
} 
function cherry_script {
    case "$1" in
        hash|hs)                hash_mode="true"; commit_hash="$2";;
        range|r)                range_mode="true"; commit_range="$2";;
        abort|a)                abort_mode="true";;
        continue|cont|c)        continue_mode="true";;
        help|h)                 help="true";;
        *)
            if [ -n "$1" ] && [[ ! "$1" =~ ^[a-f0-9]+$ ]]; then
                wrong_mode "cherry" $1
            elif [ -n "$1" ]; then
                hash_mode="true"
                commit_hash="$1"
            else
                interactive_mode="true"
            fi
    esac
    header="GIT CHERRY-PICK"
    if [ -n "${hash_mode}" ]; then
        header="$header HASH"
    elif [ -n "${range_mode}" ]; then
        header="$header RANGE"
    elif [ -n "${abort_mode}" ]; then
        header="$header ABORT"
    elif [ -n "${continue_mode}" ]; then
        header="$header CONTINUE"
    elif [ -n "${interactive_mode}" ]; then
        header="$header INTERACTIVE"
    fi
    echo -e "${YELLOW}${header}${ENDCOLOR}"
    echo
    if [ -n "$help" ]; then
        echo -e "usage: ${YELLOW}gitb cherry <mode> [args]${ENDCOLOR}"
        echo
        echo -e "${YELLOW}Available modes${ENDCOLOR}"
        echo -e "<empty>\t\t\tInteractive mode: select commits from a branch to cherry-pick"
        echo -e "\t\t\t(Use '=' to show all commits, space-separated numbers to select multiple)"
        echo -e "hash|hs <hash>\t\tCherry-pick a specific commit by its hash"
        echo -e "range|r <from>..<to>\tCherry-pick a range of commits (e.g., abc123..def456)"
        echo -e "<commit-hash>\t\tShorthand for cherry-pick by hash"
        echo -e "abort|a\t\t\tAbort current cherry-pick operation"
        echo -e "continue|cont|c\t\tContinue cherry-pick after resolving conflicts"
        echo -e "help|h\t\t\tShow this help"
        exit
    fi
    if [ -d ".git/sequencer" ]; then
        if [ -z "${continue_mode}" ] && [ -z "${abort_mode}" ]; then
            echo -e "${YELLOW}You are in the middle of a cherry-pick operation${ENDCOLOR}"
            echo -e "Use ${GREEN}gitb cherry continue${ENDCOLOR} to continue after resolving conflicts"
            echo -e "Use ${GREEN}gitb cherry abort${ENDCOLOR} to abort the operation"
            exit 1
        fi
    fi
    if [ -n "${abort_mode}" ]; then
        if [ ! -d ".git/sequencer" ]; then
            echo -e "${YELLOW}No cherry-pick operation in progress${ENDCOLOR}"
            exit
        fi
        echo -e "${YELLOW}Aborting cherry-pick operation...${ENDCOLOR}"
        abort_output=$(git cherry-pick --abort 2>&1)
        check_code $? "$abort_output" "cherry-pick abort"
        echo -e "${GREEN}Cherry-pick operation aborted successfully${ENDCOLOR}"
        exit
    fi
    if [ -n "${continue_mode}" ]; then
        if [ ! -d ".git/sequencer" ]; then
            echo -e "${YELLOW}No cherry-pick operation in progress${ENDCOLOR}"
            exit
        fi
        if git diff --name-only --diff-filter=U | grep -q .; then
            echo -e "${RED}There are still unresolved conflicts${ENDCOLOR}"
            echo -e "${YELLOW}Conflicted files:${ENDCOLOR}"
            git diff --name-only --diff-filter=U | sed 's/^/  /'
            echo
            echo -e "Resolve conflicts and then run ${GREEN}gitb cherry continue${ENDCOLOR} again"
            exit 1
        fi
        echo -e "${YELLOW}Continuing cherry-pick operation...${ENDCOLOR}"
        continue_output=$(git cherry-pick --continue 2>&1)
        continue_code=$?
        if [ $continue_code == 0 ]; then
            echo -e "${GREEN}Cherry-pick operation completed successfully${ENDCOLOR}"
            after_cherry_pick
        else
            handle_cherry_pick_conflicts "$continue_output" $continue_code
        fi
        exit
    fi
    if [ -z "${continue_mode}" ] && [ -z "${abort_mode}" ] && [ -z "${hash_mode}" ] && [ -z "${range_mode}" ]; then
        is_clean=$(git status --porcelain)
        if [ -n "$is_clean" ]; then
            echo -e "${YELLOW}Warning: You have uncommitted changes${ENDCOLOR}"
            echo -e "Files with changes:"
            git status --porcelain | sed 's/^/  /'
            echo
            echo -e "Continue with cherry-pick? This may cause conflicts. (y/n)"
            yes_no_choice "Proceeding..."
            echo
        fi
    fi
    if [ -n "${hash_mode}" ]; then
        if [ -z "${commit_hash}" ]; then
            echo -e "${RED}No commit hash provided${ENDCOLOR}"
            echo -e "Usage: ${YELLOW}gitb cherry hash <commit-hash>${ENDCOLOR}"
            exit 1
        fi
        if ! git cat-file -e "${commit_hash}" 2>/dev/null; then
            echo -e "${RED}Invalid commit hash: ${commit_hash}${ENDCOLOR}"
            exit 1
        fi
        perform_cherry_pick "${commit_hash}"
        exit
    fi
    if [ -n "${range_mode}" ]; then
        if [ -z "${commit_range}" ]; then
            echo -e "${RED}No commit range provided${ENDCOLOR}"
            echo -e "Usage: ${YELLOW}gitb cherry range <from>..<to>${ENDCOLOR}"
            exit 1
        fi
        if [[ ! "${commit_range}" =~ \.\. ]]; then
            echo -e "${RED}Invalid range format. Use: <from>..<to>${ENDCOLOR}"
            exit 1
        fi
        perform_cherry_pick "${commit_range}"
        exit
    fi
    if [ -n "${interactive_mode}" ]; then
        echo -e "${YELLOW}Select a branch to cherry-pick commits from:${ENDCOLOR}"
        choose_branch "cherry-pick"
        source_branch=${branch_name}
        echo
        echo -e "${YELLOW}Select commits to cherry-pick from '${source_branch}':${ENDCOLOR}"
        echo -e "${GRAY}(You can select multiple commits)${ENDCOLOR}"
        echo
        choose_commits_interactive "${source_branch}"
        exit
    fi
}
function perform_cherry_pick {
    local target="$1"
    echo -e "${YELLOW}Cherry-picking ${target}...${ENDCOLOR}"
    echo
    cherry_output=$(git cherry-pick "${target}" 2>&1)
    cherry_code=$?
    if [ $cherry_code == 0 ]; then
        echo -e "${GREEN}Cherry-pick completed successfully${ENDCOLOR}"
        after_cherry_pick
    else
        handle_cherry_pick_conflicts "$cherry_output" $cherry_code
    fi
}
function handle_cherry_pick_conflicts {
    local output="$1"
    local code="$2"
    if [[ $output == *"fix conflicts and run \"git cherry-pick --continue\""* ]] || [[ $output == *"after resolving the conflicts"* ]]; then
        echo -e "${RED}Cherry-pick conflicts detected${ENDCOLOR}"
        echo
        echo -e "${YELLOW}Conflicted files:${ENDCOLOR}"
        git diff --name-only --diff-filter=U | sed 's/^/  /'
        echo
        echo -e "${YELLOW}Steps to resolve:${ENDCOLOR}"
        echo -e "1. Edit the conflicted files to resolve conflicts"
        echo -e "2. Add the resolved files: ${BLUE}git add <files>${ENDCOLOR}"
        echo -e "3. Continue cherry-pick: ${GREEN}gitb cherry continue${ENDCOLOR}"
        echo
        echo -e "Or abort the operation: ${GREEN}gitb cherry abort${ENDCOLOR}"
        return
    fi
    if [[ $output == *"The previous cherry-pick is now empty"* ]]; then
        echo -e "${YELLOW}The commit is empty after cherry-pick (changes already applied)${ENDCOLOR}"
        echo -e "Skip this commit? (y/n)"
        yes_no_choice "Skipping empty commit..."
        skip_output=$(git cherry-pick --skip 2>&1)
        if [ $? == 0 ]; then
            echo -e "${GREEN}Empty commit skipped${ENDCOLOR}"
            after_cherry_pick
        else
            echo -e "${RED}Failed to skip commit:${ENDCOLOR}"
            echo "$skip_output"
        fi
        return
    fi
    echo -e "${RED}Cherry-pick failed with error:${ENDCOLOR}"
    echo "$output"
    exit $code
}
function after_cherry_pick {
    echo
    commit_hash=$(git rev-parse HEAD)
    commit_message=$(git log -1 --pretty=%B | head -n 1)
    echo -e "${BLUE}[${current_branch} ${commit_hash::7}]${ENDCOLOR}"
    echo -e "${commit_message}"
    echo
    changes=$(git --no-pager show ${commit_hash} --stat --format="")
    if [ -n "$changes" ]; then
        print_changes_stat "$changes"
    fi
    echo
    echo -e "Push your changes: ${YELLOW}gitb push${ENDCOLOR}"
    echo -e "Undo cherry-pick: ${YELLOW}gitb reset${ENDCOLOR}"
}
function choose_commits_interactive {
    local source_branch="$1"
    local commits=()
    local commit_messages=()
    local commit_hashes=()
    local show_all=false
    mapfile -t all_commits < <(git rev-list "${current_branch}..${source_branch}" --reverse)
    if [ ${#all_commits[@]} -eq 0 ]; then
        echo -e "${YELLOW}No commits to cherry-pick from '${source_branch}'${ENDCOLOR}"
        echo -e "All commits from '${source_branch}' are already in '${current_branch}'"
        exit
    fi
    while true; do
        local max_commits=20
        if [ "$show_all" = true ] || [ ${#all_commits[@]} -le $max_commits ]; then
            commits=("${all_commits[@]}")
            if [ "$show_all" = true ]; then
                echo -e "${GRAY}Showing all ${#all_commits[@]} commits${ENDCOLOR}"
            fi
        else
            echo -e "${GRAY}Showing last ${max_commits} commits (${#all_commits[@]} total available)${ENDCOLOR}"
            commits=("${all_commits[@]: -$max_commits}")
        fi
        commit_hashes=()
        commit_messages=()
        for commit in "${commits[@]}"; do
            commit_hashes+=("$commit")
            message=$(git log -1 --pretty=format:"%s" "$commit")
            author=$(git log -1 --pretty=format:"%an" "$commit")
            date=$(git log -1 --pretty=format:"%cr" "$commit")
            commit_messages+=("${commit::7} - $message ${GRAY}($author, $date)${ENDCOLOR}")
        done
        echo -e "${YELLOW}Available commits:${ENDCOLOR}"
        for i in "${!commit_messages[@]}"; do
            echo -e "$((i+1)). ${commit_messages[$i]}"
        done
        echo -e "0. Exit"
        if [ "$show_all" = false ] && [ ${#all_commits[@]} -gt $max_commits ]; then
            echo -e "Enter = to show all commits"
        fi
        echo
        echo -e "Enter commit numbers to cherry-pick (space-separated, e.g., '1 3 5'):"
        read -e selected_numbers
        if [ -z "$selected_numbers" ]; then
            exit
        fi
        if [ "$selected_numbers" = "=" ] && [ "$show_all" = false ] && [ ${#all_commits[@]} -gt $max_commits ]; then
            show_all=true
            echo
            continue
        fi
        break
    done
    local selected_commits=()
    local IFS=' '
    local selected_array=($selected_numbers)
    for num in "${selected_array[@]}"; do
        num=$(echo "$num" | xargs)
        if [ -z "$num" ]; then
            continue
        fi
        if [[ "$num" =~ ^[0-9]+$ ]]; then
            if [ "$num" == "0" ]; then
                exit
            elif [ "$num" -gt 0 ] && [ "$num" -le ${#commits[@]} ]; then
                selected_commits+=("${commit_hashes[$((num-1))]}")
            else
                echo -e "${RED}Invalid selection: $num (must be between 1 and ${#commits[@]})${ENDCOLOR}"
                exit 1
            fi
        else
            echo -e "${RED}Invalid selection: '$num' (must be a number)${ENDCOLOR}"
            exit 1
        fi
    done
    if [ ${#selected_commits[@]} -eq 0 ]; then
        echo -e "${YELLOW}No valid commits selected${ENDCOLOR}"
        exit
    fi
    echo
    echo -e "${YELLOW}Selected commits to cherry-pick:${ENDCOLOR}"
    for commit in "${selected_commits[@]}"; do
        message=$(git log -1 --pretty=format:"%s" "$commit")
        echo -e "  ${commit::7} - $message"
    done
    echo
    echo -e "Proceed with cherry-pick? (y/n)"
    yes_no_choice "Proceeding with cherry-pick..."
    local success_count=0
    local total_count=${#selected_commits[@]}
    for commit in "${selected_commits[@]}"; do
        echo -e "${YELLOW}Cherry-picking ${commit::7}...${ENDCOLOR}"
        cherry_output=$(git cherry-pick "$commit" 2>&1)
        cherry_code=$?
        if [ $cherry_code == 0 ]; then
            ((success_count++))
            message=$(git log -1 --pretty=format:"%s" "$commit")
            echo -e "${GREEN}✓${ENDCOLOR} Successfully cherry-picked: $message"
        else
            echo -e "${RED}✗${ENDCOLOR} Failed to cherry-pick ${commit::7}"
            handle_cherry_pick_conflicts "$cherry_output" $cherry_code
            break
        fi
        echo
    done
    if [ $success_count -eq $total_count ]; then
        echo -e "${GREEN}All ${total_count} commits cherry-picked successfully!${ENDCOLOR}"
        after_cherry_pick
    fi
} 
function project_status {
    echo -e "${YELLOW}$project_name${ENDCOLOR} | ${CYAN}$repo_url${ENDCOLOR}"
    echo
    echo -e "${YELLOW}[$current_branch $(git log -n 1 --pretty="%h")]${ENDCOLOR}"
    echo -e "$(git --no-pager log -n 1 --pretty="%s")"
    echo -e "=============================="
    status=$(git_status)
    if [ -n "$status" ]; then
        echo -e "$status"
    else
        echo -e "${GREEN}There are no unstaged files${ENDCOLOR}"
    fi
}
function gitlog {
    local branch="$1"
    if [ -n "$branch" ]; then
        echo -e "${YELLOW}Git log for branch: ${BLUD}$branch${ENDCOLOR}"
        git log "$branch" --pretty="%C(Yellow)%h%C(reset) | %C(Cyan)%ad%C(reset) | %C(Blue)%an%C(reset) | %s (%C(Green)%cr%C(reset))"
    else
        git log --pretty="%C(Yellow)%h%C(reset) | %C(Cyan)%ad%C(reset) | %C(Blue)%an%C(reset) | %s (%C(Green)%cr%C(reset))"
    fi
}
function gitlog_branch {
    local mode="$1"
    case "$mode" in
        "local"|"l")
            echo -e "${YELLOW}GIT LOG BRANCH LOCAL${ENDCOLOR}"
            echo
            echo -e "${YELLOW}Select a local branch to view git log:${ENDCOLOR}"
            choose_branch
        ;;
        "remote"|"r")
            echo -e "${YELLOW}GIT LOG BRANCH REMOTE${ENDCOLOR}"
            echo
            echo -e "${YELLOW}Select a remote branch to view git log:${ENDCOLOR}"
            choose_branch "remote"
        ;;
        "all"|"a"|"")
            echo -e "${YELLOW}GIT LOG BRANCH${ENDCOLOR}"
            echo
            echo -e "${YELLOW}Select a branch to view git log:${ENDCOLOR}"
            choose_branch
        ;;
        "help"|"h")
            echo -e "${YELLOW}gitb log branch${ENDCOLOR} - View git log from different branches"
            echo
            echo -e "${YELLOW}Usage:${ENDCOLOR}"
            echo -e "  gitb log branch [mode]"
            echo
            echo -e "${YELLOW}Modes:${ENDCOLOR}"
            echo -e "  ${GREEN}local, l${ENDCOLOR}     Show log from local branches"
            echo -e "  ${GREEN}remote, r${ENDCOLOR}    Show log from remote branches"
            echo -e "  ${GREEN}all, a${ENDCOLOR}       Show log from all branches (default)"
            echo -e "  ${GREEN}help, h${ENDCOLOR}      Show this help"
            return
        ;;
        *)
            echo -e "${RED}Unknown mode: $mode${ENDCOLOR}"
            echo -e "Use ${GREEN}gitb log branch help${ENDCOLOR} to see available modes"
            return
        ;;
    esac
    if [ -n "$to_exit" ]; then
        return
    fi
    if [ -n "$branch_name" ]; then
        echo
        gitlog "$branch_name"
    fi
}
function gitlog_compare {
    echo -e "${YELLOW}GIT LOG COMPARE${ENDCOLOR}"
    echo
    echo -e "${YELLOW}Select first branch:${ENDCOLOR}"
    choose_branch
    if [ -n "$to_exit" ]; then
        return
    fi
    if [ -z "$branch_name" ]; then
        return
    fi
    local first_branch="$branch_name"
    echo
    echo -e "${YELLOW}Select second branch:${ENDCOLOR}"
    choose_branch
    if [ -n "$to_exit" ]; then
        return
    fi
    if [ -n "$branch_name" ]; then
        local second_branch="$branch_name"
        echo
        echo -e "${YELLOW}Commits in '$first_branch' but not in '$second_branch':${ENDCOLOR}"
        echo
        git log "$second_branch..$first_branch" --pretty="%C(Yellow)%h%C(reset) | %C(Cyan)%ad%C(reset) | %C(Blue)%an%C(reset) | %s (%C(Green)%cr%C(reset))" --oneline
        echo
        echo -e "${YELLOW}Commits in '$second_branch' but not in '$first_branch':${ENDCOLOR}"
        echo
        git log "$first_branch..$second_branch" --pretty="%C(Yellow)%h%C(reset) | %C(Cyan)%ad%C(reset) | %C(Blue)%an%C(reset) | %s (%C(Green)%cr%C(reset))" --oneline
    fi
}
function reflog {
    git reflog --pretty="%C(Yellow)%h%C(reset) | %C(Blue)%gd%C(reset) | %C(Cyan)%ad%C(reset) | %gs (%C(Green)%cr%C(reset))"
}
function last_commit {
    git --no-pager log -n 1 --pretty="%C(Yellow)%h%C(reset) | %s | %C(Blue)%an%C(reset) | %C(Green)%cr%C(reset) | %C(Cyan)%ad%C(reset)" 
}
function last_ref {
    git --no-pager reflog -n 1 --pretty="%C(Yellow)%h%C(reset) | %C(Cyan)%gd%C(reset) | %gs | %C(Green)%cr%C(reset) | %C(Cyan)%ad%C(reset)"
}
function gitlog_search {
    local search_mode="$1"
    case "$search_mode" in
        "message"|"msg"|"m")
            echo -e "${YELLOW}GIT LOG SEARCH BY MESSAGE${ENDCOLOR}"
            echo
            echo -e "${YELLOW}Search commits by message content:${ENDCOLOR}"
            echo -e "Press Enter to exit"
            read -p "Enter search term: " -e search_term
            if [ -z "$search_term" ]; then
                return
            fi
            if ! sanitize_text_input "$search_term" 200; then
                show_sanitization_error "search term" "Use printable characters only, max 200 characters."
                return
            fi
            search_term="$sanitized_text"
            echo
            echo -e "${YELLOW}Commits matching message: '$search_term'${ENDCOLOR}"
            echo
            git log --grep="$search_term" --pretty="%C(Yellow)%h%C(reset) | %C(Cyan)%ad%C(reset) | %C(Blue)%an%C(reset) | %s (%C(Green)%cr%C(reset))" -i
        ;;
        "author"|"a")
            echo -e "${YELLOW}GIT LOG SEARCH BY AUTHOR${ENDCOLOR}"
            echo
            echo -e "${YELLOW}Search commits by author name or email:${ENDCOLOR}"
            echo -e "Press Enter to exit"
            read -p "Enter author name or email: " -e author_term
            if [ -z "$author_term" ]; then
                return
            fi
            if ! sanitize_text_input "$author_term" 100; then
                show_sanitization_error "author name" "Use printable characters only, max 100 characters."
                return
            fi
            author_term="$sanitized_text"
            echo
            echo -e "${YELLOW}Commits by author: '$author_term'${ENDCOLOR}"
            echo
            git log --author="$author_term" --pretty="%C(Yellow)%h%C(reset) | %C(Cyan)%ad%C(reset) | %C(Blue)%an%C(reset) | %s (%C(Green)%cr%C(reset))" -i
        ;;
        "file"|"f")
            echo -e "${YELLOW}GIT LOG SEARCH BY FILE${ENDCOLOR}"
            echo
            echo -e "${YELLOW}Search commits that modified specific file(s):${ENDCOLOR}"
            echo -e "Press Enter to exit"
            read -p "Enter file path or pattern: " -e file_path
            if [ -z "$file_path" ]; then
                return
            fi
            if ! sanitize_file_path "$file_path"; then
                show_sanitization_error "file path" "Invalid file path or pattern."
                return
            fi
            file_path="$sanitized_file_path"
            echo
            echo -e "${YELLOW}Commits that modified: '$file_path'${ENDCOLOR}"
            echo
            git log --follow --pretty="%C(Yellow)%h%C(reset) | %C(Cyan)%ad%C(reset) | %C(Blue)%an%C(reset) | %s (%C(Green)%cr%C(reset))" -- "$file_path"
        ;;
        "content"|"pickaxe"|"p")
            echo -e "${YELLOW}GIT LOG SEARCH BY CONTENT CHANGES${ENDCOLOR}"
            echo
            echo -e "${YELLOW}Search commits that added or removed specific content:${ENDCOLOR}"
            echo -e "Press Enter to exit"
            read -p "Enter content to search for: " -e content_term
            if [ -z "$content_term" ]; then
                return
            fi
            if ! sanitize_text_input "$content_term" 200; then
                show_sanitization_error "content term" "Use printable characters only, max 200 characters."
                return
            fi
            content_term="$sanitized_text"
            echo
            echo -e "${YELLOW}Commits that added/removed: '$content_term'${ENDCOLOR}"
            echo
            git log -S"$content_term" --pretty="%C(Yellow)%h%C(reset) | %C(Cyan)%ad%C(reset) | %C(Blue)%an%C(reset) | %s (%C(Green)%cr%C(reset))"
        ;;
        "date"|"d")
            echo -e "${YELLOW}GIT LOG SEARCH BY DATE RANGE${ENDCOLOR}"
            echo
            echo -e "${YELLOW}Search commits within a date range:${ENDCOLOR}"
            echo -e "Date formats: YYYY-MM-DD, '2 weeks ago', 'yesterday', etc."
            echo -e "Press Enter to skip a field"
            read -p "Since (start date): " -e since_date
            read -p "Until (end date): " -e until_date
            if [ -z "$since_date" ] && [ -z "$until_date" ]; then
                echo -e "${YELLOW}No date range specified${ENDCOLOR}"
                return
            fi
            local date_args=""
            if [ -n "$since_date" ]; then
                if ! sanitize_text_input "$since_date" 50; then
                    show_sanitization_error "date" "Invalid date format."
                    return
                fi
                date_args="$date_args --since=\"$sanitized_text\""
            fi
            if [ -n "$until_date" ]; then
                if ! sanitize_text_input "$until_date" 50; then
                    show_sanitization_error "date" "Invalid date format."
                    return
                fi
                date_args="$date_args --until=\"$sanitized_text\""
            fi
            echo
            echo -e "${YELLOW}Commits in date range:${ENDCOLOR}"
            echo
            eval "git log $date_args --pretty=\"%C(Yellow)%h%C(reset) | %C(Cyan)%ad%C(reset) | %C(Blue)%an%C(reset) | %s (%C(Green)%cr%C(reset))\""
        ;;
        "hash"|"commit"|"h")
            echo -e "${YELLOW}GIT LOG SEARCH BY COMMIT HASH${ENDCOLOR}"
            echo
            echo -e "${YELLOW}Search for commits by hash pattern:${ENDCOLOR}"
            echo -e "Press Enter to exit"
            read -p "Enter commit hash (full or partial): " -e hash_term
            if [ -z "$hash_term" ]; then
                return
            fi
            if [[ ! "$hash_term" =~ ^[a-fA-F0-9]+$ ]]; then
                echo -e "${RED}Invalid commit hash format! Use only hexadecimal characters.${ENDCOLOR}"
                return
            fi
            if [ ${#hash_term} -lt 4 ]; then
                echo -e "${RED}Hash too short! Use at least 4 characters.${ENDCOLOR}"
                return
            fi
            echo
            echo -e "${YELLOW}Commits matching hash pattern: '$hash_term'${ENDCOLOR}"
            echo
            git log --grep="$hash_term" --pretty="%C(Yellow)%h%C(reset) | %C(Cyan)%ad%C(reset) | %C(Blue)%an%C(reset) | %s (%C(Green)%cr%C(reset))" --all || \
            git log --oneline --all | grep -i "$hash_term" | head -20 | while read line; do
                hash=$(echo "$line" | cut -d' ' -f1)
                git log --pretty="%C(Yellow)%h%C(reset) | %C(Cyan)%ad%C(reset) | %C(Blue)%an%C(reset) | %s (%C(Green)%cr%C(reset))" -1 "$hash"
            done
        ;;
        "interactive"|"i"|"")
            echo -e "${YELLOW}GIT LOG INTERACTIVE SEARCH${ENDCOLOR}"
            echo
            echo -e "${YELLOW}Select search type:${ENDCOLOR}"
            echo
            echo "1. Search by commit message"
            echo "2. Search by author"
            echo "3. Search by file changes"
            echo "4. Search by content changes (pickaxe)"
            echo "5. Search by date range"
            echo "6. Search by commit hash"
            echo "0. Exit"
            echo
            read -n 1 -p "Enter your choice: " choice
            echo
            echo
            case "$choice" in
                "1") gitlog_search "message" ;;
                "2") gitlog_search "author" ;;
                "3") gitlog_search "file" ;;
                "4") gitlog_search "content" ;;
                "5") gitlog_search "date" ;;
                "6") gitlog_search "hash" ;;
                "0") return ;;
                *) 
                    echo -e "${RED}Invalid choice!${ENDCOLOR}"
                    return
                ;;
            esac
        ;;
        "help"|"help")
            echo -e "${YELLOW}gitb log search${ENDCOLOR} - Search git log with various criteria"
            echo
            echo -e "${YELLOW}Usage:${ENDCOLOR}"
            echo -e "  gitb log search [mode]"
            echo
            echo -e "${YELLOW}Search Modes:${ENDCOLOR}"
            echo -e "  ${GREEN}interactive, i${ENDCOLOR}   Interactive search menu (default)"
            echo -e "  ${GREEN}message, msg, m${ENDCOLOR}  Search by commit message content"
            echo -e "  ${GREEN}author, a${ENDCOLOR}        Search by author name or email"
            echo -e "  ${GREEN}file, f${ENDCOLOR}          Search by file changes"
            echo -e "  ${GREEN}content, p${ENDCOLOR}       Search by content changes (pickaxe search)"
            echo -e "  ${GREEN}date, d${ENDCOLOR}          Search by date range"
            echo -e "  ${GREEN}hash, h${ENDCOLOR}          Search by commit hash pattern"
            echo -e "  ${GREEN}help${ENDCOLOR}             Show this help"
            echo
            echo -e "${YELLOW}Examples:${ENDCOLOR}"
            echo -e "  gitb log search"
            echo -e "  gitb log search message"
            echo -e "  gitb log search author"
            echo -e "  gitb log search file"
        ;;
        *)
            echo -e "${RED}Unknown search mode: $search_mode${ENDCOLOR}"
            echo -e "Use ${GREEN}gitb log search help${ENDCOLOR} to see available modes"
        ;;
    esac
}
function gitlog_script {
    local mode="$1"
    case "$mode" in
        "branch"|"b")
            gitlog_branch "$2"
        ;;
        "compare"|"comp"|"c")
            gitlog_compare
        ;;
        "search"|"s")
            gitlog_search "$2"
        ;;
        "help"|"h")
            echo -e "${YELLOW}gitb log${ENDCOLOR} - Git log utilities"
            echo
            echo -e "${YELLOW}Usage:${ENDCOLOR}"
            echo -e "  gitb log [command]"
            echo
            echo -e "${YELLOW}Commands:${ENDCOLOR}"
            echo -e "  ${GREEN}(no command)${ENDCOLOR}   Show log for current branch"
            echo -e "  ${GREEN}branch, b${ENDCOLOR}      View log from different branches"
            echo -e "  ${GREEN}compare, c${ENDCOLOR}     Compare log between two branches"
            echo -e "  ${GREEN}search, s${ENDCOLOR}      Search git log with various criteria"
            echo -e "  ${GREEN}help, h${ENDCOLOR}        Show this help"
            echo
            echo -e "${YELLOW}Examples:${ENDCOLOR}"
            echo -e "  gitb log"
            echo -e "  gitb log branch"
            echo -e "  gitb log branch local"
            echo -e "  gitb log compare"
            echo -e "  gitb log search"
            echo -e "  gitb log search message"
        ;;
        "")
            gitlog
        ;;
        *)
            wrong_mode "log" "$mode"
        ;;
    esac
}
function get_hooks_dir {
    local hooks_dir="$(git rev-parse --git-dir)/hooks"
    echo "$hooks_dir"
}
function get_all_hook_types {
    echo "pre-commit post-commit pre-push post-update pre-receive post-receive prepare-commit-msg commit-msg post-checkout post-merge pre-rebase pre-auto-gc"
}
function get_hook_description {
    local hook_type="$1"
    case "$hook_type" in
        "pre-commit")
            echo "Triggered before a commit is created (validate/lint code)"
        ;;
        "post-commit")
            echo "Triggered after a commit is successfully created"
        ;;
        "pre-push")
            echo "Triggered before pushing to remote (validate commits/branches)"
        ;;
        "post-update")
            echo "Triggered on the remote repository after a successful push"
        ;;
        "pre-receive")
            echo "Triggered on remote repository before accepting a push"
        ;;
        "post-receive")
            echo "Triggered on remote repository after accepting a push"
        ;;
        "prepare-commit-msg")
            echo "Triggered before commit message editor is invoked"
        ;;
        "commit-msg")
            echo "Triggered to validate/modify commit message"
        ;;
        "post-checkout")
            echo "Triggered after a successful checkout"
        ;;
        "post-merge")
            echo "Triggered after a successful merge"
        ;;
        "pre-rebase")
            echo "Triggered before a rebase operation"
        ;;
        "pre-auto-gc")
            echo "Triggered before automatic garbage collection"
        ;;
        *)
            echo "Git hook"
        ;;
    esac
}
function select_hook_type {
    local action="$1"  # "create", "edit", "toggle", etc.
    local filter_existing="$2"  # "existing" to show only existing hooks
    echo -e "${YELLOW}Select git hook type for $action:${ENDCOLOR}" >&2
    echo >&2
    local hooks_dir=$(get_hooks_dir)
    local all_hooks=($(get_all_hook_types))
    local available_hooks=()
    local hook_numbers=()
    local counter=1
    if [ "$action" = "removal" ] && [ "$filter_existing" = "existing" ]; then
        available_hooks+=("ALL")
        hook_numbers+=("$counter")
        counter=$((counter + 1))
    fi
    for hook_type in "${all_hooks[@]}"; do
        local hook_file="$hooks_dir/$hook_type"
        if [ "$filter_existing" = "existing" ]; then
            if [ -f "$hook_file" ]; then
                available_hooks+=("$hook_type")
                hook_numbers+=("$counter")
                counter=$((counter + 1))
            fi
        else
            available_hooks+=("$hook_type")
            hook_numbers+=("$counter")
            counter=$((counter + 1))
        fi
    done
    if [ ${#available_hooks[@]} -eq 0 ]; then
        if [ "$filter_existing" = "existing" ]; then
            echo -e "${YELLOW}No git hooks found${ENDCOLOR}" >&2
            echo -e "Use ${GREEN}gitb hook create${ENDCOLOR} to create a hook first" >&2
        else
            echo -e "${RED}No hook types available${ENDCOLOR}" >&2
        fi
        return 1
    fi
    for i in "${!available_hooks[@]}"; do
        local hook_type="${available_hooks[$i]}"
        local number="${hook_numbers[$i]}"
        local status=""
        local color=""
        local description=""
        if [ "$hook_type" = "ALL" ]; then
            local existing_count=0
            for check_hook in $(get_all_hook_types); do
                if [ -f "$hooks_dir/$check_hook" ]; then
                    ((existing_count++))
                fi
            done
            status=" ${RED}(remove all $existing_count hooks)${ENDCOLOR}"
            color="$RED"
            description="Remove all existing git hooks"
        else
            local hook_file="$hooks_dir/$hook_type"
            if [ -f "$hook_file" ]; then
                if [ -x "$hook_file" ]; then
                    status=" ${GREEN}(enabled)${ENDCOLOR}"
                    color="$GREEN"
                else
                    status=" ${YELLOW}(disabled)${ENDCOLOR}"
                    color="$YELLOW"
                fi
            else
                if [ "$filter_existing" != "existing" ]; then
                    status=" ${GRAY}(not created)${ENDCOLOR}"
                    color="$GRAY"
                fi
            fi
            description=$(get_hook_description "$hook_type")
        fi
        if [ -n "$color" ]; then
            echo -e "${color}${number}) ${ENDCOLOR}${hook_type}${status} - ${description}" >&2
        else
            echo "${number}) ${hook_type}${status} - ${description}" >&2
        fi
    done
    echo >&2
    if [ ${#available_hooks[@]} -le 9 ]; then
        read -n 1 -p "Enter number (1-${#available_hooks[@]}): " choice < /dev/tty
        echo >&2  # Add newline after single character input
    else
        read -p "Enter number (1-${#available_hooks[@]}): " choice < /dev/tty
    fi
    if ! [[ "$choice" =~ ^[0-9]+$ ]] || [ "$choice" -lt 1 ] || [ "$choice" -gt ${#available_hooks[@]} ]; then
        echo -e "${RED}Invalid selection${ENDCOLOR}" >&2
        return 1
    fi
    selected_hook_type="${available_hooks[$((choice - 1))]}"
    echo "$selected_hook_type"
}
function show_hooks_menu {
    echo -e "${YELLOW}Git Hooks Management${ENDCOLOR}" >&2
    echo >&2
    echo -e "${YELLOW}What would you like to do?${ENDCOLOR}" >&2
    echo >&2
    local actions=(
        "list:List all hooks with status" 
        "create:Create a new hook"
        "edit:Edit an existing hook"
        "toggle:Enable/disable a hook"
        "test:Test a hook"
        "show:View hook content"
        "remove:Remove hook(s) - single or all"
        "select:Browse hook types"
        "install:Install sample hooks"
    )
    for i in "${!actions[@]}"; do
        local action="${actions[$i]}"
        local action_name="${action%%:*}"
        local description="${action##*:}"
        local number=$((i + 1))
        echo "${number}) ${action_name} - ${description}" >&2
    done
    echo >&2
    if [ ${#actions[@]} -le 9 ]; then
        read -n 1 -p "Enter number (1-${#actions[@]}): " choice < /dev/tty
        echo >&2  # Add newline after single character input
    else
        read -p "Enter number (1-${#actions[@]}): " choice < /dev/tty
    fi
    if ! [[ "$choice" =~ ^[0-9]+$ ]] || [ "$choice" -lt 1 ] || [ "$choice" -gt ${#actions[@]} ]; then
        exit
    fi
    local selected_action="${actions[$((choice - 1))]}"
    local action_command="${selected_action%%:*}"
    echo >&2
    case "$action_command" in
        "list")
            list_hooks
        ;;
        "create")
            hooks_script "create"
        ;;
        "edit")
            hooks_script "edit"
        ;;
        "toggle")
            hooks_script "toggle"
        ;;
        "test")
            hooks_script "test"
        ;;
        "show")
            hooks_script "show"
        ;;
        "remove")
            hooks_script "remove"
        ;;
        "select")
            hooks_script "select"
        ;;
        "install")
            hooks_script "install"
        ;;
        "help")
            hooks_script "help"
        ;;
    esac
}
function select_hook_template {
    local hook_type="$1"
    echo -e "${YELLOW}Select template for $hook_type hook:${ENDCOLOR}" >&2
    echo >&2
    local templates=()
    local template_descriptions=()
    templates+=("basic")
    template_descriptions+=("Basic hook template with placeholder content")
    case "$hook_type" in
        "pre-commit")
            templates+=("pre-commit-lint")
            template_descriptions+=("Linting, TODO/FIXME detection, large file prevention")
        ;;
        "commit-msg")
            templates+=("commit-msg-conventional")
            template_descriptions+=("Conventional commit message format validation")
        ;;
        "pre-push")
            templates+=("pre-push-protection")
            template_descriptions+=("Branch protection for main/master branches")
        ;;
    esac
    for i in "${!templates[@]}"; do
        local template="${templates[$i]}"
        local description="${template_descriptions[$i]}"
        local number=$((i + 1))
        echo "${number}) ${template} - ${description}" >&2
    done
    echo >&2
    if [ ${#templates[@]} -le 9 ]; then
        read -n 1 -p "Enter number (1-${#templates[@]}, default: 1): " choice < /dev/tty
        echo >&2  # Add newline after single character input
    else
        read -p "Enter number (1-${#templates[@]}, default: 1): " choice < /dev/tty
    fi
    if [ -z "$choice" ]; then
        choice=1
    fi
    if ! [[ "$choice" =~ ^[0-9]+$ ]] || [ "$choice" -lt 1 ] || [ "$choice" -gt ${#templates[@]} ]; then
        exit
    fi
    selected_template="${templates[$((choice - 1))]}"
    echo "$selected_template"
}
function list_hooks {
    local hooks_dir=$(get_hooks_dir)
    local show_samples="$1"
    if [ ! -d "$hooks_dir" ]; then
        echo -e "${RED}Git hooks directory not found: $hooks_dir${ENDCOLOR}"
        return 1
    fi
    echo -e "${YELLOW}Git hooks in: $hooks_dir${ENDCOLOR}"
    echo
    local found_hooks=false
    local all_hooks=$(get_all_hook_types)
    for hook_type in $all_hooks; do
        local hook_file="$hooks_dir/$hook_type"
        local sample_file="$hooks_dir/$hook_type.sample"
        if [ -f "$hook_file" ]; then
            found_hooks=true
            if [ -x "$hook_file" ]; then
                echo -e "${GREEN}✓ $hook_type${ENDCOLOR} (executable)"
            else
                echo -e "${YELLOW}! $hook_type${ENDCOLOR} (not executable)"
            fi
        elif [ -f "$sample_file" ] && [ -n "$show_samples" ]; then
            echo -e "${GRAY}○ $hook_type.sample${ENDCOLOR} (sample)"
        fi
    done
    if [ "$found_hooks" = false ]; then
        echo -e "${YELLOW}No git hooks found${ENDCOLOR}"
        if [ -z "$show_samples" ]; then
            echo -e "Use ${GREEN}gitb hooks list samples${ENDCOLOR} to see available sample hooks"
        fi
    fi
}
function create_hook {
    local hook_type="$1"
    local template="$2"
    local hooks_dir=$(get_hooks_dir)
    local hook_file="$hooks_dir/$hook_type"
    if [ ! -d "$hooks_dir" ]; then
        echo -e "${RED}Git hooks directory not found: $hooks_dir${ENDCOLOR}"
        return 1
    fi
    local all_hooks=$(get_all_hook_types)
    if [[ ! " $all_hooks " =~ " $hook_type " ]]; then
        echo -e "${RED}Invalid hook type: $hook_type${ENDCOLOR}"
        echo -e "${YELLOW}Valid types: $all_hooks${ENDCOLOR}"
        return 1
    fi
    if [ -f "$hook_file" ]; then
        echo -e "${YELLOW}Hook '$hook_type' already exists${ENDCOLOR}"
        echo -e "Do you want to ${RED}overwrite${ENDCOLOR} it? (y/n)"
        read -n 1 -s choice
        echo
        if [ "$choice" != "y" ] && [ "$choice" != "Y" ]; then
            echo -e "${YELLOW}Hook creation cancelled${ENDCOLOR}"
            return
        fi
    fi
    local hook_content=""
    case "$template" in
        "basic"|"")
            hook_content="#!/bin/sh
#
#
echo \"Running $hook_type hook...\"
exit 0"
        ;;
        "pre-commit-lint")
            if [ "$hook_type" != "pre-commit" ]; then
                echo -e "${RED}Template 'pre-commit-lint' is only for pre-commit hooks${ENDCOLOR}"
                return 1
            fi
            hook_content="#!/bin/sh
#
#
echo \"Running pre-commit checks...\"
if git diff --cached --name-only --quiet; then
    echo \"No staged files to check\"
    exit 0
fi
staged_files=\$(git diff --cached --name-only)
if echo \"\$staged_files\" | xargs grep -l \"TODO\\|FIXME\" 2>/dev/null; then
    echo \"⚠️  Warning: Found TODO/FIXME comments in staged files\"
    echo \"Continue anyway? (y/n)\"
    read -n 1 answer
    echo
    if [ \"\$answer\" != \"y\" ] && [ \"\$answer\" != \"Y\" ]; then
        echo \"Commit aborted\"
        exit 1
    fi
fi
for file in \$staged_files; do
    if [ -f \"\$file\" ]; then
        size=\$(stat -c%s \"\$file\" 2>/dev/null || stat -f%z \"\$file\" 2>/dev/null)
        if [ \"\$size\" -gt 10485760 ]; then
            echo \"❌ Error: Large file detected: \$file (\${size} bytes)\"
            echo \"Files larger than 10MB should not be committed\"
            exit 1
        fi
    fi
done
echo \"Pre-commit checks passed\"
exit 0"
        ;;
        "commit-msg-conventional")
            if [ "$hook_type" != "commit-msg" ]; then
                echo -e "${RED}Template 'commit-msg-conventional' is only for commit-msg hooks${ENDCOLOR}"
                return 1
            fi
            hook_content="#!/bin/sh
#
#
commit_regex='^(feat|fix|docs|style|refactor|test|chore|perf|ci|build|revert)(\\(.+\\))?: .{1,50}'
error_msg=\"❌ Invalid commit message format!
Commit message should follow conventional commits format:
  <type>[optional scope]: <description>
Examples:
  feat: add new search functionality
  fix(auth): resolve login issue  
  docs: update API documentation
Valid types: feat, fix, docs, style, refactor, test, chore, perf, ci, build, revert\"
if ! grep -qE \"\$commit_regex\" \"\$1\"; then
    echo \"\$error_msg\"
    exit 1
fi
echo \"Commit message format is valid\"
exit 0"
        ;;
        "pre-push-protection")
            if [ "$hook_type" != "pre-push" ]; then
                echo -e "${RED}Template 'pre-push-protection' is only for pre-push hooks${ENDCOLOR}"
                return 1
            fi
            hook_content="#!/bin/sh
#
#
protected_branch=\"main\"
current_branch=\$(git branch --show-current)
remote=\"\$1\"
url=\"\$2\"
echo \"Running pre-push checks...\"
if [ \"\$current_branch\" = \"\$protected_branch\" ]; then
    echo \"❌ Error: Direct push to '\$protected_branch' branch is not allowed\"
    echo \"Please create a feature branch and submit a pull request\"
    exit 1
fi
while read local_ref local_sha remote_ref remote_sha; do
    if [[ \"\$remote_ref\" == *\"/main\" ]] || [[ \"\$remote_ref\" == *\"/master\" ]]; then
        echo \"❌ Error: Direct push to remote main/master branch is not allowed\"
        echo \"Please use pull requests for main/master branch\"
        exit 1
    fi
done
echo \"Pre-push checks passed\"
exit 0"
        ;;
    esac
    echo "$hook_content" > "$hook_file"
    chmod +x "$hook_file"
    echo -e "${GREEN}Created executable hook: $hook_type${ENDCOLOR}"
    echo -e "${YELLOW}Hook file: $hook_file${ENDCOLOR}"
    echo
    echo -e "Do you want to ${BLUE}edit${ENDCOLOR} the hook now? (y/n)"
    read -n 1 -s choice
    echo
    if [ "$choice" = "y" ] || [ "$choice" = "Y" ]; then
        edit_hook "$hook_type"
    fi
}
function edit_hook {
    local hook_type="$1"
    local hooks_dir=$(get_hooks_dir)
    local hook_file="$hooks_dir/$hook_type"
    if [ ! -f "$hook_file" ]; then
        echo -e "${RED}Hook '$hook_type' does not exist${ENDCOLOR}"
        echo -e "Use ${GREEN}gitb hooks create $hook_type${ENDCOLOR} to create it first"
        return 1
    fi
    echo -e "${YELLOW}Editing hook: $hook_type${ENDCOLOR}"
    echo -e "${GRAY}File: $hook_file${ENDCOLOR}"
    echo
    "$editor" "$hook_file"
    chmod +x "$hook_file"
    echo -e "${GREEN}Hook updated and made executable${ENDCOLOR}"
}
function toggle_hook {
    local hook_type="$1"
    local hooks_dir=$(get_hooks_dir)
    local hook_file="$hooks_dir/$hook_type"
    if [ ! -f "$hook_file" ]; then
        echo -e "${RED}Hook '$hook_type' does not exist${ENDCOLOR}"
        return 1
    fi
    if [ -x "$hook_file" ]; then
        chmod -x "$hook_file"
        echo -e "${YELLOW}Disabled hook: $hook_type${ENDCOLOR}"
    else
        chmod +x "$hook_file"
        echo -e "${GREEN}Enabled hook: $hook_type${ENDCOLOR}"
    fi
}
function remove_hook {
    local hook_type="$1"
    local hooks_dir=$(get_hooks_dir)
    local hook_file="$hooks_dir/$hook_type"
    if [ ! -f "$hook_file" ]; then
        echo -e "${RED}Hook '$hook_type' does not exist${ENDCOLOR}"
        return 1
    fi
    echo -e "${RED}Are you sure you want to delete hook '$hook_type'?${ENDCOLOR}"
    echo -e "${GRAY}File: $hook_file${ENDCOLOR}"
    echo -e "This action cannot be undone. (y/n)"
    read -n 1 -s choice
    echo
    if [ "$choice" = "y" ] || [ "$choice" = "Y" ]; then
        rm "$hook_file"
        echo -e "${GREEN}Removed hook: $hook_type${ENDCOLOR}"
    else
        echo -e "${YELLOW}Hook removal cancelled${ENDCOLOR}"
    fi
}
function remove_all_hooks {
    local hooks_dir=$(get_hooks_dir)
    if [ ! -d "$hooks_dir" ]; then
        echo -e "${RED}Git hooks directory not found: $hooks_dir${ENDCOLOR}"
        return 1
    fi
    echo -e "${RED}Remove All Git Hooks${ENDCOLOR}"
    echo
    echo -e "${YELLOW}Description:${ENDCOLOR}"
    echo "This will remove ALL git hooks from your repository."
    echo -e "${RED}WARNING: This action cannot be undone!${ENDCOLOR}"
    echo
    local all_hooks=$(get_all_hook_types)
    local existing_hooks=()
    local hook_count=0
    echo -e "${YELLOW}Hooks that will be removed:${ENDCOLOR}"
    for hook_type in $all_hooks; do
        local hook_file="$hooks_dir/$hook_type"
        if [ -f "$hook_file" ]; then
            existing_hooks+=("$hook_type")
            if [ -x "$hook_file" ]; then
                echo -e "  ${RED}✗${ENDCOLOR} $hook_type ${GREEN}(enabled)${ENDCOLOR}"
            else
                echo -e "  ${RED}✗${ENDCOLOR} $hook_type ${YELLOW}(disabled)${ENDCOLOR}"
            fi
            ((hook_count++))
        fi
    done
    if [ $hook_count -eq 0 ]; then
        echo -e "${YELLOW}No git hooks found to remove${ENDCOLOR}"
        return
    fi
    echo
    echo -e "${RED}This will permanently delete $hook_count hooks.${ENDCOLOR}"
    echo -e "${YELLOW}Are you absolutely sure? (y/n)${ENDCOLOR}"
    read -n 1 -p "Your choice: " choice < /dev/tty
    echo
    echo
    if [ "$choice" != "y" ] && [ "$choice" != "Y" ]; then
        echo -e "${YELLOW}Hook removal cancelled${ENDCOLOR}"
        return
    fi
    echo -e "${RED}FINAL CONFIRMATION${ENDCOLOR}"
    echo -e "${RED}Type 'DELETE' to confirm removal of all hooks:${ENDCOLOR}"
    read -p "Enter confirmation: " confirmation < /dev/tty
    if [ "$confirmation" != "DELETE" ]; then
        echo -e "${YELLOW}Hook removal cancelled - confirmation text did not match${ENDCOLOR}"
        return
    fi
    echo
    echo -e "${YELLOW}Removing all hooks...${ENDCOLOR}"
    echo
    local removed_count=0
    for hook_type in "${existing_hooks[@]}"; do
        local hook_file="$hooks_dir/$hook_type"
        if [ -f "$hook_file" ]; then
            rm "$hook_file"
            echo -e "${RED}✗ Removed: $hook_type${ENDCOLOR}"
            ((removed_count++))
        fi
    done
    echo
    echo -e "${GREEN}Successfully removed $removed_count hooks${ENDCOLOR}"
}
function test_hook {
    local hook_type="$1"
    local hooks_dir=$(get_hooks_dir)
    local hook_file="$hooks_dir/$hook_type"
    if [ ! -f "$hook_file" ]; then
        echo -e "${RED}Hook '$hook_type' does not exist${ENDCOLOR}"
        return 1
    fi
    if [ ! -x "$hook_file" ]; then
        echo -e "${YELLOW}Hook '$hook_type' is not executable${ENDCOLOR}"
        echo -e "Enable it with: ${GREEN}gitb hooks toggle $hook_type${ENDCOLOR}"
        return 1
    fi
    echo -e "${YELLOW}Testing hook: $hook_type${ENDCOLOR}"
    echo -e "${GRAY}Running: $hook_file${ENDCOLOR}"
    echo "----------------------------------------"
    "$hook_file"
    local exit_code=$?
    echo "----------------------------------------"
    if [ $exit_code -eq 0 ]; then
        echo -e "${GREEN}Hook test passed (exit code: $exit_code)${ENDCOLOR}"
    else
        echo -e "${RED}❌ Hook test failed (exit code: $exit_code)${ENDCOLOR}"
    fi
}
function show_hook {
    local hook_type="$1"
    local hooks_dir=$(get_hooks_dir)
    local hook_file="$hooks_dir/$hook_type"
    if [ ! -f "$hook_file" ]; then
        echo -e "${RED}Hook '$hook_type' does not exist${ENDCOLOR}"
        return 1
    fi
    echo -e "${YELLOW}Hook: $hook_type${ENDCOLOR}"
    echo -e "${GRAY}File: $hook_file${ENDCOLOR}"
    if [ -x "$hook_file" ]; then
        echo -e "${GREEN}Status: Enabled (executable)${ENDCOLOR}"
    else
        echo -e "${YELLOW}Status: Disabled (not executable)${ENDCOLOR}"
    fi
    echo "----------------------------------------"
    cat "$hook_file"
    echo "----------------------------------------"
}
function install_samples {
    local hooks_dir=$(get_hooks_dir)
    if [ ! -d "$hooks_dir" ]; then
        echo -e "${RED}Git hooks directory not found: $hooks_dir${ENDCOLOR}"
        return 1
    fi
    echo -e "${YELLOW}Install Git Sample Hooks${ENDCOLOR}"
    echo
    echo -e "${YELLOW}Description:${ENDCOLOR}"
    echo "This will install all available sample hooks from Git into your repository."
    echo "Sample hooks are template scripts provided by Git for common hook scenarios."
    echo
    echo -e "${YELLOW}What will happen:${ENDCOLOR}"
    echo "• Copy all *.sample files to executable hook files"
    echo "• Skip existing hooks (no overwriting)"
    echo "• Make all installed hooks executable"
    echo "• Show summary of installed hooks"
    echo
    echo -e "${YELLOW}Available sample hooks:${ENDCOLOR}"
    local sample_count=0
    for sample_file in "$hooks_dir"/*.sample; do
        if [ -f "$sample_file" ]; then
            local hook_name=$(basename "$sample_file" .sample)
            local hook_file="$hooks_dir/$hook_name"
            if [ ! -f "$hook_file" ]; then
                echo -e "  ${GREEN}✓${ENDCOLOR} $hook_name (will be installed)"
                ((sample_count++))
            else
                echo -e "  ${YELLOW}○${ENDCOLOR} $hook_name (already exists - will be skipped)"
            fi
        fi
    done
    if [ $sample_count -eq 0 ]; then
        echo -e "${YELLOW}No new sample hooks to install${ENDCOLOR}"
        echo "All sample hooks are already installed or no sample files found."
        return
    fi
    echo
    echo -e "${YELLOW}Ready to install $sample_count sample hooks.${ENDCOLOR}"
    echo -e "${YELLOW}Continue? (y/n)${ENDCOLOR}"
    read -n 1 -p "Your choice: " choice < /dev/tty
    echo
    echo
    if [ "$choice" != "y" ] && [ "$choice" != "Y" ]; then
        echo -e "${YELLOW}Sample hook installation cancelled${ENDCOLOR}"
        return
    fi
    echo -e "${YELLOW}Installing sample hooks...${ENDCOLOR}"
    echo
    local installed_count=0
    for sample_file in "$hooks_dir"/*.sample; do
        if [ -f "$sample_file" ]; then
            local hook_name=$(basename "$sample_file" .sample)
            local hook_file="$hooks_dir/$hook_name"
            if [ ! -f "$hook_file" ]; then
                cp "$sample_file" "$hook_file"
                chmod +x "$hook_file"
                echo -e "${GREEN}✓ Installed: $hook_name${ENDCOLOR}"
                ((installed_count++))
            else
                echo -e "${YELLOW}⚠ Skipped: $hook_name (already exists)${ENDCOLOR}"
            fi
        fi
    done
    echo
    echo -e "${GREEN}Successfully installed $installed_count sample hooks${ENDCOLOR}"
    if [ $installed_count -gt 0 ]; then
        echo
        echo -e "${YELLOW}Next steps:${ENDCOLOR}"
        echo "• Use ${GREEN}gitb hook list${ENDCOLOR} to see all installed hooks"
        echo "• Use ${GREEN}gitb hook edit <hook-name>${ENDCOLOR} to customize hooks"
        echo "• Use ${GREEN}gitb hook toggle <hook-name>${ENDCOLOR} to enable/disable hooks"
        echo "• Use ${GREEN}gitb hook test <hook-name>${ENDCOLOR} to test hooks"
    fi
}
function hooks_script {
    local mode="$1"
    local hook_type="$2"
    local template="$3"
    case "$mode" in
        "")
            show_hooks_menu
        ;;
        "list"|"l")
            if [ "$hook_type" = "samples" ]; then
                list_hooks "samples"
            else
                list_hooks
            fi
        ;;
        "create"|"new"|"c")
            if [ -z "$hook_type" ]; then
                if ! hook_type=$(select_hook_type "creation"); then
                    echo -e "${YELLOW}Hook creation cancelled${ENDCOLOR}"
                    return
                fi
                if [ -z "$hook_type" ]; then
                    echo -e "${YELLOW}Hook creation cancelled${ENDCOLOR}"
                    return
                fi
                echo
                if ! template=$(select_hook_template "$hook_type"); then
                    template="basic"
                fi
                if [ -z "$template" ]; then
                    template="basic"
                fi
            fi
            if ! sanitize_git_name "$hook_type"; then
                show_sanitization_error "hook type" "Use only letters, numbers, and hyphens."
                return 1
            fi
            hook_type="$sanitized_git_name"
            create_hook "$hook_type" "$template"
        ;;
        "edit"|"e")
            if [ -z "$hook_type" ]; then
                if ! hook_type=$(select_hook_type "editing" "existing"); then
                    return
                fi
                if [ -z "$hook_type" ]; then
                    return
                fi
            fi
            if ! sanitize_git_name "$hook_type"; then
                show_sanitization_error "hook type" "Use only letters, numbers, and hyphens."
                return 1
            fi
            hook_type="$sanitized_git_name"
            edit_hook "$hook_type"
        ;;
        "toggle"|"enable"|"disable"|"t")
            if [ -z "$hook_type" ]; then
                if ! hook_type=$(select_hook_type "toggling" "existing"); then
                    return
                fi
                if [ -z "$hook_type" ]; then
                    return
                fi
            fi
            if ! sanitize_git_name "$hook_type"; then
                show_sanitization_error "hook type" "Use only letters, numbers, and hyphens."
                return 1
            fi
            hook_type="$sanitized_git_name"
            toggle_hook "$hook_type"
        ;;
        "remove"|"delete"|"rm"|"r")
            if [ -z "$hook_type" ]; then
                if ! hook_type=$(select_hook_type "removal" "existing"); then
                    return
                fi
                if [ -z "$hook_type" ]; then
                    return
                fi
            fi
            if [ "$hook_type" = "ALL" ]; then
                remove_all_hooks
                return
            fi
            if ! sanitize_git_name "$hook_type"; then
                show_sanitization_error "hook type" "Use only letters, numbers, and hyphens."
                return 1
            fi
            hook_type="$sanitized_git_name"
            remove_hook "$hook_type"
        ;;
        "test"|"run"|"check")
            if [ -z "$hook_type" ]; then
                if ! hook_type=$(select_hook_type "testing" "existing"); then
                    return
                fi
                if [ -z "$hook_type" ]; then
                    return
                fi
            fi
            if ! sanitize_git_name "$hook_type"; then
                show_sanitization_error "hook type" "Use only letters, numbers, and hyphens."
                return 1
            fi
            hook_type="$sanitized_git_name"
            test_hook "$hook_type"
        ;;
        "show"|"cat"|"view"|"s")
            if [ -z "$hook_type" ]; then
                if ! hook_type=$(select_hook_type "viewing" "existing"); then
                    return
                fi
                if [ -z "$hook_type" ]; then
                    return
                fi
            fi
            if ! sanitize_git_name "$hook_type"; then
                show_sanitization_error "hook type" "Use only letters, numbers, and hyphens."
                return 1
            fi
            hook_type="$sanitized_git_name"
            show_hook "$hook_type"
        ;;
        "install"|"samples")
            install_samples
        ;;
        "select"|"sel")
            echo -e "${YELLOW}Git Hook Type Selector${ENDCOLOR}"
            echo
            if selected_hook=$(select_hook_type "selection"); then
                if [ -n "$selected_hook" ]; then
                    echo
                    echo -e "${GREEN}Selected hook type: $selected_hook${ENDCOLOR}"
                    echo -e "${YELLOW}Description:${ENDCOLOR} $(get_hook_description "$selected_hook")"
                    echo
                    echo -e "${YELLOW}Available actions:${ENDCOLOR}"
                    echo -e "  gitb hook create $selected_hook"
                    echo -e "  gitb hook edit $selected_hook"
                    echo -e "  gitb hook test $selected_hook"
                    echo -e "  gitb hook show $selected_hook"
                fi
            fi
        ;;
        "help"|"h")
            echo -e "${YELLOW}gitb hook${ENDCOLOR} - Git hooks management"
            echo
            echo -e "${YELLOW}Usage:${ENDCOLOR}"
            echo -e "  gitb hook [command] [hook-type] [options]"
            echo
            echo -e "${YELLOW}Commands:${ENDCOLOR}"
            echo -e "  ${GREEN}<empty>${ENDCOLOR}           Show interactive action menu"
            echo -e "  ${GREEN}list, l${ENDCOLOR}           List installed hooks with status"
            echo -e "  ${GREEN}list samples${ENDCOLOR}      List installed hooks and available samples"
            echo -e "  ${GREEN}create, new, c${ENDCOLOR}    Create a new hook (interactive selector)"
            echo -e "  ${GREEN}edit, e${ENDCOLOR}           Edit an existing hook (interactive selector)"
            echo -e "  ${GREEN}toggle, t${ENDCOLOR}         Enable/disable a hook (interactive selector)"
            echo -e "  ${GREEN}remove, rm, r${ENDCOLOR}     Remove hook(s) - single or all (interactive selector)"
            echo -e "  ${GREEN}test, run${ENDCOLOR}         Test a hook by running it (interactive selector)"
            echo -e "  ${GREEN}show, cat, s${ENDCOLOR}      Show hook content (interactive selector)"
            echo -e "  ${GREEN}select, sel${ENDCOLOR}       Interactive hook type browser"
            echo -e "  ${GREEN}install, samples${ENDCOLOR}  Install all available sample hooks"
            echo -e "  ${GREEN}help, h${ENDCOLOR}           Show this help"
            echo
            echo -e "${YELLOW}Hook Types:${ENDCOLOR}"
            echo "$(get_all_hook_types)" | tr ' ' '\n' | sed 's/^/  /'
            echo
            echo -e "${YELLOW}Templates:${ENDCOLOR}"
            echo -e "  ${GREEN}basic${ENDCOLOR}                   Basic hook template (default)"
            echo -e "  ${GREEN}pre-commit-lint${ENDCOLOR}         Pre-commit linting and file checks"
            echo -e "  ${GREEN}commit-msg-conventional${ENDCOLOR} Conventional commit message validation"
            echo -e "  ${GREEN}pre-push-protection${ENDCOLOR}     Branch protection for main/master"
            echo
            echo -e "${YELLOW}Examples:${ENDCOLOR}"
            echo -e "  gitb hook                      # Show interactive action menu"
            echo -e "  gitb hook list                 # List all hooks"
            echo -e "  gitb hook create               # Interactive hook creation"
            echo -e "  gitb hook create pre-commit    # Create specific hook type"
            echo -e "  gitb hook edit                 # Interactive hook selection"
            echo -e "  gitb hook select               # Browse hook types interactively"
            echo -e "  gitb hook test                 # Interactive hook testing"
            echo -e "  gitb hook remove               # Interactive removal - single or all hooks"
            echo -e "  gitb hook install              # Install sample hooks"
        ;;
        *)
            wrong_mode "hooks" "$mode"
        ;;
    esac
} 
function print_help {
    echo -e "usage: ${YELLOW}gitb <command> <mode>${ENDCOLOR}"
    echo
    msg="${YELLOW}Command${ENDCOLOR}_\t${GREEN}Aliases${ENDCOLOR}_\t${BLUE}Description of ${BOLD}workflow${NORMAL}${BLUE} commands${ENDCOLOR}"
    msg="$msg\ncommit_c|co|com_Everything about commit creation"
    msg="$msg\npush_p|ps|pus_Pushing changes to a remote repository"
    msg="$msg\npull_pu|pl|pul_Pulling changes from a remote repository"
    msg="$msg\nbranch_b|br|bran_Managing branches"
    msg="$msg\ntag_t|tg_Managing tags"
    msg="$msg\nmerge_m|me_Merge changes to the current branch"
    msg="$msg\nrebase_r|re|base_Rebase current branch"
    msg="$msg\ncherry_ch|cp_Cherry-pick commits from other branches"
    msg="$msg\nreset_res_Easy to use git reset"
    msg="$msg\nstash_s|sta_Manage git stashes"
    msg="$msg\nhook_ho|hk_Git hooks management"
    msg="$msg\nconfig_cf|cfg|conf_Configurate gitbasher"
    msg="$msg\n_ _ _"
    msg="$msg\n${YELLOW}Command${ENDCOLOR}_\t${GREEN}Aliases${ENDCOLOR}_\t${BLUE}Description of ${BOLD}informational${NORMAL}${BLUE} commands${ENDCOLOR}"
    msg="$msg\nstatus_st_Info about repo and changed files"
    msg="$msg\nlog_l|lg_Git log with branch selection and comparison"
    msg="$msg\nreflog_rl|rlg_Open git reflog in a pretty format"
    msg="$msg\nlast-commit_lc|lastc_Show info about the last commit"
    msg="$msg\nlast-ref_lr|lastr_Show info about the last reference"
    echo -e "$(echo -e "$msg" | column -ts '_')"
    exit
}
project_name="$(get_repo_name)"
repo_url="$(get_repo)"
if [[ $is_first == "true" ]]; then 
    git config --local gitbasher.scopes ""
    echo -e "${GREEN}Thanks for using gitbasher in project '$project_name'${ENDCOLOR}"
    print_configuration
    echo
    echo -e "You can change these settings by using ${YELLOW}gitb cfg <name>${ENDCOLOR}"
    echo
fi
if [ -z $1 ] || [ "$1" == "--help" ] || [ "$1" == "help" ] || [ "$1" == "man" ]; then
    print_help
fi
case "$1" in
    commit|c|co|com)         
        commit_script $2
    ;;
    push|p|ps|pus)         
        push_script $2
    ;;
    pull|pu|pl|pul)         
        pull_script $2
    ;;
    merge|m|me)         
        merge_script $2
    ;;
    rebase|r|re|base)         
        rebase_script $2
    ;;
    cherry|ch|cp)         
        cherry_script $2 $3
    ;;
    branch|b|br|bran)         
        branch_script $2
    ;;
    tag|t|tg)         
        tag_script $2
    ;;
    config|cf|cfg|conf)         
        config_script $2
    ;;
    reset|res)
        reset_script $2
    ;;
    stash|s|sta)
        stash_script $2
    ;;
    hook|ho|hk)
        hooks_script $2 $3 $4
    ;;
    log|l|lg)
        gitlog_script $2 $3
    ;;
    reflog|rl|rlg)
        reflog
    ;;
    last-commit|lc|lastc)
        last_commit
    ;;
    last-ref|lr|lastr)
        last_ref
    ;;
    status|st)
        project_status
    ;;
    *)
        print_help
    ;;
esac
exit $?
