#!/usr/bin/env bash
if [ "$1" == "init" ]; then
git init
fi
git_check=$(git branch --show-current 2>&1)
if [[ "$git_check" == *"fatal: not a git repository"* ]]; then
echo "You can use gitb only in a git repository"
exit
fi
if ((BASH_VERSINFO[0] < 4)); then
printf "Sorry, you need at least ${YELLOW}bash-4.0${ENDCOLOR} to run gitbasher.n
If your OS is debian-based, use:
${GREEN}apt install --only-upgrade bash${ENDCOLOR}n
If your OS is Mac, use:
${GREEN}brew install bash${ENDCOLOR}nn"
exit 1;
fi
RED="\e[31m"
GREEN="\e[32m"
YELLOW="\e[33m"
BLUE="\e[34m"
PURPLE="\e[35m"
CYAN="\e[36m"
GRAY="\e[37m"
ENDCOLOR="\e[0m"
BOLD="\033[1m"
NORMAL="\033[0m"
function get_config_value {
    value=$(git config --local --get "$1")
    if [ "$value" == "" ]; then
        value=$(git config --global --get "$1")
        if [ "$value" == "" ]; then
            value=$2
        fi
    fi
    echo -e "$value"
}
current_branch=$(git branch --show-current)
main_branch=$(get_config_value gitbasher.branch "main")
if [[ "$( git branch | grep "^[\s\*]*\s*main\s*$" )" == "" ]] && [[ "$( git branch | grep "^[\s\*]*\s*master\s*$" )" != "" ]]; then
    main_branch="master"
elif [[ "$(git branch | cat)" == "" ]]; then
    main_branch=$current_branch
fi
if [ "$(get_config_value gitbasher.branch "")" == "" ]; then
    git config --local gitbasher.branch "$main_branch"
fi
origin_name=$(git remote -v | head -n 1 | sed 's/\t.*//')
if [ "$origin_name" == "" ]; then 
    echo -e "${YELLOW}There is no configured remote in this repo!${ENDCOLOR}"
    echo
    echo -e "Use ${BLUE}git remote add origin <url>${ENDCOLOR} to add it manually"
    echo -e "Press '${BOLD}y${ENDCOLOR}' to add it now or an any key to exit"
    read -n 1 -s choice
    if [ "$choice" != "y" ]; then
        exit
    fi
    echo
    read -p "Remote repo URL: " -e remote_url
    if [ "$remote_url" == "" ]; then
        exit
    fi
    remote_check=$(git ls-remote "$remote_url" 2>&1)
    if [[ "$remote_check" == *"does not appear to be a git"* ]]; then
        echo
        echo -e "${RED}'$remote_url' is not a git repository!${ENDCOLOR}"
        echo "Please make sure you have the correct access rights and the repository exists."
        exit
    fi
    git remote add origin "$remote_url"
    echo -e "${GREEN}Remote successfully added!${ENDCOLOR}"
    if [ "$remote_check" == "" ]; then
        echo -e "${YELLOW}Repository '$remote_url' is probably empty${ENDCOLOR}"
    fi
    echo
    origin_name=$(git remote -v | head -n 1 | sed 's/\t.*//')
fi
sep=$(get_config_value gitbasher.sep "-")
editor=$(get_config_value core.editor "vi")
ticket_name=$(get_config_value gitbasher.ticket "")
scopes=$(get_config_value gitbasher.scopes "")
is_first=$(get_config_value gitbasher.isfirst "true")
git config --local gitbasher.isfirst "false"
RED_ES="\x1b[31m"
GREEN_ES="\x1b[32m"
YELLOW_ES="\x1b[33m"
BLUE_ES="\x1b[34m"
PURPLE_ES="\x1b[35m"
CYAN_ES="\x1b[36m"
GRAY_ES="\x1b[37m"
ENDCOLOR_ES="\x1b[0m"
function get_config_value {
    value=$(git config --local --get "$1")
    if [ "$value" == "" ]; then
        value=$(git config --global --get "$1")
        if [ "$value" == "" ]; then
            value=$2
        fi
    fi
    echo -e "$value"
}
function set_config_value {
    if [ -z $3 ]; then
        git config --local "$1" "$2"
    else
        git config --global "$1" "$2"
    fi
    echo "$2"
}
function wrong_mode {
    if [ -n "$2" ]; then
        echo -e "Unknown mode ${YELLOW}$2${ENDCOLOR} for ${YELLOW}gitb $1${ENDCOLOR}"
        echo -e "Use ${GREEN}gitb $1 help${ENDCOLOR} to get usage info"
        exit
    fi
}
function get_repo {
    repo=$(git config --get "remote.${origin_name}.url")
    repo="${repo/"com:"/"com/"}"
    repo="${repo/"io:"/"io/"}"
    repo="${repo/"org:"/"org/"}"
    repo="${repo/"net:"/"net/"}"
    repo="${repo/"dev:"/"dev/"}"
    repo="${repo/"ru:"/"ru/"}"
    repo="${repo/"git@"/"https://"}"
    repo="${repo/".git"/""}" 
    echo "$repo"
}
function get_repo_name {
    repo=$(get_repo)
    echo "${repo##*/}"
}
function print_configuration {
    echo -e "${YELLOW}Current configuration:${ENDCOLOR}"
    echo -e "\tuser.name:\t${YELLOW}$(get_config_value user.name)${ENDCOLOR}"
    echo -e "\tuser.email:\t${YELLOW}$(get_config_value user.email)${ENDCOLOR}"
    echo -e "\tdefault:\t${YELLOW}$main_branch${ENDCOLOR}"
    echo -e "\tseparator:\t${YELLOW}$sep${ENDCOLOR}"
    echo -e "\teditor:\t\t${YELLOW}$editor${ENDCOLOR}"
    if [ "$ticket_name" != "" ]; then
        echo -e "\tticket:\t\t${YELLOW}$ticket_name${ENDCOLOR}"
    fi
    if [ "$scopes" != "" ]; then
        echo -e "\tscopes:\t\t${YELLOW}$scopes${ENDCOLOR}"
    fi
    local ai_key=$(get_ai_api_key)
    if [ -n "$ai_key" ]; then
        ai_key=$(mask_api_key "$ai_key")
        echo -e "\tAI key:\t\t${GREEN}$ai_key${ENDCOLOR}"
    else
        echo -e "\tAI key:\t\t${RED}not set${ENDCOLOR}"
    fi
    local ai_proxy=$(get_ai_proxy)
    if [ -n "$ai_proxy" ]; then
        echo -e "\tAI proxy:\t${GREEN}$ai_proxy${ENDCOLOR}"
    else
        echo -e "\tAI proxy:\t${YELLOW}not set${ENDCOLOR}"
    fi
}
function escape {
    string="$1"
    sub="$2"
    escaped="\\$sub"
    echo "${string//${sub}/${escaped}}"
}
function check_code {
    if [ $1 != 0 ]; then
        echo
        echo
        echo -e "${RED}Error during $3!${ENDCOLOR}"
        echo -e "$2"
        if [ -n "$git_add" ]; then
            git restore --staged "$git_add"
        fi
        exit $1
    fi
}
function yes_no_choice {
    while [ true ]; do
        read -n 1 -s choice
        if [ "$choice" == "y" ]; then
            if [ -n "$1" ]; then
                echo -e "${YELLOW}$1${ENDCOLOR}"
                if [ -z $2 ]; then
                    echo
                fi
            fi
            return
        fi
        if [ "$choice" == "n" ]; then
            exit
        fi
    done
}
function choose {
    values=("$@")
    number_of_values=${#values[@]}
    while [ true ]; do
        if [ $number_of_values -gt 9 ]; then
            read -p "$read_prefix" -e -n 2 choice
        else
            read -p "$read_prefix" -n 1 -s choice
        fi
        if [ "$choice" == "0" ] || [ "$choice" == "00" ]; then
            if [ -n "$git_add" ]; then
                git restore --staged "$git_add"
            fi
            if [ $number_of_values -le 9 ]; then
                printf $choice
            fi
            exit
        fi
        re='^[0-9=]+$'
        if ! [[ $choice =~ $re ]]; then
            if [ -n "$git_add" ]; then
                git restore --staged "$git_add"
            fi
            exit
        fi
        if [ "$choice" == "=" ] || [ "$choice" == "==" ]; then
            pressed_alt="true"
            break
        fi
        index=$(($choice-1))
        choice_result=${values[index]}
        if [ -n "$choice_result" ]; then
            if [ $number_of_values -le 9 ]; then
                printf $choice
            fi
            break
        else
            if [ $number_of_values -gt 9 ]; then
                if [ -n "$git_add" ]; then
                    git restore --staged "$git_add"
                fi
                exit
            fi
        fi
    done
}
function git_status {
    status_output=$(git status --short)
    status_output=$(echo "$status_output" | sed "s/^ D/${RED_ES}\tDeleted: ${ENDCOLOR_ES}/")
    status_output=$(echo "$status_output" | sed "s/^D /${GREEN_ES}Staged\t${RED_ES}Deleted: ${ENDCOLOR_ES}/")
    status_output=$(echo "$status_output" | sed "s/^ M/${YELLOW_ES}\tModified:${ENDCOLOR_ES}/")
    status_output=$(echo "$status_output" | sed "s/^MM/${GRAY_ES}Old\t${YELLOW_ES}Modified:${ENDCOLOR_ES}/")
    status_output=$(echo "$status_output" | sed "s/^AM/${GRAY_ES}Old\t${YELLOW_ES}Modified:${ENDCOLOR_ES}/")
    status_output=$(echo "$status_output" | sed "s/^M /${GREEN_ES}Staged\t${YELLOW_ES}Modified:${ENDCOLOR_ES}/")
    status_output=$(echo "$status_output" | sed "s/^A/${GREEN_ES}Staged\tAdded:   ${ENDCOLOR_ES}/")
    status_output=$(echo "$status_output" | sed "s/^??/${GREEN_ES}\tAdded:   ${ENDCOLOR_ES}/")
    echo -e "$status_output"
}
function commit_list {
    ref=$3
    if [[ "$(git --no-pager log -n 1 2>&1)" == *"does not have any commits yet"* ]]; then
        if [[ "$3" == *"HEAD"* ]]; then
            ref="$(echo "$3" | sed 's/HEAD..//')"
        else
            return 
        fi
    fi
    IFS=$'\n' 
    read -rd '' -a commits_info <<<"$(git --no-pager log -n $1 --pretty="${YELLOW_ES}%h${ENDCOLOR_ES} | %s | ${BLUE_ES}%an${ENDCOLOR_ES} | ${GREEN_ES}%cr${ENDCOLOR_ES}" $ref | column -ts'|')"
    read -rd '' -a commits_hash <<<"$(git --no-pager log -n $1 --pretty="%h"$ref)"
    for index in "${!commits_info[@]}"
    do
        line=${commits_info[index]}
        if [ $2 == "number" ]; then
            line="$(($index+1)). ${line}"
        elif [ $2 == "tab" ]; then
            line="\t${line}"
        fi
        echo -e "$line"
    done
}
function ref_list {
    IFS=$'\n' 
    read -rd '' -a refs_info <<<"$(git --no-pager reflog -n $1 --pretty="${YELLOW_ES}%h${ENDCOLOR_ES} | ${BLUE_ES}%gd${ENDCOLOR_ES} | %gs | ${GREEN_ES}%cr${ENDCOLOR_ES}" | column -ts'|')"
    read -rd '' -a refs_hash <<<"$(git --no-pager reflog -n $1 --pretty="%gd")"
    refs_info=("${refs_info[@]:1}")
    refs_hash=("${refs_hash[@]:1}")
    for index in "${!refs_info[@]}"
    do
        line="$(($index+1)). ${refs_info[index]}"
        echo -e "$line"
    done
}
function choose_commit {
    commit_list $1 "number"
    if [ $1 -gt 9 ]; then
        echo "00. Exit"
    else
        echo "0. Exit"
    fi
    echo "Enter = to show more"
    echo
    read_prefix="Enter commit number: "
    choose "${commits_hash[@]}"
    commit_hash=$choice_result
    if [ -n "$pressed_alt" ]; then
        commit_list 50 "number"
        echo "00. Exit"
        echo
        choose "${commits_hash[@]}"
        commit_hash=$choice_result
    fi
    echo
}
function print_changes_stat {
    IFS=$'\n' read -rd '' -a stats <<< "$1"
    result_stat=""
    bottom_line=""
    number_of_stats=${#stats[@]}
    for index in "${!stats[@]}"
    do
        s=$(echo ${stats[index]} | sed -e 's/^[[:space:]]*//')
        s=$(sed "s/+/${GREEN_ES}+${ENDCOLOR_ES}/g" <<< ${s})
        s=$(sed "s/-/${RED_ES}-${ENDCOLOR_ES}/g" <<< ${s})
        if [ $(($index+1)) == $number_of_stats ]; then
            #s=$(sed '1 s/,/|/' <<< ${s})
            bottom_line="${s}"
            break
        fi
        result_stat="${result_stat}\n${s}"
    done
    echo -e "$(echo -e "${result_stat}" | column -ts'|')"
    echo -e "$bottom_line"
}
function get_push_list {
    push_list_check=$(git --no-pager log $3/$1..HEAD 2>&1)
    if [[ $push_list_check != *"unknown revision or path not in the working tree"* ]]; then
        push_list=$(commit_list 999 "tab" $3/$1..HEAD)
        history_from="$3/$1"
        return
    fi
    if [[ $push_list_check == *"unknown revision or path not in the working tree"* ]]; then
        if [[ $1 == $2 ]]; then
            push_list=$(commit_list 999 "tab")
            history_from="$3/$1"
            return
        fi
    fi
    base_commit=$(diff -u <(git rev-list --first-parent $1) <(git rev-list --first-parent $2) | sed -ne 's/^ //p' | head -1)
    if [ -n "$base_commit" ]; then
        push_list=$(commit_list 999 "tab" $base_commit..HEAD)
        history_from="${base_commit::7}"
    else
        push_list=$(commit_list 999 "tab" $3/$2..HEAD)
        history_from="$3/$2"
    fi
}
function list_branches {
    args="--sort=-committerdate"
    if [[ "$1" == "remote" ]]; then
        args="--sort=-committerdate -r"
    fi
    branches_str=$(git --no-pager branch $args --format="%(refname:short)")
    branches_info_str=$(git --no-pager branch $args --format="${BLUE_ES}%(refname:short)${ENDCOLOR_ES} | %(contents:subject) | ${YELLOW_ES}%(objectname:short)${ENDCOLOR_ES}  | ${GREEN_ES}%(committerdate:relative)${ENDCOLOR_ES}" | column -ts'|' )
    IFS=$'\n' 
    read -rd '' -a branches <<< "$branches_str"
    read -rd '' -a branches_info <<< "$branches_info_str"
    number_of_branches=${#branches[@]}
    if [[ "$1" == "remote" ]]; then
        ((number_of_branches=number_of_branches-1))
    fi
    if [[ "$number_of_branches" == 0 ]]; then
        echo
        echo -e "${YELLOW}There is no branches${ENDCOLOR}"
        to_exit="true"
        return
    fi
    branch_to_check="${branches[0]}"
    if [[ "$1" == "remote" ]]; then
        branch_to_check="${branches[1]}"
        branch_to_check="$(sed "s/${origin_name}\///g" <<< ${branch_to_check})"
    fi
    if [[ "$number_of_branches" == 1 ]] && [[ "${branch_to_check}" == "${current_branch}" ]]; then
        echo
        echo -e "There is only one branch: ${YELLOW}${current_branch}${ENDCOLOR}"
        to_exit="true"
        return
    fi
    if [[ "$1" == "delete" ]] && [[ "$number_of_branches" == 2 ]] && [[ "${current_branch}" != "${main_branch}" ]]; then
        echo
        echo -e "${YELLOW}There are no branches to delete${ENDCOLOR}"
        to_exit="true"
        return
    fi
    branches_first_main=(${main_branch})
    branches_info_first_main=("dummy")
    if [[ "$1" == "delete" ]]; then
        branches_first_main=()
        branches_info_first_main=()
    fi
    if [[ "$1" == "merge" ]] && [[ "$current_branch" == "$main_branch" ]]; then
        branches_first_main=()
        branches_info_first_main=()
    fi
    for index in "${!branches[@]}"
    do
        branch_to_check="${branches[index]}"
        if [[ "$1" == "delete" ]]; then
            if [[ "$branch_to_check" == "${current_branch}"* ]] || [[ "$branch_to_check" == "${main_branch}"* ]]; then
                continue    
            fi
        fi
        if [[ "$1" == "merge" ]]; then
            if [[ "$branch_to_check" == "${current_branch}"* ]]; then
                continue
            fi
        fi
        if [[ "$1" == "remote" ]]; then
            branch_to_check="$(sed "s/${origin_name}\///g" <<< ${branch_to_check})"
        fi
        if [[ "$branch_to_check" == "${main_branch}"* ]]; then
            branches_info_first_main[0]="${branches_info[index]}"
        elif [[ "$branch_to_check" != "HEAD->"* ]] && [[ "$branch_to_check" != "$origin_name" ]]; then 
            branches_first_main+=(${branches[index]})
            branches_info_first_main+=("${branches_info[index]}")
        fi
    done
    for index in "${!branches_info_first_main[@]}"
    do
        branch=$(escape "${branches_first_main[index]}" "/")
        if [[ "$1" == "remote" ]] && [[ "$branch" != "origin"* ]]; then
            branch="$origin_name\/$branch"
        fi
        branch_line="${branches_info_first_main[index]}"
        if [ "${branches_first_main[index]}" == "$current_branch" ]; then
            echo -e "$(($index+1)). * $branch_line"
        else
            echo -e "$(($index+1)).   $branch_line"
        fi
    done
}
function choose_branch {
    list_branches $1
    if [ -n "$to_exit" ]; then
        exit
    fi
    echo
    printf "Enter branch number: "
    choose "${branches_first_main[@]}"
    branch_name=$choice_result
    if [[ "$1" == "remote" ]]; then
        branch_name=$(sed "s/${origin_name}\///g" <<< ${branch_name})
    fi
    echo
}
function switch {
    switch_output=$(git switch $1 2>&1)
    switch_code=$?
    if [ "$switch_code" == 0 ]; then
        if [ "$current_branch" == "$1" ]; then
            echo -e "${GREEN}Already on '$1'${ENDCOLOR}"
        else
            echo -e "${GREEN}Switched to branch '$1'${ENDCOLOR}"
            changes=$(git_status)
            if [ -n "$changes" ] && [ -z $2 ]; then
                echo
                echo -e "${YELLOW}Moved changes:${ENDCOLOR}"
                echo -e "$changes"
            fi
        fi
        if [ -z $2 ]; then
            get_push_list $1 ${main_branch} ${origin_name}
            if [ -n "$push_list" ]; then
                echo
                count=$(echo -e "$push_list" | wc -l | sed 's/^ *//;s/ *$//')
                echo -e "Your branch ${YELLOW}$1${ENDCOLOR} is ahead ${YELLOW}${history_from}${ENDCOLOR} by ${BOLD}$count${ENDCOLOR} commits"
                echo -e "$push_list"
            fi
        fi
        return
    fi
    if [[ $switch_output == *"Your local changes to the following files would be overwritten"* ]]; then
        conflicts="$(echo "$switch_output" | tail -r | tail -n +3 | tail -r | tail -n +2)"
        echo -e "${RED}Changes would be overwritten by switch to '$1':${ENDCOLOR}"       
        echo -e "${conflicts//[[:blank:]]/}"
        echo
        echo -e "${YELLOW}Commit these files and try to switch for one more time${ENDCOLOR}"
        exit
    fi
    if [ $switch_code -ne 0 ]; then
        echo -e "${RED}Cannot switch to '$main_branch'! Error message:${ENDCOLOR}"
        echo -e "$switch_output"
        exit $switch_code
    fi
}
function get_ai_api_key {
    get_config_value gitbasher.ai-api-key ""
}
function set_ai_api_key {
    set_config_value gitbasher.ai-api-key "$1"
}
function get_ai_proxy {
    get_config_value gitbasher.ai-proxy ""
}
function set_ai_proxy {
    set_config_value gitbasher.ai-proxy "$1"
}
function clear_ai_proxy {
    git config --unset gitbasher.ai-proxy 2>/dev/null
}
function get_ai_diff_limit {
    get_config_value gitbasher.ai-diff-limit "50"
}
function set_ai_diff_limit {
    set_config_value gitbasher.ai-diff-limit "$1"
}
function mask_api_key {
    local api_key="$1"
    if [ -z "$api_key" ]; then
        echo ""
        return
    fi
    local length=${#api_key}
    if [ $length -le 4 ]; then
        echo "$api_key"
        return
    fi
    local visible_chars="${api_key:(-4)}"
    echo "********${visible_chars}"
}
function get_limited_diff_for_ai {
    local diff_limit=$(get_ai_diff_limit)
    local max_chars=3000  # Approximate token limit (~750 tokens)
    local diff_content=$(git diff --cached | head -n "$diff_limit")
    local char_count=${#diff_content}
    if [ "$char_count" -gt "$max_chars" ]; then
        diff_content=$(echo "$diff_content" | head -c "$max_chars")
        diff_content="${diff_content}... [truncated for token limit]"
    fi
    echo "$diff_content"
}
function call_gemini_api {
    local prompt="$1"
    local api_key=$(get_ai_api_key)
    if [ -z "$api_key" ]; then
        echo -e "${RED}AI API key not configured. Set it with: gitb config${ENDCOLOR}" >&2
        return 1
    fi
    local escaped_prompt=$(echo "$prompt" | sed 's/\\/\\\\/g' | sed 's/"/\\"/g' | tr '\n' ' ' | sed 's/  */ /g')
    local json_payload="{
        \"contents\": [{
            \"parts\": [{
                \"text\": \"$escaped_prompt\"
            }]
        }],
        \"generationConfig\": {
            \"temperature\": 0.1,
            \"maxOutputTokens\": 100,
            \"topP\": 0.8,
            \"topK\": 10
        }
    }"
    local proxy_url=$(get_ai_proxy)
    local response=""
    if [ -n "$proxy_url" ]; then
        response=$(curl -s -X POST \
            --proxy "$proxy_url" \
            "https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${api_key}" \
            -H "Content-Type: application/json" \
            -d "$json_payload" 2>/dev/null)
    else
        response=$(curl -s -X POST \
            "https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${api_key}" \
            -H "Content-Type: application/json" \
            -d "$json_payload" 2>/dev/null)
    fi
    if [ $? -ne 0 ] || [ -z "$response" ]; then
        echo -e "${RED}Failed to connect to AI service${ENDCOLOR}" >&2
        return 1
    fi
    local has_error=$(echo "$response" | grep -q '"error"' && echo "true" || echo "false")
    if [ "$has_error" = "true" ]; then
        local error_code=$(echo "$response" | grep -o '"code"[[:space:]]*:[[:space:]]*[0-9]*' | grep -o '[0-9]*')
        local error_message=$(echo "$response" | grep -o '"message"[[:space:]]*:[[:space:]]*"[^"]*"' | sed 's/"message"[[:space:]]*:[[:space:]]*"\([^"]*\)"/\1/')
        echo -e "${RED}AI API Error${ENDCOLOR}" >&2
        if [ -n "$error_code" ]; then
            echo -e "${RED}Error Code: $error_code${ENDCOLOR}" >&2
        fi
        if [ -n "$error_message" ]; then
            echo -e "${RED}Error Message: $error_message${ENDCOLOR}" >&2
        fi
        echo >&2
        case "$error_code" in
            400)
                if [[ "$error_message" == *"location is not supported"* ]]; then
                    echo -e "${YELLOW}âš ï¸  Geographic restriction: Google's Gemini API is not available in your region.${ENDCOLOR}" >&2
                    echo -e "${YELLOW}Solutions:${ENDCOLOR}" >&2
                    echo -e "${YELLOW}  â€¢ Configure proxy with: gitb cfg proxy${ENDCOLOR}" >&2
                    echo -e "${YELLOW}  â€¢ Use a VPN to connect from a supported region${ENDCOLOR}" >&2
                    echo -e "${YELLOW}  â€¢ Use manual commit messages for now${ENDCOLOR}" >&2
                else
                    echo -e "${YELLOW}âš ï¸  Bad request: Check your API configuration or prompt format.${ENDCOLOR}" >&2
                    echo -e "${YELLOW}Solutions:${ENDCOLOR}" >&2
                    echo -e "${YELLOW}  â€¢ Verify your API key is correct${ENDCOLOR}" >&2
                    echo -e "${YELLOW}  â€¢ Try again with a smaller commit diff${ENDCOLOR}" >&2
                fi
                ;;
            401|403)
                echo -e "${YELLOW}ðŸ” Authentication error: Invalid or expired API key.${ENDCOLOR}" >&2
                echo -e "${YELLOW}Solutions:${ENDCOLOR}" >&2
                echo -e "${YELLOW}  â€¢ Check your API key with: gitb cfg ai${ENDCOLOR}" >&2
                echo -e "${YELLOW}  â€¢ Generate a new API key at: https://makersuite.google.com/app/apikey${ENDCOLOR}" >&2
                echo -e "${YELLOW}  â€¢ Ensure your API key has proper permissions${ENDCOLOR}" >&2
                ;;
            429)
                echo -e "${YELLOW}â±ï¸  Rate limit exceeded: Too many requests.${ENDCOLOR}" >&2
                echo -e "${YELLOW}Solutions:${ENDCOLOR}" >&2
                echo -e "${YELLOW}  â€¢ Wait a few minutes and try again${ENDCOLOR}" >&2
                echo -e "${YELLOW}  â€¢ Consider upgrading your API plan for higher limits${ENDCOLOR}" >&2
                ;;
            500|502)
                echo -e "${YELLOW}ðŸ”§ Server error: Google's service is experiencing issues.${ENDCOLOR}" >&2
                echo -e "${YELLOW}Solutions:${ENDCOLOR}" >&2
                echo -e "${YELLOW}  â€¢ Try again in a few minutes${ENDCOLOR}" >&2
                echo -e "${YELLOW}  â€¢ Check Google's API status page${ENDCOLOR}" >&2
                ;;
            503)
                echo -e "${YELLOW}ðŸ“Š Service overloaded: Google's servers are busy.${ENDCOLOR}" >&2
                echo -e "${YELLOW}Solutions:${ENDCOLOR}" >&2
                echo -e "${YELLOW}  â€¢ Try again in a few minutes${ENDCOLOR}" >&2
                echo -e "${YELLOW}  â€¢ Retry during off-peak hours${ENDCOLOR}" >&2
                ;;
            *)
                if [[ "$error_message" == *"suspended"* ]]; then
                    echo -e "${YELLOW}ðŸš« Account suspended: Your API access has been suspended.${ENDCOLOR}" >&2
                    echo -e "${YELLOW}Solutions:${ENDCOLOR}" >&2
                    echo -e "${YELLOW}  â€¢ Contact Google Support to resolve account issues${ENDCOLOR}" >&2
                    echo -e "${YELLOW}  â€¢ Check your Google Cloud Console for notices${ENDCOLOR}" >&2
                elif [[ "$error_message" == *"location is not supported"* ]]; then
                    echo -e "${YELLOW}âš ï¸  Geographic restriction: Google's Gemini API is not available in your region.${ENDCOLOR}" >&2
                    echo -e "${YELLOW}Solutions:${ENDCOLOR}" >&2
                    echo -e "${YELLOW}  â€¢ Configure proxy with: gitb cfg proxy${ENDCOLOR}" >&2
                    echo -e "${YELLOW}  â€¢ Use a VPN to connect from a supported region${ENDCOLOR}" >&2
                    echo -e "${YELLOW}  â€¢ Use manual commit messages for now${ENDCOLOR}" >&2
                else
                    echo -e "${YELLOW}â“ Unknown error occurred.${ENDCOLOR}" >&2
                    echo -e "${YELLOW}Solutions:${ENDCOLOR}" >&2
                    echo -e "${YELLOW}  â€¢ Check Google's API documentation${ENDCOLOR}" >&2
                    echo -e "${YELLOW}  â€¢ Try again later${ENDCOLOR}" >&2
                fi
                ;;
        esac
        return 1
    fi
    local ai_response=""
    ai_response=$(echo "$response" | sed -n 's/.*"text"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/p' | head -1)
    if [ -z "$ai_response" ]; then
        ai_response=$(echo "$response" | sed -n 's/.*"candidates".*"text"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/p' | head -1)
    fi
    if [ -z "$ai_response" ]; then
        ai_response=$(echo "$response" | sed -n 's/.*"content".*"parts".*"text"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/p' | head -1)
    fi
    if [ -n "$ai_response" ]; then
        ai_response=$(echo "$ai_response" | sed 's/\\n/\n/g' | sed 's/\\"/"/g' | sed 's/\\\\//g')
    fi
    if [ -z "$ai_response" ]; then
        echo -e "${RED}Failed to parse AI response${ENDCOLOR}" >&2
        echo -e "${YELLOW}Raw API response:${ENDCOLOR}" >&2
        echo "$response" | head -5 >&2
        echo -e "${YELLOW}...${ENDCOLOR}" >&2
        echo -e "${YELLOW}To see full response, enable debug mode in ai.sh${ENDCOLOR}" >&2
        return 1
    fi
    echo "$ai_response"
}
function check_ai_available {
    if ! command -v curl >/dev/null 2>&1; then
        echo -e "${RED}curl is required for AI functionality but not installed${ENDCOLOR}" >&2
        return 1
    fi
    local api_key=$(get_ai_api_key)
    if [ -z "$api_key" ]; then
        echo -e "${RED}AI API key not configured${ENDCOLOR}" >&2
        echo -e "${YELLOW}Configure it with: gitb cfg ai${ENDCOLOR}" >&2
        return 1
    fi
    return 0
}
function generate_ai_commit_message {
    local staged_files=$(git diff --name-only --cached)
    if [ -z "$staged_files" ]; then
        echo -e "${RED}No staged files found${ENDCOLOR}" >&2
        return 1
    fi
    local diff_content=$(git diff --cached --stat)
    local diff_details=$(get_limited_diff_for_ai)
    local prompt="Analyze the following git changes and generate a conventional commit message in the format 'type(scope): subject'.
Available types:
- feat: new feature, logic change or performance improvement
- fix: small changes, bug fix
- refactor: code change that neither fixes a bug nor adds a feature, style changes
- test: adding missing tests or changing existing tests
- build: changes that affect the build system or external dependencies
- ci: changes to CI configuration files and scripts
- chore: maintenance and housekeeping
- docs: documentation changes
Staged files:
$staged_files
File changes summary:
$diff_content
Code changes (partial):
$diff_details
Generate ONLY the commit message in the format 'type(scope): subject'. The subject should:
- Use imperative mood (e.g., 'add', 'fix', 'update')
- Be lowercase
- Not end with a period
- Be concise and descriptive
If you can determine a meaningful scope from the file paths, include it. Otherwise, omit the scope.
Respond with only the commit message, nothing else."
    call_gemini_api "$prompt"
}
function generate_ai_commit_message_subject {
    local staged_files=$(git diff --name-only --cached)
    if [ -z "$staged_files" ]; then
        echo -e "${RED}No staged files found${ENDCOLOR}" >&2
        return 1
    fi
    local diff_content=$(git diff --cached --stat)
    local diff_details=$(get_limited_diff_for_ai)
    local prompt="Analyze the following git changes and generate a conventional commit message that will be after appended to $1'.
Staged files:
$staged_files
File changes summary:
$diff_content
Code changes (partial):
$diff_details
Generate ONLY the commit message. The message should:
- Use imperative mood (e.g., 'add', 'fix', 'update')
- Be lowercase
- Not end with a period
- Be concise and descriptive
Respond with only the commit message without any other text, nothing else."
    call_gemini_api "$prompt"
}
function generate_ai_commit_message_full {
    local staged_files=$(git diff --name-only --cached)
    if [ -z "$staged_files" ]; then
        echo -e "${RED}No staged files found${ENDCOLOR}" >&2
        return 1
    fi
    local diff_content=$(git diff --cached --stat)
    local diff_details=$(get_limited_diff_for_ai)
    local prompt="Analyze the following git changes and generate a conventional commit message in the format 'type(scope): subject'.
Also write a body for the commit message, where you can explain why you are making the change.
Available types:
- feat: new feature, logic change or performance improvement
- fix: small changes, bug fix
- refactor: code change that neither fixes a bug nor adds a feature, style changes
- test: adding missing tests or changing existing tests
- build: changes that affect the build system or external dependencies
- ci: changes to CI configuration files and scripts
- chore: maintenance and housekeeping
- docs: documentation changes
Staged files:
$staged_files
File changes summary:
$diff_content
Code changes (partial):
$diff_details
Generate ONLY the commit message in the format 'type(scope): subject' with body. The subject should:
- Use imperative mood (e.g., 'add', 'fix', 'update')
- Be lowercase
- Not end with a period
- Be concise and descriptive
If you can determine a meaningful scope from the file paths, include it. Otherwise, omit the scope.
The body should explain why you are making the change. The length of the body should be 1-2 sentences, not more.
Respond with only the full commit message, nothing else."
    call_gemini_api "$prompt"
}
function set_default_branch {
    echo -e "${YELLOW}Fetching remote branches...${ENDCOLOR}"
    echo
    fetch_output=$(git fetch 2>&1)
    check_code $? "$fetch_output" "fetch remote"
    prune_output=$(git remote prune $origin_name 2>&1)
    echo -e "Current gitbasher default branch: ${YELLOW}$main_branch${ENDCOLOR}"
    echo
    echo -e "${YELLOW}Select a branch to make it default in gitbasher${ENDCOLOR}"
    choose_branch "remote"
    echo 
    main_branch=$(set_config_value gitbasher.branch $branch_name)
    echo -e "${GREEN}Set '${branch_name}' as a default gitbasher branch in '${project_name}' repo${ENDCOLOR}"
    echo
    echo -e "Do you want to set it ${YELLOW}globally${ENDCOLOR} for all projects (y/n)?"
    yes_no_choice "\nSet '${branch_name}' globally" "true"
    main_branch=$(set_config_value gitbasher.branch $branch_name "true")
}
function set_sep {
    echo -e "${YELLOW}Select a branch name separator${ENDCOLOR}"
    echo
    echo -e "Separator is a symbol between type and name, e.g. ${YELLOW}name${sep}name${ENDCOLOR}"
    echo -e "Current separator: ${YELLOW}$sep${ENDCOLOR}"
    echo -e "1. type${YELLOW}/${ENDCOLOR}name"
    echo -e "2. type${YELLOW}_${ENDCOLOR}name"
    echo -e "3. type${YELLOW}-${ENDCOLOR}name"
    echo -e "4. type${YELLOW}.${ENDCOLOR}name"
    echo -e "5. type${YELLOW},${ENDCOLOR}name"
    echo -e "6. type${YELLOW}+${ENDCOLOR}name"
    echo -e "7. type${YELLOW}=${ENDCOLOR}name"
    echo -e "8. type${YELLOW}@${ENDCOLOR}name"
    echo "0. Exit without changes"
    declare -A seps=(
            [1]="/"
            [2]="_"
            [3]="-"
            [4]="."
            [5]=","
            [6]="+"
            [7]="="
            [8]="@"
        )
    while [ true ]; do
        read -n 1 -s choice
        if [ "$choice" == "0" ]; then
            exit
        fi
        re='^[0-9]+$'
        if ! [[ $choice =~ $re ]]; then
            continue
        fi
        new_sep="${seps[$choice]}"
        if [ -n "$new_sep" ]; then
            break
        fi
    done
    echo
    sep=$(set_config_value gitbasher.sep $new_sep)
    echo -e "${GREEN}Set '${sep}' as a branch name separator in '${project_name}' repo${ENDCOLOR}"
    echo
    echo -e "Do you want to set it ${YELLOW}globally${ENDCOLOR} for all projects (y/n)?"
    yes_no_choice "\nSet '${sep}' globally" "true"
    sep=$(set_config_value gitbasher.sep $branch_name $new_sep)
}
function set_editor {
    echo -e "${YELLOW}Enter an editor for commit messages${ENDCOLOR}"
    echo
    echo -e "Enter the bin name of editor to run for creating commit messages (e.g. 'vi' or 'nano')"
    echo -e "It will override ${YELLOW}core.editor${ENDCOLOR} git config value, press Enter if you want to exit"
    echo -e "Current editor: ${YELLOW}${editor}${ENDCOLOR}"
    read -p "Editor: " choice
    if [ "$choice" == "" ]; then
        exit
    fi
    echo
    which_output=$(which $choice)
    if [ "${which_output}" == *"not found"* ] || [ "${which_output}" == "" ]; then
        echo -e "${RED}Binary '${choice}' not found!${ENDCOLOR}"
        exit
    fi
    editor=$(set_config_value core.editor $choice)
    echo -e "${GREEN}Use editor '$editor' located at '$which_output'${ENDCOLOR}"
    echo
    echo -e "Do you want to set it ${YELLOW}globally${ENDCOLOR} for all projects (y/n)?"
    yes_no_choice "\nSet '${editor}' globally" "true"
    sep=$(set_config_value core.editor $branch_name $new_sep)
}
function set_ticket {
    echo -e "${YELLOW}Enter a ticket prefix${ENDCOLOR}"
    echo
    if [ -z $ticket_name ]; then
        echo -e "${YELLOW}Ticket prefix is not set in gitbasher${ENDCOLOR}"
    else
        echo -e "Current ticket prefix: ${YELLOW}$ticket_name${ENDCOLOR}"
    fi
    read -p "Ticket prefix: " -e ticket_name
    if [ -z $ticket_name ]; then
        exit
    fi
    ticket_name="${ticket_name##*( )}"
    echo 
    ticket_name=$(set_config_value gitbasher.ticket $ticket_name)
    echo -e "${GREEN}Set '${ticket_name}' as a ticket name in '${project_name}' repo${ENDCOLOR}"
    echo
    echo -e "Do you want to set it ${YELLOW}globally${ENDCOLOR} for all projects (y/n)?"
    yes_no_choice "\nSet '${ticket_name}' globally" "true"
    ticket_name=$(set_config_value gitbasher.ticket $ticket_name "true")
}
function configure_ai_key {
    echo -e "${YELLOW}Enter AI API key${ENDCOLOR}"
    echo
    ai_api_key=$(get_ai_api_key)
    if [ -z "$ai_api_key" ]; then
        echo -e "${YELLOW}AI API key is not set${ENDCOLOR}"
    else
        echo -e "AI API key is ${GREEN}configured${ENDCOLOR}: ${BLUE}$(mask_api_key "$ai_api_key")${ENDCOLOR}"
    fi
    echo -e "Enter your ${YELLOW}Gemini API key${ENDCOLOR} to enable AI commit message generation"
    echo -e "Get your API key from: ${BLUE}https://aistudio.google.com/app/apikey${ENDCOLOR}"
    echo -e "Press Enter to exit without changes or enter 0 to remove existing key"
    echo
    echo -e "${YELLOW}API key enters silently, so you can't see it, but it is entered${ENDCOLOR}"
    read -p "API Key: " -s ai_key_input
    echo
    if [ "$ai_key_input" == "" ]; then
        exit
    fi
    if [ "$ai_key_input" == "0" ]; then
        git config --local --unset gitbasher.ai-api-key 2>/dev/null
        echo
        echo -e "${GREEN}AI API key removed from '${project_name}' repo${ENDCOLOR}"
        exit
    fi
    echo
    if [[ ! "$ai_key_input" =~ ^AIza[A-Za-z0-9_-]{35}$ ]]; then
        echo -e "${RED}Warning: API key format doesn't match expected Gemini format${ENDCOLOR}"
        read -n 1 -p "Continue anyway? (y/n) " -s choice
        echo
        if [ "$choice" != "y" ] && [ "$choice" != "Y" ]; then
            exit
        fi
    fi
    ai_api_key=$(set_config_value gitbasher.ai-api-key "$ai_key_input")
    echo -e "${GREEN}AI API key configured for '${project_name}' repo${ENDCOLOR}: ${BLUE}$(mask_api_key "$ai_api_key")${ENDCOLOR}"
    echo
    echo -e "Do you want to set it ${YELLOW}globally${ENDCOLOR} for all projects (y/n)?"
    yes_no_choice "\nSet AI API key globally" "true"
    ai_api_key=$(set_config_value gitbasher.ai-api-key "$ai_key_input" "true")
}
function configure_ai_proxy {    
    echo -e "${YELLOW}Configure AI HTTP Proxy${ENDCOLOR}"
    echo
    ai_proxy=$(get_ai_proxy)
    if [ -z "$ai_proxy" ]; then
        echo -e "${YELLOW}AI proxy is not configured${ENDCOLOR}"
    else
        echo -e "Current AI proxy: ${GREEN}$ai_proxy${ENDCOLOR}"
    fi
    echo -e "Enter HTTP proxy URL to route AI requests through (useful for bypassing geo-restrictions)"
    echo -e "Format: ${BLUE}http://proxy.example.com:8080${ENDCOLOR}"
    echo -e "With auth: ${BLUE}http://username:password@proxy.example.com:8080${ENDCOLOR}"
    echo -e "Press Enter to exit without changes or enter 0 to remove existing proxy"
    read -p "Proxy URL: " ai_proxy_input
    if [ "$ai_proxy_input" == "" ]; then
        exit
    fi
    if [ "$ai_proxy_input" == "0" ]; then
        clear_ai_proxy
        echo
        echo -e "${GREEN}AI proxy removed from '${project_name}' repo${ENDCOLOR}"
        exit
    fi
    echo
    if [[ ! "$ai_proxy_input" =~ ^https?://.*:[0-9]+$ ]]; then
        echo -e "${YELLOW}Warning: Proxy URL format should be http://host:port or https://host:port${ENDCOLOR}"
        read -n 1 -p "Continue anyway? (y/n) " -s choice
        echo
        if [ "$choice" != "y" ] && [ "$choice" != "Y" ]; then
            exit
        fi
    fi
    set_ai_proxy "$ai_proxy_input"
    echo -e "${GREEN}AI proxy configured for '${project_name}' repo${ENDCOLOR}: ${BLUE}$ai_proxy_input${ENDCOLOR}"
    echo
    echo -e "${YELLOW}Example usage:${ENDCOLOR}"
    echo -e "  ${BLUE}gitb commit ai${ENDCOLOR}    - Generate commit with AI through proxy"
    echo -e "  ${BLUE}gitb commit aif${ENDCOLOR}   - Fast AI commit through proxy"
    echo
    echo -e "Do you want to set it ${YELLOW}globally${ENDCOLOR} for all projects (y/n)?"
    yes_no_choice "\nSet AI proxy globally" "true"
    set_ai_proxy "$ai_proxy_input"
    git config --global gitbasher.ai-proxy "$ai_proxy_input"
}
function set_scopes {
    echo -e "${YELLOW}Enter a list of predefined scopes${ENDCOLOR}"
    echo
    if [ "$scopes" == "" ]; then
        echo -e "${YELLOW}Scopes list is not set${ENDCOLOR}"
    else
        echo -e "Current list of scopes: ${YELLOW}$scopes${ENDCOLOR}"
    fi
    echo -e "Use only english letters and space as separator, maximum is 9 scopes"
    echo -e "Enter 0 if you want to remove scopes"
    read -p "Scopes: " -e scopes_raw
    if [ "$scopes_raw" == "" ]; then
        exit
    fi
    if [ "$scopes_raw" == "0" ]; then
        git config --local --unset-all gitbasher.scopes
        echo
        echo -e "${GREEN}Scopes list removed from '${project_name}' repo${ENDCOLOR}"
        exit
    fi
    echo
    re='^([a-zA-Z]+ ){0,8}([a-zA-Z]+)+$'
    if ! [[ $scopes_raw =~ $re ]]; then
        echo -e "${RED}Invalid scopes list!${ENDCOLOR}"
        exit
    fi
    git config --local --replace-all gitbasher.scopes "$scopes_raw"
    scopes="$scopes_raw"
    echo -e "${GREEN}Set '${scopes}' as a scopes list in '${project_name}' repo${ENDCOLOR}"
    echo
    echo -e "Do you want to set it ${YELLOW}globally${ENDCOLOR} for all projects (y/n)?"
    yes_no_choice "\nSet '${scopes}' globally" "true"
    git config --global --replace-all gitbasher.scopes "$scopes_raw"
}
function delete_global {
    echo -e "${YELLOW}Unset global config${ENDCOLOR}"
    echo
    echo -e "Select a cfg to unset from global settings"
    global_default=$(git config --global --get gitbasher.branch)
    if [ "$global_default" != "" ]; then
        echo -e "1. Default branch: ${YELLOW}${global_default}${ENDCOLOR}"
    fi
    global_sep=$(git config --global --get gitbasher.sep)
    if [ "$global_sep" != "" ]; then
        echo -e "2. Branch separator: ${YELLOW}${global_sep}${ENDCOLOR}"
    fi
    global_editor=$(git config --global --get core.editor)
    if [ "$global_editor" != "" ]; then
        echo -e "3. Commit message editor: ${YELLOW}${global_editor}${ENDCOLOR}"
    fi
    global_ticket=$(git config --global --get gitbasher.ticket)
    if [ "$global_ticket" != "" ]; then
        echo -e "4. Ticket prefix: ${YELLOW}${global_ticket}${ENDCOLOR}"
    fi
    global_scopes=$(git config --global --get gitbasher.scopes)
    if [ "$global_scopes" != "" ]; then
        echo -e "5. Scopes list: ${YELLOW}${global_scopes}${ENDCOLOR}"
    fi
    global_ai_key=$(git config --global --get gitbasher.ai-api-key)
    if [ "$global_ai_key" != "" ]; then
        echo -e "6. AI API key: ${GREEN}configured${ENDCOLOR}"
    fi
    global_ai_proxy=$(git config --global --get gitbasher.ai-proxy)
    if [ "$global_ai_proxy" != "" ]; then
        echo -e "7. AI proxy: ${GREEN}$global_ai_proxy${ENDCOLOR}"
    fi
    echo -e "0. Exit"
    read -n 1 -s choice
    re='^[01234567]+$'
    if ! [[ $choice =~ $re ]]; then
        break
    fi
    if [ "$choice" == "0" ]; then
        exit
    fi
    echo
    case "$choice" in
        1)  
            echo -e "${GREEN}Unset default branch from global settings${ENDCOLOR}"
            git config --global --unset gitbasher.branch
            ;;
        2)
            echo -e "${GREEN}Unset branch separator from global settings${ENDCOLOR}"
            git config --global --unset gitbasher.sep
            ;;
        3)
            echo -e "${GREEN}Unset commit message editor from global settings${ENDCOLOR}"
            git config --global --unset core.editor
            ;;
        4)
            echo -e "${GREEN}Unset ticket prefix from global settings${ENDCOLOR}"
            git config --global --unset gitbasher.ticket
            ;;
        5)
            echo -e "${GREEN}Unset scopes list from global settings${ENDCOLOR}"
            git config --global --unset gitbasher.scopes
            ;;
        6)
            echo -e "${GREEN}Unset AI API key from global settings${ENDCOLOR}"
            git config --global --unset gitbasher.ai-api-key
            ;;
        7)
            echo -e "${GREEN}Unset AI proxy from global settings${ENDCOLOR}"
            git config --global --unset gitbasher.ai-proxy
            ;;
    esac
}
function set_user {
    echo -e "${YELLOW}Set user name and email${ENDCOLOR}"
    echo
    echo -e "Current name: ${YELLOW}$(get_config_value user.name)${ENDCOLOR}"
    echo -e "Enter new name or press Enter if you don't want to change it"
    read -p "Name: " -e user_name
    echo
    echo -e "Current email: ${YELLOW}$(get_config_value user.email)${ENDCOLOR}"
    echo -e "Enter new email or press Enter if you don't want to change it"
    read -p "Email: " -e user_email
    if [ "$user_name" == "" ] && [ "$user_email" == "" ]; then
        exit
    fi
    echo
    if [ "$user_name" != "" ]; then
        echo -e "${GREEN}Set user name to '${user_name}'${ENDCOLOR}"
        git config --local --replace-all user.name "$user_name"
    fi
    if [ "$user_email" != "" ]; then
        echo -e "${GREEN}Set user email to '${user_email}'${ENDCOLOR}"
        git config --local --replace-all user.email "$user_email"
    fi
}
function config_script {
    case "$1" in
        default|def|d|b|main) set_default_cfg="true";;
        separator|sep)        set_sep_cfg="true";;
        editor|ed|e)          set_editor_cfg="true";;
        ticket|jira|ti|t)     set_ticket_cfg="true";;
        scopes|scope|sc|s)    set_scopes_cfg="true";;
        ai|llm|key)           set_ai_cfg="true";;
        proxy|prx|p)          set_proxy_cfg="true";;
        delete|unset|del)     delete_cfg="true";;
        user|name|email|u)    set_user_cfg="true";;
        help|h)               help="true";;
        *)                    wrong_mode "config" $1
    esac
    header="GIT CONFIG"
    if [ -n "${set_default_cfg}" ]; then
        header="$header DEFAULT BRANCH"
    elif [ -n "${set_sep_cfg}" ]; then
        header="$header BRANCH SEPARATOR"
    elif [ -n "${set_editor_cfg}" ]; then
        header="$header COMMIT MESSAGE EDITOR"
    elif [ -n "${set_ticket_cfg}" ]; then
        header="$header TICKET PREFIX"
    elif [ -n "${set_scopes_cfg}" ]; then
        header="$header SCOPES LIST"
    elif [ -n "${set_ai_cfg}" ]; then
        header="$header AI API KEY"
    elif [ -n "${set_proxy_cfg}" ]; then
        header="$header AI PROXY"
    elif [ -n "${delete_cfg}" ]; then
        header="$header UNSET GLOBAL CONFIG"
    elif [ -n "${set_user_cfg}" ]; then
        header="$header USER NAME & EMAIL"
    fi
    echo -e "${YELLOW}${header}${ENDCOLOR}"
    echo
    if [ "$set_user_cfg" == "true" ]; then
        set_user
        exit
    fi
    if [ "$set_default_cfg" == "true" ]; then
        set_default_branch
        exit
    fi
    if [ "$set_sep_cfg" == "true" ]; then
        set_sep
        exit
    fi
    if [ "$set_editor_cfg" == "true" ]; then
        set_editor
        exit
    fi
    if [ "$set_ticket_cfg" == "true" ]; then
        set_ticket
        exit
    fi
    if [ "$set_scopes_cfg" == "true" ]; then
        set_scopes
        exit
    fi
    if [ "$set_ai_cfg" == "true" ]; then
        configure_ai_key
        exit
    fi
    if [ "$set_proxy_cfg" == "true" ]; then
        configure_ai_proxy
        exit
    fi
    if [ "$delete_cfg" == "true" ]; then
        delete_global
        exit
    fi
    if [ -n "$help" ]; then
        echo -e "usage: ${YELLOW}gitb config <mode>${ENDCOLOR}"
        echo
        echo -e "${YELLOW}Available modes for configuration${ENDCOLOR}"
        echo -e "<empty>\t\t\tPrint current gitbasher configuration"
        echo -e "user|name|email|u\tSet user name and email"
        echo -e "default|def|d|b|main\tUpdate gitbasher's default branch (not in remote git repo!)"
        echo -e "separator|sep|s\t\tUpdate separator between type and name in branch"
        echo -e "editor|ed|e\t\tUpdate text editor for the commit messages"
        echo -e "ticket|ti|t|jira\tSet ticket prefix to help with commit/branch building"
        echo -e "scopes|sc|s\t\tSet a list of scopes to help with commit building"
        echo -e "ai|llm|key\t\tSet AI API key for commit message generation"
        echo -e "proxy|prx|p\t\tSet HTTP proxy for AI requests (bypass geo-restrictions)"
        echo -e "delete|unset|del\tUnset global configuration"
        exit
    fi
    print_configuration
}
function merge_script {
    case "$1" in
        main|master|m)          main="true";;
        to-main|to-master|tm)   to_main="true";;
        remote|r)               remote="true";;
        help|h)                 help="true";;
        *)
            wrong_mode "merge" $1
    esac
    header="GIT MERGE"
    if [ -n "${main}" ]; then
        header="$header MAIN"
    elif [ -n "${to_main}" ]; then
        header="$header TO MAIN"
    elif [ -n "${remote}" ]; then
        header="$header REMOTE"
    fi
    echo -e "${YELLOW}${header}${ENDCOLOR}"
    echo
    if [ -n "$help" ]; then
        echo -e "usage: ${YELLOW}gitb merge <mode>${ENDCOLOR}"
        echo
        echo -e "${YELLOW}Available modes${ENDCOLOR}"
        echo -e "<empty>\t\t\tSelect a branch to merge into the current one and fix conflicts"
        echo -e "main|master|m\t\tMerge $main_branch to the current branch and fix conflicts"
        echo -e "to-main|to-master|tm\tSwitch to $main_branch and merge the current branch into $main_branch"
        echo -e "remote|r\t\tFetch $origin_name and select a remote branch to merge into current"
        echo -e "help|h\t\t\tShow this help"
        exit
    fi
    if [ -n "$main" ]; then
        if [ "$current_branch" == "${main_branch}" ]; then
            echo -e "${YELLOW}Already on ${main_branch}${ENDCOLOR}"
            exit
        fi
        merge_branch=${main_branch}
    elif [ -n "$to_main" ]; then
        if [ "$current_branch" == "${main_branch}" ]; then
            echo -e "${YELLOW}Already on ${main_branch}${ENDCOLOR}"
            exit
        fi
        merge_branch=${current_branch}
    elif [ -n "$remote" ]; then
        echo -e "${YELLOW}Fetching remote...${ENDCOLOR}"
        echo
        fetch_output=$(git fetch 2>&1)
        check_code $? "$fetch_output" "fetch remote"
        prune_output=$(git remote prune $origin_name 2>&1)
        echo -e "${YELLOW}Select which remote branch to merge into '${current_branch}'${ENDCOLOR}"
        choose_branch "remote"
        merge_branch=${branch_name}
        merge_from_origin=true
        echo
    else
        echo -e "${YELLOW}Select which branch to merge into '${current_branch}'${ENDCOLOR}"
        choose_branch "merge"
        merge_branch=${branch_name}
        echo
    fi
    if [ -z "$remote" ]; then
        echo -e "Do you want to fetch ${YELLOW}${origin_name}/${merge_branch}${ENDCOLOR} before merge (y/n)?"
        read -n 1 -s choice
        if [ "$choice" == "y" ]; then
            echo
            echo -e "${YELLOW}Fetching ${origin_name}/${merge_branch}...${ENDCOLOR}"
            fetch $merge_branch $origin_name
            merge_from_origin=true
        fi
        echo
    fi
    if [ -n "$to_main" ]; then
        switch $main_branch "true"
        echo
        current_branch=$main_branch
    fi
    commit_message_before_merge="$(git --no-pager log --pretty="%s" -1)"
    merge $merge_branch $origin_name $editor "merge" $merge_from_origin
    if [[ $merge_output == *"Already up to date"* ]]; then
        echo -e "${GREEN}Nothing to merge - already up to date${ENDCOLOR}"
        exit
    fi
    commit_message_after_merge="$(git --no-pager log --pretty="%s" -1)"
    if [[ "$commit_message_after_merge" != "$commit_message_before_merge" ]]; then
        echo -e "${GREEN}Successful merge!${ENDCOLOR} ${BLUE}[$merge_branch${ENDCOLOR} -> ${BLUE}$current_branch]${ENDCOLOR}"
        echo -e "$commit_message_after_merge"
    else
        echo -e "${GREEN}Successful fast-forward merge!${ENDCOLOR} ${BLUE}[$merge_branch${ENDCOLOR} -> ${BLUE}$current_branch]${ENDCOLOR}"
    fi
    changes=$(echo "$merge_output" | tail -n +3)
    if [[ $changes == *"conflict"* ]]; then
        commit_hash="$(git --no-pager log --pretty="%h" -1)"
        changes=$(git --no-pager show $commit_hash --stat --format="")
    fi
    if [ -n "$changes" ]; then
        echo
        print_changes_stat "$changes"
    fi
}
function merge {
    args=""
    if [ "$6" == "true" ]; then
        args="--ff-only"
    fi
    if [ "$5" == "true" ]; then
        merge_output=$(git merge $args $2/$1 2>&1)
    else
        merge_output=$(git merge $args $1 2>&1)
    fi
    merge_code=$?
    if [ $merge_code == 0 ] ; then
        return
    fi
    operation="$4"
    if [ "$operation" == "" ]; then
        operation="merge"
    fi
    if [[ $merge_output == *"Please commit your changes or stash them before you merge"* ]]; then
        echo -e "${RED}Cannot $operation! There are uncommited changes that will be overwritten by $operation${ENDCOLOR}"
        files_to_commit=$(echo "$merge_output" | tail -n +2 | tail -r | tail -n +4 | tail -r)
        echo -e "${YELLOW}Files with changes${ENDCOLOR}"
        echo "$files_to_commit"
        exit $merge_code
    fi
    if [[ $merge_output == *"possible to fast-forward"* ]]; then
        echo -e "${RED}Branches cannot be fast forwarded!${ENDCOLOR}"
        echo -e "You should use merge or rebase"
        exit $merge_code
    fi
    if [[ $merge_output != *"fix conflicts and then commit the result"* ]]; then
        echo -e "${RED}Cannot $operation! Error message:${ENDCOLOR}"
        echo "$merge_output"
        exit $merge_code
    fi
    echo -e "${RED}Cannot $operation! There are conflicts in staged files${ENDCOLOR}"
    resolve_conflicts $1 $2 $3
    merge_code=0
    echo
}
function resolve_conflicts {
    echo
    default_message="Merge branch '$2/$1' into '$1'"
    echo -e "${YELLOW}You should resolve conflicts manually${ENDCOLOR}"
    echo -e "After resolving, select an option to continue"
    echo -e "1. Create a merge commit with a generated message:"
    printf "\t${YELLOW}${default_message}${ENDCOLOR}\n"
    echo -e "2. Create a merge commit with an entered message"
    echo -e "3. Abort merge and return to the original state: ${YELLOW}git merge --abort${ENDCOLOR}"
    echo -e "0. Exit from this script ${BOLD}without${NORMAL} merge abort"
    echo
    echo -e "${YELLOW}Files with conflicts${ENDCOLOR}"
    IFS=$'\n' read -rd '' -a files_with_conflicts <<<"$(git --no-pager diff --name-only --diff-filter=U --relative)"
    for file in "${files_with_conflicts[@]}"; do
        echo -e "\t$file"
    done
    while [ true ]; do
        read -n 1 -s choice
        if [ "$choice" == "1" ] || [ "$choice" == "2" ]; then
            merge_commit $choice "${files_with_conflicts[@]}" "${default_message}" $1 $2 $3
            if [ "$merge_error" == "false" ]; then
                return
            fi
        fi
        if [ "$choice" == "3" ]; then
            echo
            echo -e "${YELLOW}Aborting merge...${ENDCOLOR}"
            git merge --abort
            exit $?
        fi
        if [ "$choice" == "0" ]; then
            exit
        fi
    done
}
function merge_commit {
    merge_error="false"
    files_with_conflicts_one_line="$(echo "$2" | tr '\n' ' ' | sed 's/ $//')"
    files_with_conflicts_new="$(git --no-pager grep -l --name-only -E "[<=>]{7} HEAD" $files_with_conflicts_one_line)"
    if [ "$files_with_conflicts_new" != "" ]; then
        echo
        echo -e "${YELLOW}There are files with conflicts${ENDCOLOR}"
        echo -e "$(echo -e "${files_with_conflicts_new}" | tr ' ' '\n' | sed 's/^/\t/')"
        echo
        echo -e "Fix conflicts and press ${YELLOW}$1${ENDCOLOR} for one more time"
        merge_error="true"
        return
    fi
    echo
    echo -e "${YELLOW}Adding resolved files to commit...${ENDCOLOR}"
    git add -u
    if [ "$1" == "1" ]; then
        commit_message="$3"
        result=$(git commit -m "$commit_message" 2>&1)
        if [[ $result != *"not staged for commit"* ]]; then
            check_code $? "$result" "creating default merge commit"
        fi  
    else
        staged_with_tab="$(sed 's/^/####\t/' <<< "$2")"
        commitmsg_file=$(mktemp ".commitmsg.XXXXXX")
        echo """
####
#### Write a message about merge from '$5/$4' into '$4'. Lines starting with '#' will be ignored. 
#### 
#### On branch $4
#### Changes to be commited:
${staged_with_tab}
""" >> $commitmsg_file
        while [ true ]; do
            $6 $commitmsg_file
            commit_message=$(cat $commitmsg_file | sed '/^#/d')
            if [ -n "$commit_message" ]; then
                break
            fi
            echo
            echo -e "${YELLOW}Merge commit message cannot be empty${ENDCOLOR}"
            echo
            read -n 1 -p "Do you want to try for one more time? (y/n) " -s -e choice
            if [ "$choice" != "y" ]; then
                git restore --staged $files_with_conflicts_one_line
                find . -name "$commitmsg_file*" -delete
                merge_error="true"
                exit
            fi    
        done
        find . -name "$commitmsg_file*" -delete
        result=$(git commit -m """$commit_message""" 2>&1)
        if [[ $result != *"not staged for commit"* ]]; then
            check_code $? "$result" "creating merge commit"
        fi  
    fi
}
function rebase_script {
    case "$1" in
        main|master|m)           main="true";;
        interactive|i)           interactive="true";;
        autosquash|a|s|f|ia|if)  autosquash="true";;
        help|h)                  help="true";;
        *)
            wrong_mode "rebase" $1
    esac
    header="GIT REBASE"
    if [ -n "${interactive}" ]; then
        header="$header INTERACTIVE"
    elif [ -n "${autosquash}" ]; then
        header="$header AUTOSQUASH"
    elif [ -n "${main}" ]; then
        header="$header MAIN"
    fi
    echo -e "${YELLOW}${header}${ENDCOLOR}"
    echo
    if [ -n "$help" ]; then
        echo -e "usage: ${YELLOW}gitb rebase <mode>${ENDCOLOR}"
        echo
        echo -e "${YELLOW}Available modes${ENDCOLOR}"
        echo -e "<empty>\t\t\tSelect base branch to rebase current changes"
        echo -e "main|master|m\t\tRebase current branch onto default branch"
        echo -e "interactive|i\t\tSelect base commit in current branch and rebase in an interactive mode"
        echo -e "autosquash|a|s|f|ia|if\tRebase on the current local branch in an interactive mode with --autosquash"
        echo -e "help|h\t\t\tShow this help"
        exit
    fi
    is_clean=$(git status | tail -n 1)
    if [ "$is_clean" != "nothing to commit, working tree clean" ]; then
        echo -e "${RED}Cannot rebase! There are uncommited changes:"
        git_status
        exit 1
    fi
    if [ -n "$main" ]; then
        if [ "$current_branch" == "${main_branch}" ]; then
            echo -e "${YELLOW}Already on ${main_branch}${ENDCOLOR}"
            exit
        fi
        new_base_branch=${main_branch}
    elif [ -n "$autosquash" ]; then
        new_base_branch=${current_branch}
    else
        echo -e "${YELLOW}Select which branch will become a new base for '${current_branch}'${ENDCOLOR}"
        choose_branch "rebase"
        new_base_branch=${branch_name}
        echo
    fi
    if [ -z "$autosquash" ]; then
        echo -e "Fetch ${YELLOW}${origin_name}/${new_base_branch}${ENDCOLOR} before rebase (y/n/0)?"
        read -n 1 -s choice
        if [ "$choice" == "0" ]; then
            exit
        fi
        if [ "$choice" == "y" ]; then
            echo
            echo -e "${YELLOW}Fetching ${origin_name}/${new_base_branch}...${ENDCOLOR}"
            fetch $new_base_branch $origin_name
            from_origin=true
        fi
        echo
    fi
    rebase_branch "$new_base_branch" "$origin_name" "$from_origin" "$interactive" "$autosquash" "$autosquash"
    if [[ $rebase_output == *"is up to date"* ]]; then
        echo -e "${GREEN}Nothing to rebase - already up to date${ENDCOLOR}"
        exit
    fi
    if [ $rebase_code == 0 ] ; then
        echo -e "${GREEN}Successful rebase!${ENDCOLOR}"
        echo -e "${BLUE}[${new_base_branch}${ENDCOLOR} -> ${BLUE}${current_branch}]${ENDCOLOR}"
    else
        echo -e "${RED}Cannot rebase! Error message:${ENDCOLOR}"
        echo -e "$rebase_output"
    fi
}
function rebase_branch {
    ref=$1
    if [ "$3" == "true" ]; then
        ref=$2/$1
    fi
    if [ "$5" == "true" ]; then
        if [ "$6" == "true" ]; then
            echo -e "Select a new ${BOLD}base${NORMAL} commit from which to squash fixup commits (third one or older):"
            choose_commit 20 "number" $ref
            ref="$commit_hash"
        fi
        rebase_output=$(git rebase -i --autosquash $ref 3>&2 2>&1 1>&3)
    elif [ "$4" == "true" ]; then
        rebase_output=$(git rebase -i $ref 3>&2 2>&1 1>&3)
    else
        rebase_output=$(git rebase $ref 3>&2 2>&1 1>&3)
    fi
    rebase_code=$?
    if [ $rebase_code == 0 ] ; then
        return
    fi
    if [[ $rebase_output == *"Please commit or stash them"* ]]; then
        echo -e "${RED}Cannot rebase! There are uncommited changes:"
        git_status
        exit $rebase_code
    fi
    if [[ $rebase_output == *"error: invalid"* ]]; then
        rebase_todo_errors "$rebase_output"
        echo
    fi
    if [[ $rebase_output == *"Resolve all conflicts manually"* ]] || [[ $rebase_output == *"previous cherry-pick is now empty"* ]]; then
        echo -e "${RED}Cannot rebase! There are conflicts${ENDCOLOR}"
        rebase_conflicts $rebase_output 
        echo
    fi
    if [[ $rebase_output != *"Successfully rebased"* ]]; then
        echo -e "${RED}Cannot rebase! Error message:${ENDCOLOR}"
        echo "$rebase_output"
        exit $rebase_code
    fi
}
function rebase_todo_errors {
    rebase_output=$1
    output_to_print=$1
    while [ true ]; do
        echo -e "${RED}Cannot rebase! Your rebase plan has errors:${ENDCOLOR}"
        echo "$(sed '$d' <<< $output_to_print)"
        echo
        echo -e "${YELLOW}You should fix errors${ENDCOLOR}"
        echo -e "1. Open editor to change rebase plan: ${BLUE}git rebase --edit-todo${ENDCOLOR}"
        echo -e "2. Abort rebase and return to the original state: ${YELLOW}git rebase --abort${ENDCOLOR}"
        echo -e "0. Exit from this script ${BOLD}without${NORMAL} rebase abort"
        while [ true ]; do
            read -n 1 -s choice
            re='^[012]+$'
            if [[ $choice =~ $re ]]; then
                break
            fi
        done
        if [ "$choice" == "1" ]; then
            todo_output=$(git rebase --edit-todo 3>&2 2>&1 1>&3)
            rebase_output=$(git rebase --continue 2>&1)
            rebase_code=$?
        elif [ "$choice" == "2" ]; then
            echo
            echo -e "${YELLOW}Aborting rebase...${ENDCOLOR}"
            git rebase --abort
            exit
        elif [ "$choice" == "0" ]; then
            exit $rebase_code
        fi
        if [ "$2" != "" ] ; then
            output_to_print=$todo_output
            if [[ $todo_output != *"can fix this with"* ]]; then
                break
            fi
        else
            output_to_print=$rebase_output
            if [[ $rebase_output != *"error: invalid"* ]]; then
                break
            fi
        fi
        echo
    done
}
function rebase_conflicts {
    print_menu="true"
    new_step="true"
    rebase_output=$1
    while [ true ]; do
        if [ "$print_menu" == "true" ]; then
            echo
            echo -e "${YELLOW}You should resolve conflicts manually${ENDCOLOR}"
            echo -e "After resolving, select an option to continue"
            echo -e "1. Add changes and continue: ${YELLOW}git rebase --continue${ENDCOLOR}"
            echo -e "2. Open editor to change rebase plan: ${BLUE}git rebase --edit-todo${ENDCOLOR}"
            echo -e "3. Throw away the commit from the history: ${RED}git rebase --skip${ENDCOLOR}"
            echo -e "4. Abort rebase and return to the original state: ${YELLOW}git rebase --abort${ENDCOLOR}"
            echo -e "0. Exit from this script ${BOLD}without${NORMAL} rebase abort"
            print_menu="false"
        fi
        if [ "$new_step" == "true" ]; then
            status=$(git status)
            current_step=$(echo "$status" | sed -n 's/.*Last commands done (\([0-9]*\) commands done):/\1/p')
            if [ "$current_step" == "" ]; then
                current_step=$(echo "$status" | sed -n 's/.*Last command done (\([0-9]*\) command done):/\1/p')
            fi
            remaining_steps=$(echo "$status" | sed -n 's/.*Next commands to do (\([0-9]*\) remaining commands):/\1/p')
            total_steps=$((current_step + remaining_steps))
            commit_name=$(echo "$status" | sed -n '/done):/,/Next command/p' | sed 's/^[ \t]*//;s/[ \t]*$//' | sed '/^[LN(]/d' | tail -n 1 )
            commit_name=$(echo "$commit_name" | sed 's/^[ \t]*//;s/[ \t]*$//' | sed "s/\([a-z]* [0-9a-f]*\)/${BLUE_ES}\[\1\]${ENDCOLOR_ES}/")
            files=$(echo "$status" | sed -n '/^Unmerged paths:/,/^$/p' | sed '/^Unmerged paths:/d;/^$/d;/^ *(/d')
            files=$(sed "s/\(.*\)both modified:/\1${YELLOW_ES}modified:${ENDCOLOR_ES}/" <<< "${files}")
            files=$(sed "s/\(.*\)both added:/\1${YELLOW_ES}added:${ENDCOLOR_ES}/" <<< "${files}")
            echo
            echo -e "${GREEN}Step $current_step/$total_steps:${ENDCOLOR} $commit_name"
            if [ "$files" != "" ]; then
                echo -e "$files"
            else
                echo
                echo -e "${YELLOW}The previous commit is now empty due to conflict resolution${ENDCOLOR}"
                echo -e "${GREEN}You can skip this commit by pressing ${BOLD}3${ENDCOLOR}"
                force_skip="true"
            fi
            new_step="false"
        fi
        while [ true ]; do
            read -n 1 -s choice
            re='^[01234]+$'
            if [[ $choice =~ $re ]]; then
                break
            fi
        done
        if [ "$choice" == "1" ]; then
            files_with_conflicts_one_line="$(tr '\n' ' ' <<< "$(git --no-pager diff --name-only --diff-filter=U --relative)")"
            files_with_conflicts_new="$(git grep -l --name-only -E "[<=>]{7} HEAD" $files_with_conflicts_one_lined)"
            if [ "$files_with_conflicts_new" != "" ]; then
                echo
                echo -e "${YELLOW}There are files with conflicts${ENDCOLOR}"
                echo -e "$(echo -e "${files_with_conflicts_new}" | tr ' ' '\n' | sed 's/^/\t/')"
                continue
            fi
            git add .
            rebase_output=$(git -c core.editor=true rebase --continue 2>&1)
            rebase_code=$?
            if [[ $rebase_output == *"Successfully rebased"* ]]; then
                return
            fi
            if [[ $rebase_output != *"CONFLICT"* ]]; then
                echo -e "${RED}Cannot rebase! Error message:${ENDCOLOR}"
                echo "$rebase_output"
                exit $rebase_code
            fi
            new_step="true"
            continue
        fi
        if [ "$choice" == "2" ]; then
            todo_output=$(git rebase --edit-todo 3>&2 2>&1 1>&3)
            rebase_output=$(git rebase --continue 2>&1)
            if [[ $todo_output == *"error: invalid"* ]]; then
                echo
                rebase_todo_errors "$todo_output" "true"
                print_menu="true"
                new_step="true"
            fi
            echo
            echo -e "${YELLOW}Successfull plan edit, continuing...${ENDCOLOR}"
            continue
        fi
        if [ "$choice" == "3" ]; then
            if [ "$force_skip" != "true" ]; then
                echo
                echo -e "Are you sure you want to ${RED}skip${ENDCOLOR} commit and ${RED}throw it away${ENDCOLOR} (y/n)?"
                read -n 1 -s choice_yes
                if [ "$choice_yes" != "y" ]; then
                    echo -e "${YELLOW}Continuing...${ENDCOLOR}"
                    continue
                fi
            fi
            force_skip="false"
            rebase_output=$(git rebase --skip 2>&1)
            rebase_code=$?
            if [[ $rebase_output == *"Successfully rebased"* ]]; then
                echo
                return
            fi
            echo -e "${YELLOW}Skipping commit${ENDCOLOR}"
            new_step="true"
            continue
        fi
        if [ "$choice" == "4" ]; then
            echo
            echo -e "Are you sure you want to ${YELLOW}abort rebase${ENDCOLOR} (y/n)?"
            read -n 1 -s choice_yes
            if [ "$choice_yes" == "y" ]; then
                echo
                echo -e "${YELLOW}Aborting rebase...${ENDCOLOR}"
                git rebase --abort
                exit $?
            else
                echo -e "${YELLOW}Continuing...${ENDCOLOR}"
            fi
            continue
        fi
        if [ "$choice" == "0" ]; then
            exit
        fi
    done
}
function pull_script {
    case "$1" in
        fetch|fe)           fetch="true";;
        all|fa)             fetch="true"; all="true";;
        upd|u)              update="true";;
        ffonly|ff)          ffonly="true";;
        merge|m)            merge="true";;
        rebase|r)           rebase="true";;
        interactive|ri|rs)  rebase="true"; interactive="true";;
        help|h)             help="true";;
        *)
            wrong_mode "pull" $1
    esac
    header_msg="GIT PULL"
    if [ -n "${fetch}" ]; then
        if [ -n "${all}" ]; then
            header_msg="$header_msg FETCH ALL"
        else
            header_msg="$header_msg FETCH"
        fi
    elif [ -n "${rebase}" ]; then
        if [ -n "${interactive}" ]; then
            header_msg="$header_msg INTERACTIVE REBASE"
        else
            header_msg="$header_msg REBASE"
        fi
    elif [ -n "${ffonly}" ]; then
        header_msg="$header_msg FAST FORWARD ONLY"
    elif [ -n "${merge}" ]; then
        header_msg="$header_msg MERGE"
    elif [ -n "${update}" ]; then
        header_msg="$header_msg REMOTE UPDATE"
    fi
    echo -e "${YELLOW}${header_msg}${ENDCOLOR}"
    echo
    if [ -n "$help" ]; then
        echo -e "usage: ${YELLOW}gitb pull${ENDCOLOR}"
        echo
        echo -e "${YELLOW}Available modes${ENDCOLOR}"
        echo -e "<empty>\t\t\tFetch current branch, try to fast-forward or ask about strategy"
        echo -e "fetch|fe\t\tFetch current branch without merge"    
        echo -e "all|fa\t\t\tFetch all without merge"
        echo -e "upd|u\t\t\tRun git remote update to fetch all branches"
        echo -e "ffonly|ff\t\tFetch and then merge in fast forward only mode"
        echo -e "merge|m\t\t\tFetch current branch and then merge it"
        echo -e "rebase|r\t\tFetch current branch and then rebase"
        echo -e "interactive|ri|rs\tFetch current branch and then rebase in interactive mode with --autosquash"
        echo -e "help|h\t\t\tShow this help"
        exit
    fi
    if [ -n "$rebase" ]; then
        mode="rebase"
    elif [ -n "$merge" ]; then
        mode="merge"
    fi
    if [ -n "$fetch" ]; then
        if [ -n "$all" ]; then
            echo -e "${YELLOW}Fetching all...${ENDCOLOR}"
        else
            echo -e "${YELLOW}Fetching '$origin_name/$current_branch'...${ENDCOLOR}"
        fi
        echo
        fetch $current_branch $origin_name $all
        if [ $fetch_code == 0 ] ; then
            commits=$(commit_list 999 "tab" HEAD..$origin_name/$current_branch)
            if [ "$commits" != "" ]; then
                if [ -n "$all" ]; then
                    echo -e "${GREEN}Successfully fetched all!${ENDCOLOR}"
                else
                    echo -e "${GREEN}Successfully fetched '$origin_name/$current_branch'!${ENDCOLOR}"
                fi
                if [ "$fetch_output" != "" ]; then
                    echo
                    echo -e "$fetch_output"
                fi
                echo
                count=$(echo -e "$commits" | wc -l | sed 's/^ *//;s/ *$//')
                echo -e "Your branch is behind ${YELLOW}$origin_name/$current_branch${ENDCOLOR} by ${BOLD}$count${ENDCOLOR} commits"
                echo -e "$commits"
            else
                echo -e "${GREEN}Already up to date${ENDCOLOR}"
            fi
        fi
        exit
    fi
    if [ -n "$update" ]; then
        echo -e "${YELLOW}Updating from remote...${ENDCOLOR}"
        echo
        update_output=$(git remote update 2>&1)
        update_code=$?
        if [ $update_code == 0 ] ; then
            commits=$(commit_list 999 "tab" HEAD..$origin_name/$current_branch)
            if [ "$commits" != "" ]; then
                echo -e "${GREEN}Successfully updated from remote!${ENDCOLOR}"
                if [ "$update_output" != "" ]; then
                    echo
                    echo -e "$update_output"
                fi
                echo
                count=$(echo -e "$commits" | wc -l | sed 's/^ *//;s/ *$//')
                echo -e "Your branch is behind ${YELLOW}$origin_name/$current_branch${ENDCOLOR} by ${BOLD}$count${ENDCOLOR} commits"
                echo -e "$commits"
            else
                echo -e "${GREEN}Already up to date${ENDCOLOR}"
            fi
            exit
        fi
        echo -e "${RED}Cannot update! Error message:${ENDCOLOR}"
        echo -e "${update_output}"
        exit $update_code
    fi
    echo -e "${YELLOW}Pulling '$origin_name/$current_branch'...${ENDCOLOR}"
    echo
    pull $current_branch $origin_name $editor $mode $ffonly 
    exit
}
function fetch {
    if [ -n "$3" ]; then
        fetch_output=$(git fetch --all 2>&1)
        fetch_code=$?
    else
        fetch_output=$(git fetch $2 $1 2>&1)
        fetch_code=$?
    fi
    if [ $fetch_code == 0 ] ; then
        return
    fi
    if [[ ${fetch_output} != *"couldn't find remote ref"* ]]; then
        echo -e "${RED}Cannot fetch '$1'! Error message:${ENDCOLOR}"
        echo -e "${fetch_output}"
        exit $fetch_code
    fi
    echo -e "${YELLOW}There is no '$1' in $2${ENDCOLOR}"
}
function pull {
    fetch $1 $2
    if [ $fetch_code != 0 ] ; then
        return
    fi
    merge_output=$(git merge --ff-only $2/$1 2>&1)
    merge_code=$?
    mode="fast-forward"
    if [[ $merge_output == *"Already up to date"* ]]; then  
        echo -e "${GREEN}Already up to date${ENDCOLOR}"
        return
    fi
    if [ $merge_code != 0 ] ; then
        if [[ $merge_output != *"possible to fast-forward"* ]]; then
            echo -e "${RED}Cannot pull! Error message:${ENDCOLOR}"
            echo "$merge_output"
            exit $merge_code
        fi
        commits=$(commit_list 999 "tab" HEAD..$origin_name/$current_branch)
        count=$(echo -e "$commits" | wc -l | sed 's/^ *//;s/ *$//')
        echo -e "Your branch is behind ${YELLOW}$origin_name/$current_branch${ENDCOLOR} by ${BOLD}$count${ENDCOLOR} commits"
        echo -e "$commits"
        echo
        mode=$4
        if [ "$4" == "merge" ]; then
            echo -e "${YELLOW}Merging...${ENDCOLOR}"
            choice="1"
        elif [ "$4" == "rebase" ]; then
            echo -e "${YELLOW}Rebasing...${ENDCOLOR}"
            choice="2"
        else
            echo -e "${RED}Cannot fast forward!${ENDCOLOR} Choose an option:"
            echo -e "1. ${BLUE}Merge.${ENDCOLOR} It saves commit's timeline, but creates a merge commit with message:"
            echo -e "\t\t${YELLOW}Merge remote-tracking branch '$origin_name/$current_branch' into $current_branch${ENDCOLOR}"
            echo -e "2. ${BLUE}Rebase.${ENDCOLOR} It takes all new local commits and places them on top of the remote branch"
            read -n 1 -s choice
            re='^[12]+$'
            if ! [[ $choice =~ $re ]]; then
                exit 0
            fi
        fi
        echo
        if [ "$choice" == "1" ]; then
            merge $1 $2 $3 "pull" "true" $5
            mode="merge"
            if [ $merge_code != 0 ] ; then
                echo
           fi
        else 
           rebase_branch $1 $2 "true" $interactive $interactive
           mode="rebase"
           if [ $rebase_code != 0 ] ; then
                echo
           fi
        fi
    fi
    echo -e "${GREEN}Successfully pulled with $mode!${ENDCOLOR}"
    if [ "$mode" == "merge" ] || [ "$mode" == "fast-forward" ]; then 
        echo
        if [ $merge_code == 0 ] ; then
            if [[ $merge_output == *"made by the"* ]]; then
                changes=$(echo "$merge_output" | tail -n +3)
            else
                changes=$(echo "$merge_output" | tail -n +2)
            fi
            if [[ -n "$changes" ]]; then
                print_changes_stat "$changes"
            fi
        else
            commit_hash="$(git --no-pager log --pretty="%h" -1)"
            changes=$(git --no-pager show $commit_hash --stat --format="")
            if [[ -n "$changes" ]]; then
                print_changes_stat "$changes"
            fi
        fi
    fi
}
function push {
    push_output=$(git push $1 ${origin_name} ${current_branch} 2>&1)
    push_code=$?
    if [ $push_code -eq 0 ] ; then 
        echo -e "${GREEN}Successful push!${ENDCOLOR}"
        repo=$(get_repo)
        echo -e "${YELLOW}Repo:${ENDCOLOR}\t${repo}"
        if [[ ${current_branch} != ${main_branch} ]]; then
            link=$(echo "$push_output" | grep "https://" | sed 's|^remote:[[:space:]]*||')
            if [[ $repo == *"github"* ]]; then
                if [ "$link" != "" ]; then
                    echo -e "${YELLOW}New PR:${ENDCOLOR}\t${link}"
                else
                    echo -e "${YELLOW}PRs:${ENDCOLOR}\t${repo}/pulls"
                fi
            elif [[ $repo == *"gitlab"* ]]; then
                is_new=$(echo "$push_output" | grep "create a merge request")
                if [ "$is_new" != "" ]; then
                    echo -e "${YELLOW}New MR:${ENDCOLOR}\t${link}"
                else
                    if [ "$mr_link" != "" ]; then
                        echo -e "${YELLOW}MR:${ENDCOLOR}\t${link}"
                    else
                        echo -e "${YELLOW}MRs:${ENDCOLOR}\t${repo}/merge_requests"
                    fi
                fi
            fi
        fi
        exit
    fi
    if [[ $push_output != *"[rejected]"* ]]; then
        echo -e "${RED}Cannot push! Error message:${ENDCOLOR}"
        echo "$push_output"
        exit $push_code
    fi
}
function push_script {
    case "$1" in
        yes|y)      fast="true";;
        force|f)    force="true";;
        list|log|l) list="true";;
        help|h)     help="true";;
        *)
            wrong_mode "push" $1
    esac
    header_msg="GIT PUSH"
    if [ -n "${fast}" ]; then
        header_msg="${YELLOW}$header_msg FAST${ENDCOLOR}"
    elif [ -n "${force}" ]; then
        header_msg="${RED}$header_msg FORCE${ENDCOLOR}"
    elif [ -n "${list}" ]; then
        header_msg="${YELLOW}$header_msg LIST${ENDCOLOR}"
    else
        header_msg="${YELLOW}$header_msg${ENDCOLOR}"
    fi
    echo -e "${header_msg}"
    echo
    if [ -n "$help" ]; then
        echo -e "usage: ${YELLOW}gitb push <mode>${ENDCOLOR}"
        echo
        echo -e "${YELLOW}Available modes${ENDCOLOR}"
        echo -e "<empty>\t\tPrint list of commits, push them to current branch or pull changes first"
        echo -e "yes|y\t\tSame as <empty> but without pressing 'y'"
        echo -e "force|f\t\tSame as <empty> but with --force"
        echo -e "list|log|l\tPrint a list of unpushed local commits without actual pushing it"
        echo -e "help|h\t\tShow this help"
        exit
    fi
    get_push_list ${current_branch} ${main_branch} ${origin_name}
    if [ -z "$push_list" ]; then
        echo -e "${GREEN}Nothing to push${ENDCOLOR}"
        exit
    fi
    if [ "${history_from}" != "${origin_name}/${current_branch}" ]; then
        echo -e "Branch ${YELLOW}${current_branch}${ENDCOLOR} doesn't exist in the ${YELLOW}${origin_name}${ENDCOLOR}, get commits diff from the base commit"
    fi
    count=$(echo -e "$push_list" | wc -l | sed 's/^ *//;s/ *$//')
    echo -e "Your branch is ahead ${YELLOW}${history_from}${ENDCOLOR} by ${BOLD}$count${ENDCOLOR} commits"
    echo -e "$push_list"
    if [ -n "$list" ]; then
        exit
    fi
    echo
    if [ -n "${force}" ]; then
        force_arg=" --force"
    fi
    if [ -z "${fast}" ]; then
        echo -e "Do you want to push${RED}${force_arg}${ENDCOLOR} this commits to ${YELLOW}${origin_name}/${current_branch}${ENDCOLOR} (y/n)?"
        if [ "${current_branch}" == "${main_branch}" ]; then
            echo -e "${RED}Warning!${ENDCOLOR} You are going to push right in the default ${YELLOW}${main_branch}${ENDCOLOR} branch"
        fi
        yes_no_choice "Pushing..."
    else
        echo -e "${YELLOW}Pushing...${ENDCOLOR}"
        echo
    fi
    push $force_arg
    echo -e "${RED}Cannot push!${ENDCOLOR} There are unpulled changes in ${YELLOW}${origin_name}/${current_branch}${ENDCOLOR}"
    echo
    echo -e "Do you want to pull ${YELLOW}${origin_name}/${current_branch}${ENDCOLOR} (y/n)?"
    yes_no_choice "Pulling..."
    pull $current_branch $origin_name $editor
    echo
    echo -e "${YELLOW}Pushing...${ENDCOLOR}"
    echo
    push $force_arg
}
function cleanup_on_exit {
    if [ -n "$1" ]; then
        git restore --staged "$1"
    fi
}
function handle_ai_commit_generation {
    local step="$1"
    local ai_mode="$2"
    local commit_prefix="$3"
    local skip_confirmation="$4"
    echo
    if [ "$ai_mode" = "subject" ]; then
        echo -e "${YELLOW}Step ${step}.${ENDCOLOR} Generating ${YELLOW}commit message summary${ENDCOLOR} using AI..."
    else
        echo -e "${YELLOW}Step ${step}.${ENDCOLOR} Generating ${YELLOW}commit message${ENDCOLOR} using AI..."
    fi
    if ! check_ai_available; then
        cleanup_on_exit "$git_add"
        exit 1
    fi
    local ai_commit_message
    if [ "$ai_mode" = "full" ] && [ -n "${msg}" ]; then
        ai_commit_message=$(generate_ai_commit_message_full)
    elif [ "$ai_mode" = "subject" ]; then
        ai_commit_message=$(generate_ai_commit_message_subject "$commit_prefix")
    else
        ai_commit_message=$(generate_ai_commit_message)
    fi
    if [ $? -ne 0 ] || [ -z "$ai_commit_message" ]; then
        echo -e "${RED}Failed to generate AI commit message${ENDCOLOR}"
        cleanup_on_exit "$git_add"
        exit 1
    fi
    ai_commit_message=$(echo "$ai_commit_message" | sed 's/^"//;s/"$//' | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')
    echo
    echo -e "${GREEN}AI generated commit message:${ENDCOLOR}"
    echo -e "${BOLD}$ai_commit_message${ENDCOLOR}"
    echo
    local choice="y"
    if [ "$skip_confirmation" = "true" ] && [ -n "${fast}" ] && [ -z "${push}" ]; then
        choice="y"
    else
        read -n 1 -p "Use this commit message? (y/n/e to edit) " -s choice
        echo
        if [ "$ai_mode" != "subject" ]; then
            echo
        fi
    fi
    if [ "$choice" = "y" ] || [ "$choice" = "Y" ]; then
        commit="$ai_commit_message"
        if [ "$ai_mode" = "subject" ]; then
            echo
        fi
        result=$(git commit -m """$commit""" 2>&1)
        check_code $? "$result" "commit"
        git config --unset gitbasher.cached-git-add 2>/dev/null
        after_commit
        if [ -n "${push}" ]; then
            echo
            push_script y
        fi
        exit
    elif [ "$choice" = "e" ] || [ "$choice" = "E" ]; then
        if [ "$ai_mode" = "full" ] && [ -n "${msg}" ]; then
            echo -e "${YELLOW}Edit the AI generated message:${ENDCOLOR}"
            commitmsg_file=$(mktemp ".commitmsg.XXXXXX")
            echo "$ai_commit_message" > $commitmsg_file
            while [ true ]; do
                $editor $commitmsg_file
                commit_message=$(cat $commitmsg_file | sed '/^#/d')
                if [ -n "$commit_message" ]; then
                    break
                fi
                echo
                echo -e "${YELLOW}Commit message cannot be empty${ENDCOLOR}"
                echo
                read -n 1 -p "Try for one more time? (y/n) " -s -e choice
                if [ "$choice" != "y" ]; then
                    cleanup_on_exit "$git_add"
                    find . -name "$commitmsg_file*" -delete
                    exit
                fi    
            done
            commit_message=$(cat $commitmsg_file)
            rm $commitmsg_file
            echo
        else
            if [ "$ai_mode" = "subject" ]; then
                echo
            fi
            echo -e "${YELLOW}Edit the AI generated message:${ENDCOLOR}"
            read -p "" -e -i "$ai_commit_message" commit_message
        fi
        if [ -z "$commit_message" ]; then
            cleanup_on_exit "$git_add"
            exit
        fi
        commit="$commit_message"
        echo
        result=$(git commit -m """$commit""" 2>&1)
        check_code $? "$result" "commit"
        git config --unset gitbasher.cached-git-add 2>/dev/null
        after_commit
        if [ -n "${push}" ]; then
            echo
            push_script y
        fi
        exit
    else
        if [ "$ai_mode" = "subject" ]; then
            echo
        fi
        echo -e "${YELLOW}Falling back to manual commit message creation...${ENDCOLOR}"
        if [ "$ai_mode" = "subject" ]; then
            echo
        fi
    fi
}
function after_commit {
    if [ -n "$1" ]; then
        echo -e "${GREEN}Successful commit $1!${ENDCOLOR}"
    else
        echo -e "${GREEN}Successful commit!${ENDCOLOR}"
    fi
    echo
    commit_hash=$(git rev-parse HEAD)
    echo -e "${BLUE}[$current_branch ${commit_hash::7}]${ENDCOLOR}"
    if [ -z "${commit}" ]; then
        echo $(git log -1 --pretty=%B | cat)
    else
        printf "$commit\n"
    fi
    echo
    print_changes_stat "$(git --no-pager show $commit_hash --stat --format="")"
    if [ -z "${fast}" ] && [ -z "${push}" ]; then
        echo
        echo -e "Push your changes: ${YELLOW}gitb push${ENDCOLOR}"
        echo -e "Undo commit: ${YELLOW}gitb reset${ENDCOLOR}"
    fi
}
function commit_script {
    case "$1" in
        scope|s)            ;; # general commit with scope
        msg|m)              msg="true";;
        ticket|jira|j|t)    ticket="true";;
        fast|f)             fast="true";;
        fasts|fs|sf)        fast="true"; scope="true";;
        push|pu|p)          push="true";;
        fastp|fp|pf)        fast="true"; push="true";;
        fastsp|fsp|fps)     fast="true"; push="true"; scope="true";;
        fixup|fix|x)        fixup="true";;
        fixupp|fixp|xp|px)  fixup="true"; push="true";;
        fastfix|fx|xf)      fixup="true"; fast="true";;
        fastfixp|fxp|xfp)   fixup="true"; fast="true"; push="true";;
        amend|am|a)         amend="true";;
        amendf|amf|af|fa)   amend="true"; fast="true";;
        last|l)             last="true";;
        revert|rev)         revert="true";;
        llm|ai|i)           llm="true";;
        llmf|aif|if)        llm="true"; fast="true";;
        llmp|aip|ip)        llm="true"; push="true";;
        llmfp|aifp|ifp|ipf) llm="true"; fast="true"; push="true";;
        llms|ais|is)        llm="true"; scope="true";;
        llmm|aim|im)        llm="true"; msg="true";;
        help|h)             help="true";;
        *)
            wrong_mode "commit" $1
    esac
    header_msg="GIT COMMIT"
    if [ -n "${llm}" ]; then
        header_msg="$header_msg AI"
    fi
    if [ -n "${fast}" ]; then
        if [ -n "${push}" ]; then
            if [ -n "${fixup}" ]; then
                header_msg="$header_msg FAST FIXUP & PUSH"
            else
                header_msg="$header_msg FAST & PUSH"
            fi
        elif [ -n "${fixup}" ]; then
            header_msg="$header_msg FAST FIXUP"
        else
            header_msg="$header_msg FAST"
        fi
    elif [ -n "${fixup}" ]; then
        if [ -n "${push}" ]; then
            header_msg="$header_msg FIXUP & PUSH"
        else
            header_msg="$header_msg FIXUP"
        fi
    elif [ -n "${push}" ]; then
        header_msg="$header_msg & PUSH"
    elif [ -n "${msg}" ]; then
        header_msg="$header_msg MSG"
    elif [ -n "${ticket}" ]; then
        header_msg="$header_msg TICKET"
    elif [ -n "${amend}" ]; then
        header_msg="$header_msg AMEND LAST"
    elif [ -n "${last}" ]; then
        header_msg="$header_msg LAST"
    elif [ -n "${revert}" ]; then
        header_msg="$header_msg REVERT"
    fi
    echo -e "${YELLOW}${header_msg}${ENDCOLOR}"
    echo
    if [ -n "$help" ]; then
        echo -e "usage: ${YELLOW}gitb commit <mode>${ENDCOLOR}"
        echo
        echo -e "${YELLOW}Available modes${ENDCOLOR}"
        echo -e "<empty>\t\tSelect files to commit and create a conventional message in format: 'type(scope): message'"
        echo -e "fast|f\t\tAdd all files (git add .) and create a conventional commit message without scope"
        echo -e "fasts|fs|sf\tAdd all files (git add .) and create a conventional commit message with scope"
        echo -e "push|pu|p\tCreate a conventional commit and push changes at the end"
        echo -e "fastp|fp|pf\tCreate a conventional commit in the fast mode and push changes"
        echo -e "fastsp|fsp|fps\tCreate a conventional commit in the fast mode with scope and push changes"
        echo -e "fixup|fix|x\tSelect files and commit to make a --fixup commit (git commit --fixup <hash>)"
        echo -e "fixupp|fixp|xp\tSelect files and commit to make a --fixup commit and push changes"
        echo -e "fastfix|fx|xf\tAdd all files (git add .) and commit to make a --fixup commit"
        echo -e "fastfixp|fxp\tAdd all files (git add .) and commit to make a --fixup commit and push"
        echo -e "msg|m\t\tSame as <empty>, but create multiline commit message using text editor"
        echo -e "ticket|t\tSame as <empty>, but add tracker's ticket info to the end of the commit header"
        echo -e "amend|am|a\tSelect files and add them to the last commit without message edit (git commit --amend --no-edit)"
        echo -e "amendf|amf|af\tAdd all fiels to the last commit without message edit (git commit --amend --no-edit)"
        echo -e "last|l\t\tChange commit message to the last one"
        echo -e "revert|rev\tSelect a commit to revert (git revert -no-edit <commit>)"
        echo -e "llm|ai|i\tUse AI to generate commit message based on staged changes"
        echo -e "llmf|aif|if\tUse AI to generate commit message in the fast mode (git add .) without confirmation"
        echo -e "llmp|aip|ip\tUse AI to generate commit message and push changes"
        echo -e "llmfp|aifp|ifp\tUse AI to generate commit message in the fast mode and push changes"
        echo -e "llms|ais|is\tUse AI to generate commit summary with manual type and scope enter"
        echo -e "llmm|aim|im\tUse AI to generate multiline commit message with body"
        echo -e "help|h\t\tShow this help"
        git config --unset gitbasher.cached-git-add 2>/dev/null
        exit
    fi
    if [ -n "$last" ]; then
        git config --unset gitbasher.cached-git-add 2>/dev/null
        git commit --amend
        exit
    fi
    is_clean=$(git status | tail -n 1)
    if [ "$is_clean" = "nothing to commit, working tree clean" ]; then
        if [ -z "${revert}" ]; then
            git config --unset gitbasher.cached-git-add 2>/dev/null
            echo -e "${GREEN}Nothing to commit, working tree clean${ENDCOLOR}"
            exit
        fi
    elif [ -n "${revert}" ]; then
        echo -e "${RED}Cannot revert! There are uncommited changes:${ENDCOLOR}"
        exit
    fi
    if [ -n "${revert}" ]; then
        echo -e "${YELLOW}Step 1.${ENDCOLOR} Select a commit to ${YELLOW}revert${ENDCOLOR} it:"
        choose_commit 20
        result=$(git revert --no-edit ${commit_hash} 2>&1)
        check_code $? "$result" "revert"
        after_commit "revert"
        exit
    fi
    if [ -z "${fast}" ]; then 
        echo -e "${YELLOW}Changed files${ENDCOLOR}"
        git_status
    fi
    saved_git_add=""
    if [ -z "${fast}" ]; then
        saved_git_add=$(git config --get gitbasher.cached-git-add 2>/dev/null)
        if [ -n "$saved_git_add" ]; then
            echo
            echo -e "${YELLOW}Found previous git add arguments:${ENDCOLOR} ${BOLD}$saved_git_add${ENDCOLOR}"
            read -n 1 -p "Use them? (y/n) " -s choice
            echo
            if [ "$choice" = "y" ] || [ "$choice" = "Y" ]; then
                git add "$saved_git_add"
                if [ $? -eq 0 ]; then
                    git_add="$saved_git_add"
                    use_saved_git_add="true"
                else
                    echo
                    echo -e "${RED}Failed to apply saved git add arguments, continuing normally${ENDCOLOR}"
                    git config --unset gitbasher.cached-git-add 2>/dev/null
                fi
                echo
            else
                git config --unset gitbasher.cached-git-add 2>/dev/null
            fi
        fi
    fi
    if [ -n "${fast}" ]; then
        git add .
        git_add="."
        git config --unset gitbasher.cached-git-add 2>/dev/null
    elif [ -n "${use_saved_git_add}" ]; then
        echo -e "${YELLOW}Step 1.${ENDCOLOR} Using saved git add arguments: ${BOLD}$git_add${ENDCOLOR}"
        echo
    else
        echo
        printf "${YELLOW}Step 1.${ENDCOLOR} List files for "
        if [ -n "${fixup}" ]; then
            printf "${YELLOW}--fixup${ENDCOLOR} "
        elif [ -n "${squash}" ]; then
            printf "${YELLOW}--squash${ENDCOLOR} "
        elif [ -n "${amend}" ]; then
            printf "${YELLOW}--amend${ENDCOLOR} "
        fi
        if [ -n "${amend}" ]; then
            printf "to the last commit in the ${YELLOW}${current_branch}${ENDCOLOR} branch\n"
        else
            printf "commit to the ${YELLOW}${current_branch}${ENDCOLOR} branch\n"
        fi
        echo "Press Enter if you want to exit"
        while [ true ]; do
            read -p "$(echo -n -e "${BOLD}git add${ENDCOLOR} ")" -e git_add
            git_add=$(echo "$git_add" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')
            if [ "$git_add" == "" ]; then
                exit
            fi
            result=$(git add "$git_add" 2>&1)
            if [ $? -eq 0 ]; then
                git config gitbasher.cached-git-add "$git_add"
                break
            else
                if [[ "$result" == *"did not match any files"* ]] && [[ "$git_add" != *"*" ]]; then
                    echo "$result"
                    git_add_with_star="${git_add}*"
                    echo -e "${YELLOW}Trying with wildcard:${ENDCOLOR} ${BOLD}git add $git_add_with_star${ENDCOLOR}"
                    result_star=$(git add "$git_add_with_star" 2>&1)
                    if [ $? -eq 0 ]; then
                        git config gitbasher.cached-git-add "$git_add_with_star"
                        git_add="$git_add_with_star"
                        break
                    else
                        echo "$result_star"
                        echo
                    fi
                else
                    echo "$result"
                fi
            fi
        done
        echo
    fi
    echo -e "${YELLOW}Staged files:${ENDCOLOR}"
    staged="$(sed 's/^/\t/' <<< "$(git diff --name-only --cached)")"
    echo -e "${GREEN}${staged}${ENDCOLOR}"
    if [ -n "${llm}" ] && [ -z "${scope}" ]; then
        if [ -n "${fast}" ]; then
            step="1"
        else
            step="2"
        fi
        handle_ai_commit_generation "$step" "full" "" "true"
    fi
    if [ -n "${fixup}" ]; then
        echo
        echo -e "${YELLOW}Step 2.${ENDCOLOR} Select a commit to ${YELLOW}--fixup${ENDCOLOR}:"
        if [ -n "${fast}" ]; then
            choose_commit 9
        else
            choose_commit 19
        fi
        result=$(git commit --fixup $commit_hash 2>&1)
        check_code $? "$result" "fixup"
        git config --unset gitbasher.cached-git-add 2>/dev/null
        after_commit "fixup"
        if [ -n "${push}" ]; then
            echo
            push_script y
        fi
        exit
    fi
    if [ -n "${amend}" ]; then
        result=$(git commit --amend --no-edit 2>&1)
        check_code $? "$result" "amend"
        git config --unset gitbasher.cached-git-add 2>/dev/null
        echo
        after_commit "amend"
        exit
    fi
    echo
    step="2"
    if [ -n "${fast}" ]; then
        step="1"
    fi
    echo -e "${YELLOW}Step ${step}.${ENDCOLOR} What ${YELLOW}type${ENDCOLOR} of changes do you want to commit?"
    echo -e "Final meesage will be ${YELLOW}<type>${ENDCOLOR}(${BLUE}<scope>${ENDCOLOR}): ${BLUE}<summary>${ENDCOLOR}"
    echo -e "1. ${BOLD}feat${ENDCOLOR}:\tnew feature, logic change or performance improvement"
    echo -e "2. ${BOLD}fix${ENDCOLOR}:\t\tsmall changes, eg. bug fix"
    echo -e "3. ${BOLD}refactor${ENDCOLOR}:\tcode change that neither fixes a bug nor adds a feature, style changes"
    echo -e "4. ${BOLD}test${ENDCOLOR}:\tadding missing tests or changing existing tests"
    echo -e "5. ${BOLD}build${ENDCOLOR}:\tchanges that affect the build system or external dependencies"
    echo -e "6. ${BOLD}ci${ENDCOLOR}:\t\tchanges to CI configuration files and scripts"
    echo -e "7. ${BOLD}chore${ENDCOLOR}:\tmaintanance and housekeeping"
    echo -e "8. ${BOLD}docs${ENDCOLOR}:\tdocumentation changes"
    echo -e "9.  \t\twrite plain commit without type and scope"
    echo -e "0. Exit without changes"
    declare -A types=(
        [1]="feat"
        [2]="fix"
        [3]="refactor"
        [4]="test"
        [5]="build"
        [6]="ci"
        [7]="chore"
        [8]="docs"
    )
    while [ true ]; do
        read -n 1 -s choice
        if [ "$choice" == "0" ]; then
            cleanup_on_exit "$git_add"
            exit
        fi
        re='^[0-9]+$'
        if ! [[ $choice =~ $re ]]; then
            continue
        fi
        if [ "$choice" == "9" ]; then
            is_empty="true"
            break
        fi
        commit_type="${types[$choice]}"
        if [ -n "$commit_type" ]; then
            break
        fi
    done
    commit=""
    if [ -z "$is_empty" ]; then
        commit="$commit_type"
    fi
    if [ -z "$is_empty" ] && ([ -z "$fast" ] || [ -n "$scope" ]); then
        step="3"
        if [ -n "${fast}" ]; then
            step="2"
        fi
        echo
        echo -e "${YELLOW}Step ${step}.${ENDCOLOR} Enter a ${YELLOW}scope${ENDCOLOR} of changes to provide some additional context"
        echo -e "Final meesage will be ${BLUE}${commit_type}${ENDCOLOR}(${YELLOW}<scope>${ENDCOLOR}): ${BLUE}<summary>${ENDCOLOR}"
        echo -e "Press Enter to continue without scope or enter 0 to exit without changes"
        detected_scopes=""
        staged_files=$(git diff --name-only --cached)
        if [ -n "$staged_files" ]; then
            declare -A scope_counts
            declare -A scope_depths
            while IFS= read -r file; do
                if [ -n "$file" ]; then
                    IFS='/' read -r -a path_components <<< "$file"
                    for i in "${!path_components[@]}"; do
                        component="${path_components[$i]}"
                        if [ -n "$component" ]; then
                            if [ $i -eq $((${#path_components[@]} - 1)) ]; then
                                component_no_ext="${component%.*}"
                                if [[ ! "$component_no_ext" =~ ^(index|main|app|test|spec|config|readme|license|makefile|dockerfile)$ ]]; then
                                    scope_counts["$component_no_ext"]=$((${scope_counts["$component_no_ext"]:-0} + 1))
                                    current_depth=$((i + 1))
                                    if [ -z "${scope_depths["$component_no_ext"]}" ] || [ $current_depth -lt ${scope_depths["$component_no_ext"]} ]; then
                                        scope_depths["$component_no_ext"]=$current_depth
                                    fi
                                fi
                            else
                                if [[ ! "$component" =~ ^(src|lib|test|tests|spec|specs|build|dist|node_modules|vendor|tmp|temp|cache|logs|log)$ ]]; then
                                    scope_counts["$component"]=$((${scope_counts["$component"]:-0} + 1))
                                    current_depth=$((i + 1))
                                    if [ -z "${scope_depths["$component"]}" ] || [ $current_depth -lt ${scope_depths["$component"]} ]; then
                                        scope_depths["$component"]=$current_depth
                                    fi
                                fi
                            fi
                        fi
                    done
                fi
            done <<< "$staged_files"
            max_count=0
            for token in "${!scope_counts[@]}"; do
                if [ ${scope_counts["$token"]} -gt $max_count ]; then
                    max_count=${scope_counts["$token"]}
                fi
            done
             detected_scopes_array=()
             for token in "${!scope_counts[@]}"; do
                 count=${scope_counts["$token"]}
                 depth=${scope_depths["$token"]}
                 if [ $max_count -gt 1 ]; then
                     if [ $count -gt 1 ]; then
                         detected_scopes_array+=("$count:$depth:$token")
                     fi
                 else
                     detected_scopes_array+=("$count:$depth:$token")
                 fi
             done
             if [ ${#detected_scopes_array[@]} -gt 0 ]; then
                 filename_entries=()
                 directory_entries=()
                 for entry in "${detected_scopes_array[@]}"; do
                     count="${entry%%:*}"  # Extract count (first field)
                     rest="${entry#*:}"    # Remove count
                     depth="${rest%%:*}"   # Extract depth (second field)
                     token="${rest#*:}"    # Extract token (third field)
                     if [ $depth -ge 4 ]; then  # Assume depth 4+ are likely filenames
                         filename_entries+=("$entry")
                     else
                         directory_entries+=("$entry")
                     fi
                 done
                 IFS=$'\n' filename_sorted=($(printf '%s\n' "${filename_entries[@]}" | sort -t':' -k1,1nr -k2,2n -k3,3))
                 unset IFS
                 IFS=$'\n' directory_sorted=($(printf '%s\n' "${directory_entries[@]}" | sort -t':' -k1,1nr -k2,2n -k3,3))
                 unset IFS
                 detected_scopes_sorted=("${filename_sorted[@]}" "${directory_sorted[@]}")
                 final_scopes=()
                 count=0
                 for entry in "${detected_scopes_sorted[@]}"; do
                     if [ $count -ge 9 ]; then
                         break
                     fi
                     token="${entry##*:}"  # Extract token after last colon
                     final_scopes+=("$token")
                     count=$((count + 1))
                 done
                 detected_scopes="${final_scopes[*]}"
             fi
        fi
        all_scopes=""
        if [ -n "$scopes" ]; then
            all_scopes="$scopes"
        elif [ -n "$detected_scopes" ]; then
            all_scopes="$detected_scopes"
        fi
        if [ -n "$all_scopes" ]; then
           IFS=' ' read -r -a scopes_array <<< "$all_scopes"
           res=""
           for i in "${!scopes_array[@]}"; do
                scope_display="${scopes_array[$i]}"
                res="$res$((i+1)). ${BOLD}${scope_display}${ENDCOLOR}|"
           done
           echo -e "You can select one of the ${YELLOW}detected scopes${ENDCOLOR}: $(echo $res | column -ts'|')"            
        fi
        while [ true ]; do
            read -p "<scope>: " -e commit_scope
            if [ "$commit_scope" == "0" ]; then
                cleanup_on_exit "$git_add"
                exit
            fi
            if [ -z "$commit_scope" ]; then
                commit="$commit: "
                break
            fi
            re_number='^[1-9][0-9]*$'
            if [[ $commit_scope =~ $re_number ]] && [ -n "$all_scopes" ]; then
                IFS=' ' read -r -a scopes_array <<< "$all_scopes"
                index=$((commit_scope - 1))
                if [ $index -ge 0 ] && [ $index -lt ${#scopes_array[@]} ]; then
                    selected_scope="${scopes_array[$index]}"
                    commit_scope="${selected_scope#*}"
                    commit="$commit($commit_scope): "
                    break
                else
                    echo -e "${RED}Invalid scope index! Please choose from 1-${#scopes_array[@]} or enter custom scope.${ENDCOLOR}"
                    continue
                fi
            else
                re='^[a-zA-Z0-9/,_.-]+$'
                if [[ $commit_scope =~ $re ]]; then
                    commit="$commit($commit_scope): "
                    break
                else
                    echo -e "${RED}Invalid scope format! Use only letters, numbers, hyphens, underscores, and dots.${ENDCOLOR}"
                    echo -e "${RED}Debug: input was '$commit_scope'${ENDCOLOR}"
                    continue
                fi
            fi
        done
    fi
    if [ -z "$is_empty" ] && [ -n "$fast" ] && [ -z "$scope" ]; then
        commit="$commit: "
    fi
    if [ -n "${fast}" ]; then
        if [ -n "$scope" ]; then
            step="3"
        else
            step="2"
        fi
    elif [ -n "$is_empty" ]; then
        step="3"
    else
        step="4"
    fi
    if [ -n "${llm}" ] && [ -n "${scope}" ]; then
        handle_ai_commit_generation "$step" "subject" "$commit" "false"
    else
        echo
    fi
    echo -e "${YELLOW}Step ${step}.${ENDCOLOR} Write a ${YELLOW}summary${ENDCOLOR} about your changes"
    if [ -n "$is_empty" ]; then
        echo -e "Final meesage will be ${YELLOW}<summary>${ENDCOLOR}"
    elif [ "$commit_scope" == "" ]; then
        echo -e "Final meesage will be ${BLUE}${commit_type}${ENDCOLOR}: ${YELLOW}<summary>${ENDCOLOR}"
    else
        echo -e "Final meesage will be ${BLUE}${commit_type}${ENDCOLOR}(${BLUE}${commit_scope}${ENDCOLOR}): ${YELLOW}<summary>${ENDCOLOR}"
    fi
    echo -e "Press Enter if you want to exit"
    if [ -n "$msg" ]; then
        commitmsg_file=$(mktemp ".commitmsg.XXXXXX")
        staged_with_tab="$(sed 's/^/####\t/' <<< "${staged}")"
        echo """
####
#### Step ${step}. Write a <summary> about your changes. Lines starting with '#' will be ignored. 
#### 
#### On branch ${current_branch}
#### Changes to be commited:
${staged_with_tab}
####
#### Here is expected format:
#### ${commit}<summary>
#### <BLANK LINE>
#### <optional body>
#### <BLANK LINE>
#### <optional footer>
####
#### Summary should provide a succinct description of the change:
####     use the imperative, present tense: 'change' not 'changed' nor 'changes'
####     no dot (.) at the end
####     don't capitalize the first letter
####
#### The body is optional and should explain why you are making the change. 
####
#### The footer is optional and should contain any information about 'Breaking Changes'.
#### Breaking Change section should start with the phrase 'BREAKING CHANGE: ' followed by a summary of the breaking change.
####
#### Similarly, a Deprecation section should start with 'DEPRECATED: ' followed by a short description of what is deprecated.
""" >> $commitmsg_file
        while [ true ]; do
            $editor $commitmsg_file
            commit_message=$(cat $commitmsg_file | sed '/^#/d')
            if [ -n "$commit_message" ]; then
                break
            fi
            echo
            echo -e "${YELLOW}Commit message cannot be empty${ENDCOLOR}"
            echo
            read -n 1 -p "Try for one more time? (y/n) " -s -e choice
            if [ "$choice" != "y" ]; then
                cleanup_on_exit "$git_add"
                find . -name "$commitmsg_file*" -delete
                exit
            fi    
        done
        find . -name "$commitmsg_file*" -delete
    else
        read -p "$(echo -n -e "${commit}")" -e commit_message
        if [ -z "$commit_message" ]; then
            cleanup_on_exit "$git_add"
            exit
        fi
    fi
    if [ -n "${ticket}" ]; then
        echo
        echo -e "${YELLOW}Step 5.${ENDCOLOR} Enter the number of a resolved issue (e.g. in JIRA or Youtrack)"
        echo -e "It will be added to the end of the summary header"
        echo -e "Press Enter to continue or 0 to exit without changes"
        if [ -n "$ticket_name" ]; then
            read -p "${ticket_name}${sep}" -e commit_ticket
        else 
            read -p "<ticket>: " -e commit_ticket
        fi
        if [ "$commit_ticket" == "0" ]; then
            cleanup_on_exit "$git_add"
            exit
        fi
        if [ "$commit_ticket" != "" ]; then
            commit_ticket=$(echo "$commit_ticket" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')
            summary=$(echo "$commit_message" | head -n 1)
            remaining_message=""
            if [ "$summary" != "$commit_message" ]; then
                remaining_message=$(echo "$commit_message" | tail -n +2)
                remaining_message="""
    $remaining_message"
            fi
            if [ -n "$ticket_name" ]; then
                commit_ticket="${ticket_name}${sep}${commit_ticket}"
            fi
            commit_message="$summary ($commit_ticket)$remaining_message"
        fi
    fi
    commit="${commit}${commit_message}"
    echo
    result=$(git commit -m """$commit""" 2>&1)
    check_code $? "$result" "commit"
    git config --unset gitbasher.cached-git-add 2>/dev/null
    after_commit
    if [ -n "${push}" ]; then
        echo
        push_script y
    fi
}
function branch_script {
    case "$1" in
        list|l)      list="true";;
        remote|r|re) remote="true";;
        main|def|m)  main="true";;
        new|n|c)          
            new="true"
            current="true"    
        ;;
        newd|nd|cd)        
            new="true"
        ;;
        delete|del|d) delete="true";;
        tag|t)        tag="true";;
        help|h)       help="true";;
        *)
            wrong_mode "branch" $1
    esac
    header="GIT BRANCH"
    if [ -n "${remote}" ]; then
        header="$header REMOTE"
    elif [ -n "${main}" ]; then
        header="$header DEFAULT"
    elif [ -n "${current}" ]; then
        header="$header NEW"
    elif [ -n "${new}" ]; then
        header="$header NEW FROM DEFAULT"
    elif [ -n "${list}" ]; then
        header="$header LIST"
    elif [ -n "${delete}" ]; then
        header="$header DELETE"
    elif [ -n "${tag}" ]; then
        header="$header TAG"
    fi
    echo -e "${YELLOW}${header}${ENDCOLOR}"
    echo
    if [ -n "$help" ]; then
        echo -e "usage: ${YELLOW}gitb branch <mode>${ENDCOLOR}"
        echo
        echo -e "${YELLOW}Available modes${ENDCOLOR}"
        echo -e "<empty>\t\tSelect a local branch to switch"
        echo -e "list|l\t\tPrint a list of local branches"
        echo -e "remote|re|r\tFetch $origin_name and select a remote branch to switch"
        echo -e "main|def|m\tSwitch to $main_branch without additional confirmations"
        echo -e "tag|t\t\tCheckout to a specific tag"
        echo -e "new|n|c\t\tBuild a conventional name and create a new branch from $main_branch"
        echo -e "newd|nd\t\tBuild a conventional name, switch to $main_branch, pull it and create new branch"
        echo -e "delete|del|d\tSelect a local branch to delete"
        echo -e "help|h\t\tShow this help"
        exit
    fi
    if [[ -n "${main}" ]]; then
        switch ${main_branch}
        exit
    fi
    if [[ -n "${tag}" ]]; then
        echo -e "${YELLOW}Do you want to fetch remote tags first?${ENDCOLOR}"
        read -n 1 -p "Fetch remote? (y/n) " choice
        echo
        if [ "$choice" = "y" ] || [ "$choice" = "Y" ]; then
            echo
            echo -e "${YELLOW}Fetching remote tags...${ENDCOLOR}"
            fetch_output=$(git fetch --tags 2>&1)
            check_code $? "$fetch_output" "fetch remote tags"
        fi
        echo
        echo -e "${YELLOW}Select a tag to checkout:${ENDCOLOR}"
        tags_info_str=$(git for-each-ref --count=999  --sort=-creatordate refs/tags --format="${BLUE_ES}%(refname:short)${ENDCOLOR_ES} | %(contents:subject) | ${YELLOW_ES}%(objectname:short)${ENDCOLOR_ES} | ${CYAN_ES}%(creatordate:human)${ENDCOLOR_ES}" | column -ts'|' )
        IFS=$'\n' read -rd '' -a tags_info <<<"$tags_info_str"
        if [ -z "$tags_info" ]; then
            echo -e "${RED}No tags found in this repository${ENDCOLOR}"
            exit
        fi
        for index in "${!tags_info[@]}"; do
            echo -e "$(($index+1)). ${tags_info[index]}"
        done
        echo "0. Exit without changes"
        echo
        while [ true ]; do
            read -p "Select tag number: " choice
            if [ "$choice" == "0" ] || [ "$choice" == "" ]; then
                exit
            fi
            re='^[1-9][0-9]*$'
            if [[ $choice =~ $re ]]; then
                index=$((choice - 1))
                if [ $index -ge 0 ] && [ $index -lt ${#tags_info[@]} ]; then
                    selected_tag=$(git for-each-ref --count=999 --sort=-creatordate refs/tags --format='%(refname:short)' | sed -n "$((index+1))p")
                    break
                else
                    echo -e "${RED}Invalid tag number! Please choose from 1-${#tags_info[@]}.${ENDCOLOR}"
                    echo
                    continue
                fi
            else
                echo -e "${RED}Please enter a valid tag number.${ENDCOLOR}"
                echo
                continue
            fi
        done
        echo
        echo -e "${YELLOW}Checking out to tag ${selected_tag}...${ENDCOLOR}"
        echo
        checkout_output=$(git checkout $selected_tag 2>&1)
        checkout_code=$?
        if [ $checkout_code -eq 0 ]; then
            echo -e "${GREEN}Successfully checked out to tag '${selected_tag}'${ENDCOLOR}"
            echo -e "${YELLOW}Note: You are now in 'detached HEAD' state${ENDCOLOR}"
            echo -e "If you want to make changes, create a new branch: ${YELLOW}gitb branch new${ENDCOLOR}"
        else
            echo -e "${RED}Failed to checkout to tag ${selected_tag}! Error message:${ENDCOLOR}"
            echo "${checkout_output}"
            exit $checkout_code
        fi
        exit
    fi
    if [[ -z "$new" ]] && [[ -z "$remote" ]] && [[ -z "$delete" ]] && [[ -z "$list" ]] && [[ -z "$tag" ]]; then
        echo -e "${YELLOW}Select a branch to switch from '${current_branch}'${ENDCOLOR}:"
        choose_branch
        echo
        switch ${branch_name}
        exit
    elif [[ -z "$new" ]] && [[ -n "$remote" ]] && [[ -z "$delete" ]] && [[ -z "$tag" ]]; then
        echo -e "${YELLOW}Fetching remote...${ENDCOLOR}"
        echo
        fetch_output=$(git fetch 2>&1)
        check_code $? "$fetch_output" "fetch remote"
        prune_output=$(git remote prune $origin_name 2>&1)
        echo -e "${YELLOW}Switch from '${current_branch}' to the remote branch${ENDCOLOR}"
        choose_branch "remote"
        echo
        switch ${branch_name}
        exit
    elif [[ -z "$new" ]] && [[ -n "$delete" ]] && [[ -z "$tag" ]]; then
        IFS=$'\n' read -rd '' -a merged_branches <<<"$(git branch -v --sort=-committerdate --merged | cat 2>&1)"
        merged_branches_without_main=()
        for index in "${!merged_branches[@]}"
        do
            branch_with_info="$(echo "${merged_branches[index]}" | sed -e 's/^[[:space:]]*//')"
            if [[ ${branch_with_info} != "${main_branch}"* ]] && [[ ${branch_with_info} != "*"* ]] ; then
                merged_branches_without_main+=("$branch_with_info")
            fi
        done
        number_of_branches=${#merged_branches_without_main[@]}
        if [ $number_of_branches != 0 ]; then
            echo -e "${YELLOW}Do you want to delete merged local branches?${ENDCOLOR}"
            echo -e "These are branches without new changes regarding ${YELLOW}${main_branch}${ENDCOLOR}"
            for index in "${!merged_branches_without_main[@]}"
            do
                printf "\t${merged_branches_without_main[index]}\n"
            done
            printf "\nAnswer (y/n): "
            while [ true ]; do
                read -n 1 -s choice
                if [ "$choice" == "y" ]; then
                    printf "y\n\n"
                    branches_to_delete="$(git branch --merged | egrep -v "(^\*|master|main|develop|${main_branch})" | xargs)"
                    IFS=$' ' read -rd '' -a branches <<<"$branches_to_delete"
                    for index in "${!branches[@]}"
                    do
                        branch_to_delete="$(echo "${branches[index]}" | xargs)"
                        delete_output=$(git branch -d $branch_to_delete 2>&1)
                        delete_code=$?
                        if [ $delete_code == 0 ]; then
                            echo -e "${GREEN}Branch '$branch_to_delete' is deleted!${ENDCOLOR}"
                        else
                            echo -e "${RED}Cannot delete branch '$branch_to_delete'!${ENDCOLOR}"
                            echo -e "${delete_output}"
                            break
                        fi
                    done
                    echo
                    break
                else
                    printf "n\n\n"
                    break
                fi
            done
        fi
        echo -e "${YELLOW}Delete a local branch${ENDCOLOR}"
        choose_branch "delete"
        echo
        delete_output=$(git branch -d $branch_name 2>&1)
        delete_code=$?
        if [ "$delete_code" == 0 ]; then
            echo -e "${GREEN}Branch '$branch_name' is deleted!${ENDCOLOR}"
        elif [[ ${delete_output} == *"is not fully merged"* ]]; then
            echo -e "${RED}The branch '$branch_name' is not fully merged${ENDCOLOR}"
            echo "Do you want to force delete (-D flag) this branch?"
            printf "Answer (y/n): "
            while [ true ]; do
                read -n 1 -s choice
                if [ "$choice" == "y" ]; then
                    printf "y\n\n"
                    delete_output=$(git branch -D $branch_name 2>&1)
                    delete_code=$?
                    if [ "$delete_code" != 0 ]; then
                        echo -e "${RED}Cannot delete branch '$branch_name'! Error message:${ENDCOLOR}"
                        echo -e "${delete_output}"
                        exit
                    fi
                    echo -e "${GREEN}Branch '$branch_name' is deleted!${ENDCOLOR}"
                    break
                elif [ "$choice" == "n" ]; then
                    printf "n\n"
                    exit
                fi
            done
        else
            echo -e "${RED}Cannot delete branch '$branch_name'! Error message:${ENDCOLOR}"
            echo -e "${delete_output}"
            exit
        fi
        remote_check=$(git --no-pager log $origin_name/$branch_name..HEAD 2>&1)
        if [[ $remote_check != *"unknown revision or path not in the working tree"* ]]; then
            echo
            echo -e "${YELLOW}Do you want to delete this branch in the remote?${ENDCOLOR}"
            printf "Answer (y/n): "
            while [ true ]; do
                read -n 1 -s choice
                if [ "$choice" == "y" ]; then
                    printf "y\n\n"
                    echo -e "${YELLOW}Deleting...${YELLOW}"
                    push_output=$(git push $origin_name -d $branch_name 2>&1)
                    push_code=$?
                    echo
                    if [ "$push_code" != 0 ]; then
                        echo -e "${RED}Cannot delete branch '$branch_name'! Error message:${ENDCOLOR}"
                        echo -e "${delete_output}"
                        exit
                    fi
                    echo -e "${GREEN}Branch '$branch_name' is deleted in the remote!${ENDCOLOR}"
                    break
                elif [ "$choice" == "n" ]; then
                    printf "n\n"
                    exit
                fi
            done
        fi
        exit
    fi
    if [ -n "$current" ]; then
        echo -e "${YELLOW}Current local branches:${ENDCOLOR}"
        list_branches
    else
         echo -e "It will switch to ${BOLD}${BLUE}${main_branch}${ENDCOLOR} and pull it first"
    fi
    if [ -n "$list" ]; then
        exit
    fi
    echo
    detected_prefixes=""
    all_branches=$(git branch -a --format='%(refname:short)' 2>/dev/null | sed 's|origin/||g' | sort -u)
    if [ -n "$all_branches" ]; then
        declare -A prefix_candidates
        while IFS= read -r branch; do
            if [ -n "$branch" ] && [[ "$branch" != "$main_branch" ]] && [[ "$branch" != "HEAD" ]]; then
                if [[ "$branch" =~ ^([a-zA-Z0-9]+)[-_/](.+)$ ]]; then
                    prefix="${BASH_REMATCH[1]}"
                    if [[ ${#prefix} -ge 2 ]] && [[ ! "$prefix" =~ ^(dev|tmp|old|new|test)$ ]]; then
                        prefix_candidates["$prefix"]=1
                    fi
                fi
            fi
        done <<< "$all_branches"
        detected_prefixes_array=()
        for prefix in "${!prefix_candidates[@]}"; do
            detected_prefixes_array+=("$prefix")
        done
        if [ ${#detected_prefixes_array[@]} -gt 0 ]; then
            IFS=$'\n' detected_prefixes_sorted=($(sort <<<"${detected_prefixes_array[*]}"))
            unset IFS
            detected_prefixes="${detected_prefixes_sorted[*]}"
        fi
    fi
    all_prefixes=""
    if [ -n "$ticket_name" ]; then
        if [ -n "$detected_prefixes" ]; then
            all_prefixes="$ticket_name $detected_prefixes"
        else
            all_prefixes="$ticket_name"
        fi
    elif [ -n "$detected_prefixes" ]; then
        all_prefixes="$detected_prefixes"
    fi
    branch_type=""
    branch_type_and_sep=""
    if [ -z "$all_prefixes" ]; then
        echo -e "${YELLOW}Step 1.${ENDCOLOR} Enter the full name of the branch"
        echo "Press Enter if you want to exit"
        printf "${BOLD}git branch${ENDCOLOR} "
        read -e branch_name
        if [ -z "$branch_name" ]; then
            exit
        fi
        branch_name="${branch_name##*( )}"
    else
        branch_to_show=$current_branch
        if [ -z "$current" ]; then
            branch_to_show=$main_branch
        fi
        echo -e "${YELLOW}Step 1.${ENDCOLOR} Enter a ${YELLOW}prefix${ENDCOLOR} for your new branch from ${BOLD}${BLUE}${branch_to_show}${ENDCOLOR}"
        echo -e "A branch will be created with '${YELLOW}${sep}${ENDCOLOR}' as a separator (e.g., ${YELLOW}prefix${sep}name${ENDCOLOR})"
        echo -e "Press Enter to continue without prefix or enter 0 to exit without changes"
        IFS=' ' read -r -a prefixes_array <<< "$all_prefixes"
        declare -A prefixes_map
        res=""
        for i in "${!prefixes_array[@]}"; do
            option=$((i+1))
            prefixes_map["$option"]="${prefixes_array[$i]}"
            res="$res$option. ${BOLD}${prefixes_array[$i]}${ENDCOLOR}|"
        done
        no_prefix_option=$((${#prefixes_array[@]}+1))
        prefixes_map["$no_prefix_option"]=""
        echo -e "You can select one of the ${YELLOW}detected prefixes${ENDCOLOR}: $(echo $res | column -ts'|')"
        while [ true ]; do
            read -p "<prefix>: " choice
            if [ "$choice" == "0" ]; then
                exit
            fi
            if [ "$choice" == "" ]; then
                branch_type=""
                branch_type_and_sep=""
                break
            fi
            re='^[1-9][0-9]*$'
            if [[ $choice =~ $re ]] && [ -n "${prefixes_map[$choice]+isset}" ]; then
                branch_type="${prefixes_map[$choice]}"
                if [ -n "$branch_type" ]; then
                    branch_type_and_sep="${branch_type}${sep}"
                fi
                break
            else
                choice=$(echo "$choice" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')
                if [ -n "$choice" ]; then
                    re_prefix='^[a-zA-Z0-9]+$'
                    if [[ $choice =~ $re_prefix ]]; then
                        branch_type="$choice"
                        branch_type_and_sep="${branch_type}${sep}"
                        break
                    else
                        echo -e "${RED}Invalid prefix format! Use only letters and numbers.${ENDCOLOR}"
                        echo
                        continue
                    fi
                else
                    echo -e "${RED}Please enter a valid option number or custom prefix.${ENDCOLOR}"
                    echo
                    continue
                fi
            fi
        done
        echo
        echo -e "${YELLOW}Step 2.${ENDCOLOR} Enter the ${YELLOW}name${ENDCOLOR} of the branch"
        echo "Press Enter if you want to exit"
        printf "${BOLD}git branch${ENDCOLOR}"
        read -p " ${branch_type_and_sep}" -e branch_name
        if [ -z "$branch_name" ]; then
            exit
        fi
        branch_name="${branch_type_and_sep}${branch_name##*( )}"
    fi
    if [[ "$branch_name" == "HEAD" ]] || [[ "$branch_name" == "$origin_name" ]]; then
        echo
        echo -e "${RED}This name is forbidden${ENDCOLOR}"
        exit
    fi
    from_branch=$current_branch
    if [ -z "${current}" ]; then
        echo
        switch $main_branch "true"
        echo -e "${YELLOW}Pulling '$origin_name/$main_branch'...${ENDCOLOR}"
        echo
        pull $main_branch $origin_name $editor
        from_branch=$main_branch
    fi
    create_output=$(git switch -c $branch_name 2>&1)
    create_code=$?
    echo
    if [ $create_code -eq 0 ]; then
        echo -e "${GREEN}${create_output} from '$from_branch'${ENDCOLOR}"
        changes=$(git_status)
        if [ -n "$changes" ]; then
            echo
            echo -e "${YELLOW}Moved changes:${ENDCOLOR}"
            echo -e "${changes}"
        fi
        exit
    fi
    if [[ $create_output == *"already exists"* ]]; then
        echo -e "${RED}Branch with name '${branch_name}' already exists!${ENDCOLOR}"
        exit $create_code
    fi
    echo -e "${RED}Cannot create '${branch_name}'! Error message:${ENDCOLOR}"
    echo "${create_output}"
    exit $create_code
}
function push_tag {
    if [ -z "$1" ] || [ "$1" == "" ]; then
        all="true"
        push_output=$(git push $origin_name --tags 2>&1)
    elif [ -n "$2" ]; then
        push_output=$(git push --delete $origin_name $1 2>&1)
    else
        push_output=$(git push $origin_name $1 2>&1)
    fi
    push_code=$?
    if [ -n "$delete" ]; then
        if [[ "$push_output" == *"remote ref does not exist"* ]]; then
            echo -e "${RED}Tag '$1' doesn't exist in the ${origin_name}${ENDCOLOR}"
            exit
        fi
        echo -e "${GREEN}Tag '$1' is deleted from the ${origin_name}!${ENDCOLOR}"
        exit
    fi
    repo=$(get_repo)
    if [ -n "$all" ]; then
        echo
        IFS=$'\n' read -rd '' -a lines_with_success <<< "$(sed -n '/\[new tag\]/p' <<< "$push_output")"
        number_of_tags=${#lines_with_success[@]}
        if [ $number_of_tags != 0 ]; then
            echo -e "${GREEN}Pushed successfully!${ENDCOLOR}"
            for index in "${!lines_with_success[@]}"
            do
                echo -e "\t$(sed -e 's#.*\-> \(\)#\1#' <<< "${lines_with_success[index]}" )"
            done
            echo
        fi
    fi
    if [ $push_code != 0 ] ; then
        if [[ "$push_output" == *"Updates were rejected because the tag already exists in the remote"* ]]; then
            echo -e "${RED}Some tags were rejected${ENDCOLOR}"
            IFS=$'\n' read -rd '' -a lines_with_rejected <<< "$(sed -n '/\[rejected\]/p' <<< "$push_output")"
            for index in "${!lines_with_rejected[@]}"
            do
                echo -e "\t$(sed -e 's#.*\-> \(\)#\1#' <<< "${lines_with_rejected[index]}" )"
            done
            echo
            echo -e "${YELLOW}Repo:${ENDCOLOR} ${repo}"
            exit
        fi
        echo -e "${RED}Cannot push! Error message:${ENDCOLOR}"
        echo "$push_output"
        exit $push_code
    fi
    if [[ $push_output == *"Everything up-to-date"* ]]; then
        echo -e "${GREEN}Everything up-to-date${ENDCOLOR}"
    elif [ -z "$all" ]; then
        echo -e "${GREEN}Successful push tag '$1'!${ENDCOLOR}"
    else
        echo -e "${GREEN}Successful push all local tags!${ENDCOLOR}"
    fi
    echo -e "${YELLOW}Repo:${ENDCOLOR}\t${repo}"
    if [ -z "$all" ]; then
        if [[ $repo == *"github"* ]]; then
            echo -e "${YELLOW}Tag:${ENDCOLOR}\t${repo}/releases/tag/$1"
        elif [[ $repo == *"gitlab"* ]]; then
            echo -e "${YELLOW}Tag:${ENDCOLOR}\t${repo}/-/tags/$1"
        fi
    fi
}
function tag_script {
    case "$1" in
        annotated|a|an)     annotated="true";;
        commit|c|co|cm)     select="true"; commit="true";;
        all|al)             select="true"; annotated="true";;
        push|ps|ph|p)       push="true"; select="true";;
        push-all|pa)        push="true";;
        delete|del|d)       delete="true"; select="true";;
        delete-all|da)      delete="true";;
        list|log|l)         list="true";;
        remote|re|r|fetch)  list="true"; remote="true";;
        help|h)             help="true";;
        *)
            wrong_mode "tag" $1
    esac
    header="GIT TAG"
    if [ -n "${annotated}" ] && [ -n "${commit}" ]; then
        header="$header ALL"
    elif [ -n "${annotated}" ]; then
        header="$header ANNOTATED"
    elif [ -n "${commit}" ]; then
        header="$header COMMIT"
    elif [ -n "${push}" ] && [ -n "${select}" ]; then
        header="$header PUSH"
    elif [ -n "${push}" ]; then
        header="$header PUSH ALL"
    elif [ -n "${delete}" ] && [ -n "${select}" ]; then
        header="$header DELETE"
    elif [ -n "${delete}" ]; then
        header="$header DELETE ALL"    
    elif [ -n "${list}" ]; then
        header="$header LIST"
    elif [ -n "${remote}" ]; then
        header="$header REMOTE"
    fi
    echo -e "${YELLOW}${header}${ENDCOLOR}"
    echo
    if [ -n "$help" ]; then
        echo -e "usage: ${YELLOW}gitb tag <mode>${ENDCOLOR}"
        echo
        echo -e "${YELLOW}Available modes${ENDCOLOR}"
        echo -e "<empty>\t\tCreate a new tag from the last commit"
        echo -e "annotated|a|an\tCreate a new annotated tag from the last commit"
        echo -e "commit|c|co|cm\tCreate a new tag from a selected commit"
        echo -e "all|al\t\tCreate a new annotated tag from a selected commit"
        echo -e "push|ps|ph|p\tSelect a local tag and push it to the remote repository"
        echo -e "push-all|pa\tPush all tags to the remote repository"
        echo -e "delete|del|d\tSelect a tag to delete"
        echo -e "delete-all|da\tDelete all local tags"
        echo -e "list|log|l\tPrint a list of local tags"
        echo -e "remote|fetch|r\tFetch tags from the remote repository and print it"
        echo -e "help|h\t\tShow this help"
        exit
    fi
    if [ -n "${remote}" ]; then
        echo -e "${YELLOW}Fetching tags from the remote...${ENDCOLOR}"
        fetch_output=$(git fetch $origin_name --tags 2>&1)
        check_code $? "$fetch_output" "fetch tags"
        echo
        if [ "$fetch_output" != "" ]; then
            echo -e "${YELLOW}New tags:${ENDCOLOR}"
            IFS=$'\n' read -rd '' -a lines_with_tags <<< "$(sed -n '/\[new tag\]/p' <<< "$fetch_output")"
            for index in "${!lines_with_tags[@]}"
            do
                echo -e "\t$(sed -e 's#.*\-> \(\)#\1#' <<< "${lines_with_tags[index]}" )"
            done
            echo
        fi
    fi
    count=9
    if [ -n "${delete}" ] || [ -n "${push}" ] || [ -n "${list}" ]; then
        count=999  # Show all tags
    fi
    tags_info_str=$(git for-each-ref --count=$count  --sort=-creatordate refs/tags --format="${BLUE_ES}%(refname:short)${ENDCOLOR_ES} | %(contents:subject) | ${YELLOW_ES}%(objectname:short)${ENDCOLOR_ES} | ${CYAN_ES}%(creatordate:human)${ENDCOLOR_ES}" | column -ts'|' )
    IFS=$'\n' read -rd '' -a tags_info <<<"$tags_info_str"
    number_of_tags=${#tags_info[@]}
    if [ $number_of_tags == 0 ]; then
        echo -e "${YELLOW}There is no local tags${ENDCOLOR}"
        if [ -n "${delete}" ] || [ -n "${push}" ]; then
            exit
        fi
    else
        tags_header="Last ${number_of_tags} local tags"
        if [ -n "${delete}" ] || [ -n "${list}" ]; then
            tags_header="All ${number_of_tags} local tags"
        fi
        echo -e "${YELLOW}${tags_header}${ENDCOLOR}"
        for index in "${!tags_info[@]}"
        do  
            tag_line="${tags_info[index]}"
            if [ -n "${delete}" ] || [ -n "${push}" ]; then
                echo -e "$(($index+1)). ${tag_line}"
            else
                echo -e "${tag_line}"
            fi
        done
    fi
    if [ -n "$list" ]; then
        exit
    fi
    if [ -n "$push" ] && [ -z "$select" ]; then
        echo
        echo -e "${YELLOW}Pushing all tags..."${ENDCOLOR}
        push_tag
        exit
    fi
    if [ -n "${delete}" ] && [ -z "$select" ]; then
        echo
        echo -e "${YELLOW}Do you really want to delete all local tags (y/n)?${ENDCOLOR}"
        git tag | xargs git tag -d 
        exit
    fi
    if [ -n "${delete}" ] || [ -n "$push" ]; then
        if [ $number_of_tags -gt 9 ]; then
            echo "00. Exit"
        else
            echo "0. Exit"
        fi
        echo
        if [ -n "${delete}" ]; then
            read_prefix="Enter tag number to delete: "
        else
            read_prefix="Enter tag number to push: "
        fi
        IFS=$'\n' read -rd '' -a tags <<<"$(git for-each-ref --count=$count  --sort=-creatordate refs/tags --format="%(refname:short)")"
        choose "${tags[@]}"
        tag_name=$choice_result
        echo
        if [ -n "${push}" ]; then
            echo -e "${YELLOW}Pushing..."${ENDCOLOR}
            echo
            push_tag $tag_name
            exit
        fi
        delete_result=$(git tag -d $tag_name 2>&1)
        check_code $? "$delete_result" "delete tag"
        echo -e "${GREEN}Successfully deleted tag '${tag_name}'!${ENDCOLOR}"
        echo
        echo -e "Do you want to delete this tag in the ${YELLOW}${origin_name}${ENDCOLOR} (y/n)?"
        yes_no_choice "\nDeleting..."
        push_tag $tag_name "true"
        exit
    fi
    echo
    if [ -n "$select" ]; then
        echo -e "${YELLOW}Select a commit for a new tag on branch '$current_branch'${ENDCOLOR}"
        choose_commit 9
        echo
        echo -e "${YELLOW}Selected commit${ENDCOLOR}"
    else
        commit_hash=$(git rev-parse HEAD)
        echo -e "${YELLOW}Last branch commit${ENDCOLOR}"
    fi
    commit_message=$(git log -1 --pretty=%B $commit_hash | cat)
    echo -e "${BLUE}[$current_branch ${commit_hash::7}]${ENDCOLOR} ${commit_message}"
    echo
    echo -e "${YELLOW}Enter the name for a new tag${ENDCOLOR}"
    echo -e "If this is a release tag, use version number in semver format like '1.0.0-alpha'"
    echo -e "Press Enter if you want to exit"
    if [ -n "${annotated}" ]; then
        prompt="$(echo -n -e "${BOLD}git tag -a${ENDCOLOR} ")"
    else
        prompt="$(echo -n -e "${BOLD}git tag${ENDCOLOR} ")"
    fi
    read -p "$prompt" -e tag_name
    if [ -z "$tag_name" ]; then
        exit
    fi
    if [[ "$tag_name" == "tag" ]] || [[ "$tag_name" == *" "* ]]; then
        echo
        echo -e "${RED}This name is forbidden!${ENDCOLOR}"
        exit
    fi
    if [ -n "$annotated" ]; then
        tag_file=".tagmsg__"
        touch $tag_file
        echo """
####
#### Write some words about the new tag '${tag_name}'
#### [$current_branch ${commit_hash::7}] ${commit_message}
#### 
#### You can place changelog here if this tag for a new release
""" >> $tag_file
        while [ true ]; do
            $editor $tag_file
            tag_message=$(cat $tag_file | sed '/^#/d')
            if [ -n "$tag_message" ]; then
                break
            fi
            echo
            echo -e "${YELLOW}Tag message cannot be empty${ENDCOLOR}"
            echo
            read -n 1 -p "Do you want to try for one more time? (y/n) " -s -e choice
            if [ "$choice" != "y" ]; then
                find . -name "$tag_file*" -delete
                exit
            fi    
        done
        find . -name "$tag_file*" -delete
    fi
    if [ -z "$select" ]; then
        commit_hash=""
    fi
    echo
    if [ -n "$annotated" ]; then
        tag_output=$(git tag -a -m """$tag_message""" $tag_name $commit_hash 2>&1)
    else
        tag_output=$(git tag $tag_name $commit_hash 2>&1)
    fi
    tag_code=$?
    if [ $tag_code != 0 ]; then
        if [[ $tag_output == *"already exists" ]]; then
            echo -e "${RED}Tag '${tag_name}' already exists!${ENDCOLOR}"
        else
            echo -e "${RED}Cannot create tag '${tag_name}'! Error message:${ENDCOLOR}"
            echo -e "$tag_output"
        fi
        exit
    fi
    if [ -n "$annotated" ]; then
        is_annotated=" annotated"
    fi
    if [ -n "$select" ]; then
        is_commit_hash=" from commit '${commit_hash}'"
    fi
    echo -e "${GREEN}Successfully created${is_annotated} tag '${tag_name}'${is_commit_hash}!${ENDCOLOR}"
    if [ -n "$tag_message" ]; then
        echo -e "$tag_message"
    fi
    echo
    echo -e "Do you want to push it to the ${YELLOW}${origin_name}${ENDCOLOR} (y/n)?"
    yes_no_choice "\nPushing..."
    push_tag $tag_name
}
function reset_script {
    case "$1" in
        soft|s)         soft="true";;
        undo|u)         undo="true";;
        interactive|i)  interactive="true";;
        ref|r)          
            ref="true"
            interactive="true"
        ;;
        help|h) help="true";;
        *)
            wrong_mode "reset" $1
    esac
    header="GIT RESET"
    if [ -n "${ref}" ]; then
        header="$header REFERENCE"
    elif [ -n "${undo}" ]; then
        header="$header UNDO"
    elif [ -n "${soft}" ]; then
        header="$header --soft"
    elif [ -n "${help}" ]; then
        header="$header"
    else
        header="$header --mixed"
    fi
    echo -e "${YELLOW}${header}${ENDCOLOR}"
    echo
    if [ -n "$help" ]; then
        echo -e "usage: ${YELLOW}gitb reset <mode>${ENDCOLOR}"
        echo
        echo -e "${YELLOW}Available modes${ENDCOLOR}"
        echo -e "<empty>\t\tReset last commit (git reset HEAD^ --mixed)"
        echo -e "soft|s\t\tReset last commit, but remain all fiels staged (git reset HEAD^ --soft)"
        echo -e "undo|u\t\tUndo last commit reset (git reset HEAD@{1})"
        echo -e "interactive|i\tSelect a commit to reset"
        echo -e "ref|r\t\tSelect a HEAD reference to reset"
        echo -e "help|h\t\tShow this help"
        exit
    fi
    echo $soft
    cancelled_commit=$(git log -n 1 --pretty="%s | ${YELLOW}%h${ENDCOLOR} | ${CYAN}%cd${ENDCOLOR} (${GREEN}%cr${ENDCOLOR})")
    cancelled_action=$(git reflog -n 1 --pretty="%gs | ${YELLOW}%h${ENDCOLOR} |  ${CYAN}%cd${ENDCOLOR} (${GREEN}%cr${ENDCOLOR})")
    if [ -n "$interactive" ]; then
        if [ -n "$ref" ]; then
            echo -e "${YELLOW}Select a ref to move into:${ENDCOLOR}"
            ref_list 31
            echo "0. Exit..."
            echo
            printf "Enter ref number: "
            choose "${refs_hash[@]}"
            commit_hash=$choice_result
            echo
        else
            echo -e "${YELLOW}Select a commit to reset:${ENDCOLOR}"
            choose_commit 9
        fi
    fi
    move_ref="HEAD^"
    if [ -n "$undo" ]; then
        move_ref="HEAD@{1}"
    elif [ -n "$commit_hash" ]; then
        move_ref=$commit_hash
    fi
    args="--mixed"
    if [ -n "$soft" ]; then
        args="--soft"
    fi
    reset_output=$(git reset $args $move_ref 2>&1)
    check_code $? "$reset_output" "reset"
    new_commit=$(git log -n 1 --pretty="%s | ${YELLOW}%h${ENDCOLOR} | ${CYAN}%cd${ENDCOLOR} (${GREEN}%cr${ENDCOLOR})")
    new_action=$(git reflog -n 1 --pretty="%gs | ${YELLOW}%h${ENDCOLOR} | ${CYAN}%cd${ENDCOLOR} (${GREEN}%cr${ENDCOLOR})")
    msg="${GREEN}New last commit:${ENDCOLOR}|${new_commit}"
    if [ -n "$ref" ] || [ -n "$undo" ]; then
        msg="${msg}\n${GREEN}New last action:${ENDCOLOR}|${new_action}"
    fi
    msg="${msg}\n${RED}Cancelled commit:${ENDCOLOR}|${cancelled_commit}"
    if [ -n "$ref" ] || [ -n "$undo" ]; then
        msg="${msg}\n${RED}Cancelled action:${ENDCOLOR}|${cancelled_action}"
    fi
    msg=$(echo -e "$msg" | column -ts'|')
    echo -e "$msg"
    echo
    echo -e "${YELLOW}Status after reset${ENDCOLOR}"
    git_status
    exit
}
function select_files_for_stash {
    echo -e "${YELLOW}Select files to stash:${ENDCOLOR}"
    echo
    git_status
    echo
    echo -e "Enter file patterns or paths to stash (like ${BOLD}git add${ENDCOLOR} command)"
    echo "Press Enter if you want to exit"
    while [ true ]; do
        read -p "$(echo -n -e "${BOLD}files to stash${ENDCOLOR} ")" -e git_add
        git_add=$(echo "$git_add" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' -e "s/^'//" -e "s/'$//")
        if [ "$git_add" == "" ]; then
            exit
        fi
        test_result=$(git add --dry-run "$git_add" 2>&1)
        test_code=$?
        if [ $test_code -eq 0 ] && [ -n "$test_result" ]; then
            break
        else
            if [[ "$test_result" == *"did not match any files"* ]] && [[ "$git_add" != *"*" ]]; then
                git_add_with_star="${git_add}*"
                echo -e "${YELLOW}Trying with wildcard:${ENDCOLOR} ${BOLD}$git_add_with_star${ENDCOLOR}"
                test_result_star=$(git add --dry-run "$git_add_with_star" 2>&1)
                if [ $? -eq 0 ] && [ -n "$test_result_star" ]; then
                    git_add="$git_add_with_star"
                    break
                else
                    echo -e "${RED}No changed files match pattern: $git_add_with_star${ENDCOLOR}"
                    echo
                fi
            else
                echo -e "${RED}No changed files match pattern: $git_add${ENDCOLOR}"
                echo
            fi
        fi
    done
}
function list_stashes {
    IFS=$'\n' read -rd '' -a stashes_info <<<"$(git stash list --pretty=format:"${YELLOW_ES}%gd${ENDCOLOR_ES} | %s | ${BLUE_ES}%cr${ENDCOLOR_ES}")"
    IFS=$'\n' read -rd '' -a stashes_refs <<<"$(git stash list --pretty=format:"%gd")"
    if [ ${#stashes_info[@]} -eq 0 ]; then
        echo -e "${GREEN}No stashes found${ENDCOLOR}"
        return 1
    fi
    echo -e "${YELLOW}Available stashes:${ENDCOLOR}"
    echo
    for index in "${!stashes_info[@]}"; do
        stash_line="${stashes_info[index]}"
        formatted_line=$(echo "$stash_line" | sed 's/ | /\t/g')
        echo -e "$(($index+1)). $formatted_line"
    done
    echo
    return 0
}
function choose_stash {
    if ! list_stashes; then
        return 1
    fi
    if [ ${#stashes_refs[@]} -gt 9 ]; then
        echo "00. Exit"
    else
        echo "0. Exit"
    fi
    echo
    read_prefix="Select stash number: "
    choose "${stashes_refs[@]}"
    echo
    selected_stash=$choice_result
}
function show_stash {
    echo -e "${YELLOW}Stash details for $1${ENDCOLOR}"
    echo
    git stash show -p "$1"
}
function stash_script {
    case "$1" in
        select|sel)     select_mode="true";;
        all)            all_mode="true";;
        list|l)         list_mode="true";;
        pop|p)          pop_mode="true";;
        show|s)         show_mode="true";;
        drop|d)         drop_mode="true";;
        apply|a)        apply_mode="true";;
        help|h)         help="true";;
        *)
            if [ -n "$1" ]; then
                wrong_mode "stash" "$1"
            fi
            interactive="true"
    esac
    header_msg="GIT STASH"
    if [ -n "${select_mode}" ]; then
        header_msg="${YELLOW}$header_msg SELECT${ENDCOLOR}"
    elif [ -n "${all_mode}" ]; then
        header_msg="${YELLOW}$header_msg ALL${ENDCOLOR}"
    elif [ -n "${list_mode}" ]; then
        header_msg="${YELLOW}$header_msg LIST${ENDCOLOR}"
    elif [ -n "${pop_mode}" ]; then
        header_msg="${YELLOW}$header_msg POP${ENDCOLOR}"
    elif [ -n "${show_mode}" ]; then
        header_msg="${YELLOW}$header_msg SHOW${ENDCOLOR}"
    elif [ -n "${drop_mode}" ]; then
        header_msg="${RED}$header_msg DROP${ENDCOLOR}"
    elif [ -n "${apply_mode}" ]; then
        header_msg="${YELLOW}$header_msg APPLY${ENDCOLOR}"
    else
        header_msg="${YELLOW}$header_msg${ENDCOLOR}"
    fi
    echo -e "${header_msg}"
    echo
    if [ -n "$help" ]; then
        echo -e "usage: ${YELLOW}gitb stash <mode>${ENDCOLOR}"
        echo
        echo -e "${YELLOW}Available modes${ENDCOLOR}"
        echo -e "<empty>\t\tShow interactive menu"
        echo -e "select|sel\tSelect files to stash"
        echo -e "all\t\tStash all changes"
        echo -e "list|l\t\tList all stashes"
        echo -e "pop|p\t\tPop from selected stash"
        echo -e "show|s\t\tShow stash contents"
        echo -e "apply|a\t\tApply selected stash without removing it"
        echo -e "drop|d\t\tDrop selected stash"
        echo -e "help|h\t\tShow this help"
        exit
    fi
    if [ -n "$interactive" ]; then
        echo -e "${YELLOW}What do you want to do?${ENDCOLOR}"
        echo
        echo "1. Select files to stash"
        echo "2. Stash all changes"
        echo "3. List all stashes"
        echo "4. Pop from stash"
        echo "5. Show stash contents"
        echo "6. Apply stash (without removing)"
        echo "7. Drop stash"
        echo "0. Exit"
        read -n 1 -s choice
        echo
        case "$choice" in
            1) select_mode="true";;
            2) all_mode="true";;
            3) list_mode="true";;
            4) pop_mode="true";;
            5) show_mode="true";;
            6) apply_mode="true";;
            7) drop_mode="true";;
            0) exit;;
            *) echo -e "${RED}Invalid option${ENDCOLOR}"; exit 1;;
        esac
    fi
    if [ -n "$select_mode" ]; then
        select_files_for_stash
        echo
        echo -e "${YELLOW}Changed files to stash:${ENDCOLOR}"
        files_to_stash=$(git add --dry-run "$git_add" 2>/dev/null | sed 's/^add /\t/' | sed "s/'//g")
        echo -e "${GREEN}$files_to_stash${ENDCOLOR}"
        echo
        read -p "Enter stash message: " stash_message
        if [ -z "$stash_message" ]; then
            exit 0
        fi
        echo -e "${YELLOW}Stashing selected files...${ENDCOLOR}"
        echo
        result=$(git add "$git_add" 2>&1)
        if [ $? -ne 0 ]; then
            echo -e "${RED}Failed to stage files! Error:${ENDCOLOR}"
            echo "$result"
            exit 1
        fi
        stash_output=$(git stash push -m "$stash_message" --staged 2>&1)
        stash_code=$?
        if [ $stash_code -eq 0 ]; then
            echo -e "${GREEN}Successfully stashed selected files!${ENDCOLOR}"
            echo "$stash_output"
        else
            echo -e "${RED}Failed to stash files! Error:${ENDCOLOR}"
            echo "$stash_output"
            git restore --staged "$git_add" 2>/dev/null
            exit $stash_code
        fi
    fi
    if [ -n "$all_mode" ]; then
        if git diff --quiet && git diff --cached --quiet; then
            echo -e "${GREEN}No changes to stash${ENDCOLOR}"
            exit
        fi
        read -p "Enter stash message: " stash_message
        if [ -z "$stash_message" ]; then
            exit 0
        fi
        echo -e "${YELLOW}Stashing all changes...${ENDCOLOR}"
        echo
        stash_output=$(git stash push -m "$stash_message" --include-untracked 2>&1)
        stash_code=$?
        if [ $stash_code -eq 0 ]; then
            echo -e "${GREEN}Successfully stashed all changes!${ENDCOLOR}"
            echo "$stash_output"
        else
            echo -e "${RED}Failed to stash changes! Error:${ENDCOLOR}"
            echo "$stash_output"
            exit $stash_code
        fi
    fi
    if [ -n "$list_mode" ]; then
        if ! list_stashes; then
            exit
        fi
    fi
    if [ -n "$pop_mode" ]; then
        if ! choose_stash; then
            exit 1
        fi
        echo -e "${YELLOW}Popping from stash $selected_stash...${ENDCOLOR}"
        echo
        pop_output=$(git stash pop "$selected_stash" 2>&1)
        pop_code=$?
        if [ $pop_code -eq 0 ]; then
            echo -e "${GREEN}Successfully popped from stash!${ENDCOLOR}"
            echo "$pop_output"
        else
            echo -e "${RED}Failed to pop from stash! Error:${ENDCOLOR}"
            echo "$pop_output"
            exit $pop_code
        fi
    fi
    if [ -n "$show_mode" ]; then
        if ! choose_stash; then
            exit 1
        fi
        show_stash "$selected_stash"
    fi
    if [ -n "$apply_mode" ]; then
        if ! choose_stash; then
            exit 1
        fi
        echo -e "${YELLOW}Applying stash $selected_stash...${ENDCOLOR}"
        echo
        apply_output=$(git stash apply "$selected_stash" 2>&1)
        apply_code=$?
        if [ $apply_code -eq 0 ]; then
            echo -e "${GREEN}Successfully applied stash!${ENDCOLOR}"
            echo "$apply_output"
        else
            echo -e "${RED}Failed to apply stash! Error:${ENDCOLOR}"
            echo "$apply_output"
            exit $apply_code
        fi
    fi
    if [ -n "$drop_mode" ]; then
        if ! choose_stash; then
            exit 1
        fi
        echo
        echo -e "${RED}Are you sure you want to drop stash $selected_stash? This cannot be undone!${ENDCOLOR}"
        echo -e "Do you want to continue (y/n)?"
        yes_no_choice "Dropping stash"
        drop_output=$(git stash drop "$selected_stash" 2>&1)
        drop_code=$?
        if [ $drop_code -eq 0 ]; then
            echo -e "${GREEN}Successfully dropped stash!${ENDCOLOR}"
            echo "$drop_output"
        else
            echo -e "${RED}Failed to drop stash! Error:${ENDCOLOR}"
            echo "$drop_output"
            exit $drop_code
        fi
    fi
} 
function project_status {
    echo -e "${YELLOW}$project_name${ENDCOLOR} | ${CYAN}$repo_url${ENDCOLOR}"
    echo
    echo -e "${YELLOW}[$current_branch $(git log -n 1 --pretty="%h")]${ENDCOLOR}"
    echo -e "$(git --no-pager log -n 1 --pretty="%s")"
    echo -e "=============================="
    status=$(git_status)
    if [ -n "$status" ]; then
        echo -e "$status"
    else
        echo -e "${GREEN}There are no unstaged files${ENDCOLOR}"
    fi
}
function gitlog {
    git log --pretty="%C(Yellow)%h%C(reset) | %C(Cyan)%ad%C(reset) | %C(Blue)%an%C(reset) | %s (%C(Green)%cr%C(reset))"
}
function reflog {
    git reflog --pretty="%C(Yellow)%h%C(reset) | %C(Blue)%gd%C(reset) | %C(Cyan)%ad%C(reset) | %gs (%C(Green)%cr%C(reset))"
}
function last_commit {
    git --no-pager log -n 1 --pretty="%C(Yellow)%h%C(reset) | %s | %C(Blue)%an%C(reset) | %C(Green)%cr%C(reset) | %C(Cyan)%ad%C(reset)" 
}
function last_ref {
    git --no-pager reflog -n 1 --pretty="%C(Yellow)%h%C(reset) | %C(Cyan)%gd%C(reset) | %gs | %C(Green)%cr%C(reset) | %C(Cyan)%ad%C(reset)"
}
function print_help {
    echo -e "usage: ${YELLOW}gitb <command> <mode>${ENDCOLOR}"
    echo
    msg="${YELLOW}Command${ENDCOLOR}_\t${GREEN}Aliases${ENDCOLOR}_\t${BLUE}Description of ${BOLD}workflow${NORMAL}${BLUE} commands${ENDCOLOR}"
    msg="$msg\ncommit_c|co|com_Everything about commit creation"
    msg="$msg\npush_p|ps|pus_Pushing changes to a remote repository"
    msg="$msg\npull_pu|pl|pul_Pulling changes from a remote repository"
    msg="$msg\nbranch_b|br|bran_Managing branches"
    msg="$msg\ntag_t|tg_Managing tags"
    msg="$msg\nmerge_m|me_Merge changes to the current branch"
    msg="$msg\nrebase_r|re|base_Rebase current branch"
    msg="$msg\nreset_res_Easy to use git reset"
    msg="$msg\nstash_s|sta_Manage git stashes"
    msg="$msg\nconfig_cf|cfg|conf_Configurate gitbasher"
    msg="$msg\n_ _ _"
    msg="$msg\n${YELLOW}Command${ENDCOLOR}_\t${GREEN}Aliases${ENDCOLOR}_\t${BLUE}Description of ${BOLD}informational${NORMAL}${BLUE} commands${ENDCOLOR}"
    msg="$msg\nstatus_st_Info about repo and changed files"
    msg="$msg\nlog_l|lg_Open git log in a pretty format"
    msg="$msg\nreflog_rl|rlg_Open git reflog in a pretty format"
    msg="$msg\nlast-commit_lc|lastc_Show info about the last commit"
    msg="$msg\nlast-ref_lr|lastr_Show info about the last reference"
    echo -e "$(echo -e "$msg" | column -ts '_')"
    exit
}
project_name="$(get_repo_name)"
repo_url="$(get_repo)"
if [ $is_first == "true" ]; then 
    git config --local gitbasher.scopes ""
    echo -e "${GREEN}Thanks for using gitbasher in project '$project_name'${ENDCOLOR}"
    print_configuration
    echo
    echo -e "You can change these settings by using ${YELLOW}gitb cfg <name>${ENDCOLOR}"
    echo
fi
if [ -z $1 ] || [ "$1" == "--help" ] || [ "$1" == "help" ] || [ "$1" == "man" ]; then
    print_help
fi
case "$1" in
    commit|c|co|com)         
        commit_script $2
    ;;
    push|p|ps|pus)         
        push_script $2
    ;;
    pull|pu|pl|pul)         
        pull_script $2
    ;;
    merge|m|me)         
        merge_script $2
    ;;
    rebase|r|re|base)         
        rebase_script $2
    ;;
    branch|b|br|bran)         
        branch_script $2
    ;;
    tag|t|tg)         
        tag_script $2
    ;;
    config|cf|cfg|conf)         
        config_script $2
    ;;
    reset|res)
        reset_script $2
    ;;
    stash|s|sta)
        stash_script $2
    ;;
    log|l|lg)
        gitlog
    ;;
    reflog|rl|rlg)
        reflog
    ;;
    last-commit|lc|lastc)
        last_commit
    ;;
    last-ref|lr|lastr)
        last_ref
    ;;
    status|st)
        project_status
    ;;
    *)
        print_help
    ;;
esac
exit $?
